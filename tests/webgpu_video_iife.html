<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - equirectangular video panorama</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../three.js/examples/main.css">
	<style>
		body {
			touch-action: none;
		}
	</style>
</head>

<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - video panorama
	</div>

	<div id="container"></div>

	<video id="video" loop muted autoplay crossOrigin="anonymous" preload="metadata" playsinline style="display:none">

	</video>

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script async src="../build/three-webgpu.js"></script>


	<script type="module">



		//import * as THREE from 'three';
	

		let _requestVideoFrameCallback = false;

		class CustomVideoTexture extends THREE.Texture {

			constructor(video) {
				super(video, THREE.Texture.DEFAULT_MAPPING, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBAFormat);

				this.generateMipmaps = false;

				const updateVideo = () => {

					this.needsUpdate = true;
					video.requestVideoFrameCallback(updateVideo);

				}

				if ('requestVideoFrameCallback' in video) {

					_requestVideoFrameCallback = true;

					video.requestVideoFrameCallback(updateVideo);

				}

			}

			get isVideoTexture() {
				return true;
			}

			update() {
				if (!_requestVideoFrameCallback) this.needsUpdate = true;
			}

		}


		let camera, scene, renderer;

		let isUserInteracting = false,
			lon = 0, lat = 0,
			phi = 0, theta = 0,
			onPointerDownPointerX = 0,
			onPointerDownPointerY = 0,
			onPointerDownLon = 0,
			onPointerDownLat = 0;

		const distance = 50;

		const video = document.getElementById('video');
		video.src = "//videos.electroteque.org/360/ultra_light_flight_720p.mp4";
		video.play();

		video.addEventListener("loadedmetadata", () => {
			console.log("loadedmetadata");
			init();
		});




		async function init() {

			const container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);

			scene = new THREE.Scene();

			const geometry = new THREE.SphereGeometry(500, 60, 40);
			// invert the geometry on the x-axis so that all of the faces point inward
			geometry.scale(- 1, 1, 1);



			const texture = new CustomVideoTexture(video);

			//texture.colorSpace = THREE.SRGBColorSpace;

			//texture.colorSpace = THREE.LinearSRGBColorSpace;
			let material;

			if (await WebGPU.isAvailable()) {
				console.log("Using WebGPU");
				renderer = new WebGPURenderer();
				texture.colorSpace = THREE.SRGBColorSpace;
				material = new THREE.MeshBasicMaterial({ map: texture });
				
			} else {
				console.log("Using WebGL");
				renderer = new THREE.WebGLRenderer();
				//texture.colorSpace = THREE.LinearSRGBColorSpace;

				//use shader material for performance srgb decode fix
				/*material = new THREE.ShaderMaterial( {
					uniforms: { map: { value: texture }, color: new THREE.Color( 0xffffff ) },
					vertexShader: `
						#define attribute in
						#define varying out
						#define texture2D texture
						precision highp float;
						precision highp int;

						varying vec2 vUv;
						varying vec3 vClipPosition;

						void main() {
							vUv = vec3( uv, 1 ).xy;
							//vec3 transformed = vec3( position );
							vec4 mvPosition = vec4( position, 1.0 );
							mvPosition = modelViewMatrix * mvPosition;
							gl_Position = projectionMatrix * mvPosition;
		
						}
					`,
					fragmentShader: `
						uniform sampler2D map;
						varying vec2 vUv;
						
						void main() {
							gl_FragColor = texture2D( map, vUv );
							//gl_FragColor = linearToOutputTexel( gl_FragColor );
							gl_FragColor.rgb *= gl_FragColor.a;
						}
					`
				});

				material.color = new THREE.Color( 0xffffff );*/


				/*material = new THREE.MeshBasicMaterial({ map: texture });

				material.onBeforeCompile = function (shader) {

					shader.fragmentShader = shader.fragmentShader.replace(
						'#include <map_fragment>',
						`
						#ifdef USE_MAP
						
							vec4 sampledDiffuseColor = texture2D( map, vMapUv );
						
							// inline sRGB decode
							sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.a );

							diffuseColor *= sampledDiffuseColor;

						#endif

						`
					);

				};*/

				material = new LinearSRGBMaterial({ map: texture });

			}


			const mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);



			//renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
			//renderer.colorSpace = THREE.LinearSRGBColorSpace;
			//renderer.outputColorSpace = THREE.SRGBColorSpace;
			//renderer.colorSpace = THREE.SRGBColorSpace;

			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			//renderer.setSize(video.videoWidth, video.videoHeight );

			container.appendChild(renderer.domElement);

			document.addEventListener('pointerdown', onPointerDown);
			document.addEventListener('pointermove', onPointerMove);
			document.addEventListener('pointerup', onPointerUp);

			//

			await renderer.init();

			//window.addEventListener( 'resize', onWindowResize );

			renderer.setAnimationLoop( update);

			//animate();

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function onPointerDown(event) {

			isUserInteracting = true;

			onPointerDownPointerX = event.clientX;
			onPointerDownPointerY = event.clientY;

			onPointerDownLon = lon;
			onPointerDownLat = lat;

		}

		function onPointerMove(event) {

			if (isUserInteracting === true) {

				lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
				lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;

			}

		}

		function onPointerUp() {

			isUserInteracting = false;

		}

		function animate() {

			requestAnimationFrame(animate);
			update();

		}

		function update() {

			lat = Math.max(- 85, Math.min(85, lat));
			phi = THREE.MathUtils.degToRad(90 - lat);
			theta = THREE.MathUtils.degToRad(lon);

			camera.position.x = distance * Math.sin(phi) * Math.cos(theta);
			camera.position.y = distance * Math.cos(phi);
			camera.position.z = distance * Math.sin(phi) * Math.sin(theta);

			camera.lookAt(0, 0, 0);

			renderer.render(scene, camera);

		}

	</script>
</body>

</html>