/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
import{DynamicDrawUsage as e,Uint32BufferAttribute as t,Uint16BufferAttribute as s,Color as r,Vector2 as n,Vector3 as i,Vector4 as o,Matrix3 as a,Matrix4 as l,MathUtils as u,LinearSRGBColorSpace as c,SRGBColorSpace as d,TangentSpaceNormalMap as h,ObjectSpaceNormalMap as p,StaticDrawUsage as m,InterleavedBuffer as g,InterleavedBufferAttribute as f,InstancedInterleavedBuffer as x,DepthTexture as b,NearestFilter as N,ShaderMaterial as y,NoColorSpace as v,Material as T,sRGBEncoding as _,LinearEncoding as S,Float16BufferAttribute as w,REVISION as C,NoToneMapping as A,LinearToneMapping as R,ReinhardToneMapping as M,CineonToneMapping as E,ACESFilmicToneMapping as B,FramebufferTexture as U,LinearMipmapLinearFilter as O,UnsignedIntType as I,DepthFormat as F,EventDispatcher as L,PointLight as D,DirectionalLight as G,SpotLight as k,AmbientLight as z,HemisphereLight as P,LineBasicMaterial as V,MeshNormalMaterial as $,MeshBasicMaterial as q,MeshPhongMaterial as j,MeshStandardMaterial as W,MeshPhysicalMaterial as H,PointsMaterial as X,SpriteMaterial as Y,MaterialLoader as Z,DepthStencilFormat as K,UnsignedInt248Type as J,BackSide as Q,Mesh as ee,SphereGeometry as te,EquirectangularReflectionMapping as se,EquirectangularRefractionMapping as re,Frustum as ne,DoubleSide as ie,FrontSide as oe,WebGLRenderTarget as ae,WebGLCubeRenderTarget as le,BoxGeometry as ue,NoBlending as ce,Scene as de,LinearFilter as he,CubeCamera as pe,CustomBlending as me,MultiplyBlending as ge,SubtractiveBlending as fe,AdditiveBlending as xe,NormalBlending as be,SrcAlphaSaturateFactor as Ne,OneMinusDstAlphaFactor as ye,DstAlphaFactor as ve,OneMinusDstColorFactor as Te,DstColorFactor as _e,OneMinusSrcAlphaFactor as Se,SrcAlphaFactor as we,OneMinusSrcColorFactor as Ce,SrcColorFactor as Ae,OneFactor as Re,ZeroFactor as Me,NotEqualStencilFunc as Ee,GreaterStencilFunc as Be,GreaterEqualStencilFunc as Ue,EqualStencilFunc as Oe,LessEqualStencilFunc as Ie,LessStencilFunc as Fe,AlwaysStencilFunc as Le,NeverStencilFunc as De,DecrementWrapStencilOp as Ge,IncrementWrapStencilOp as ke,DecrementStencilOp as ze,IncrementStencilOp as Pe,InvertStencilOp as Ve,ReplaceStencilOp as $e,ZeroStencilOp as qe,KeepStencilOp as je,MaxEquation as We,MinEquation as He,ReverseSubtractEquation as Xe,SubtractEquation as Ye,AddEquation as Ze,NotEqualDepth as Ke,GreaterDepth as Je,GreaterEqualDepth as Qe,EqualDepth as et,LessEqualDepth as tt,LessDepth as st,AlwaysDepth as rt,NeverDepth as nt,CubeReflectionMapping as it,CubeRefractionMapping as ot,Texture as at,CubeTexture as lt,FloatType as ut,RGFormat as ct,RedFormat as dt,RGBAFormat as ht,NeverCompare as pt,AlwaysCompare as mt,LessCompare as gt,LessEqualCompare as ft,EqualCompare as xt,GreaterEqualCompare as bt,GreaterCompare as Nt,NotEqualCompare as yt,RepeatWrapping as vt,MirroredRepeatWrapping as Tt,NearestMipmapNearestFilter as _t,NearestMipmapLinearFilter as St,RGBA_ASTC_12x12_Format as wt,RGBA_ASTC_12x10_Format as Ct,RGBA_ASTC_10x10_Format as At,RGBA_ASTC_10x8_Format as Rt,RGBA_ASTC_10x6_Format as Mt,RGBA_ASTC_10x5_Format as Et,RGBA_ASTC_8x8_Format as Bt,RGBA_ASTC_8x6_Format as Ut,RGBA_ASTC_8x5_Format as Ot,RGBA_ASTC_6x6_Format as It,RGBA_ASTC_6x5_Format as Ft,RGBA_ASTC_5x5_Format as Lt,RGBA_ASTC_5x4_Format as Dt,RGBA_ASTC_4x4_Format as Gt,RGBA_ETC2_EAC_Format as kt,RGB_ETC2_Format as zt,RGBA_S3TC_DXT5_Format as Pt,RGBA_S3TC_DXT3_Format as Vt,RGBA_S3TC_DXT1_Format as $t,UnsignedShortType as qt,HalfFloatType as jt,UnsignedByteType as Wt,WebGPUCoordinateSystem as Ht}from"three";class Xt{static async isAvailable(){if(void 0!==navigator.gpu)try{if(null!==await navigator.gpu.requestAdapter())return void 0===window.GPUShaderStage&&(window.GPUShaderStage={VERTEX:1,FRAGMENT:2,COMPUTE:4}),!0}catch(e){return!1}return!1}}class Yt{constructor(){this.nodes=null,this.animationLoop=null,this.requestId=null,this.isAnimating=!1,this.context=self}start(){if(!0===this.isAnimating||null===this.animationLoop||null===this.nodes)return;this.isAnimating=!0;const e=(t,s)=>{this.requestId=self.requestAnimationFrame(e),this.nodes.nodeFrame.update(),this.animationLoop(t,s)};this.requestId=self.requestAnimationFrame(e)}stop(){self.cancelAnimationFrame(this.requestId),this.isAnimating=!1}setAnimationLoop(e){this.animationLoop=e}setNodes(e){this.nodes=e}}class Zt{constructor(){this.data=new WeakMap}get(e){let t=this.data.get(e);return void 0===t&&(t={},this.data.set(e,t)),t}delete(e){let t;return this.data.has(e)&&(t=this.data.get(e),this.data.delete(e)),t}has(e){return this.data.has(e)}dispose(){this.data.clear()}}class Kt{constructor(){this.weakMap=new WeakMap}get(e){if(Array.isArray(e)){let t=this.weakMap;for(let s=0;s<e.length-1;s++)if(t=t.get(e[s]),void 0===t)return;return t.get(e[e.length-1])}return super.get(e)}set(e,t){if(Array.isArray(e)){let s=this.weakMap;for(let t=0;t<e.length-1;t++){const r=e[t];!1===s.has(r)&&s.set(r,new WeakMap),s=s.get(r)}return s.set(e[e.length-1],t)}return super.set(e,t)}delete(e){if(Array.isArray(e)){let t=this.weakMap;for(let s=0;s<e.length-1;s++)if(t=t.get(e[s]),void 0===t)return!1;return t.delete(e[e.length-1])}return super.delete(e)}dispose(){this.weakMap.clear()}}let Jt=0;class Qt{constructor(e,t,s,r,n,i,o,a){this._nodes=e,this._geometries=t,this.id=Jt++,this.renderer=s,this.object=r,this.material=n,this.scene=i,this.camera=o,this.lightsNode=a,this.geometry=r.geometry,this.attributes=null,this.context=null,this.pipeline=null,this.vertexBuffers=null,this._materialVersion=-1,this._materialCacheKey="",this.onDispose=null,this.onMaterialDispose=()=>{this.dispose()},this.material.addEventListener("dispose",this.onMaterialDispose)}getNodeBuilder(){return this._nodes.getForRender(this)}getBindings(){return this.getNodeBuilder().getBindings()}getIndex(){return this._geometries.getIndex(this)}getChainArray(){return[this.object,this.material,this.scene,this.camera,this.lightsNode]}getAttributes(){if(null!==this.attributes)return this.attributes;const e=this.getNodeBuilder().getAttributesArray(),t=this.geometry,s=[],r=new Set;for(const n of e){const e=n.node&&n.node.attribute?n.node.attribute:t.getAttribute(n.name);s.push(e);const i=e.isInterleavedBufferAttribute?e.data:e;r.add(i)}return this.attributes=s,this.vertexBuffers=Array.from(r.values()),s}getVertexBuffers(){return null===this.vertexBuffers&&this.getAttributes(),this.vertexBuffers}getCacheKey(){const{material:e,scene:t,lightsNode:s}=this;e.version!==this._materialVersion&&(this._materialVersion=e.version,this._materialCacheKey=e.customProgramCacheKey());const r=[];return r.push("material:"+this._materialCacheKey),r.push("nodes:"+this._nodes.getCacheKey(t,s)),"{"+r.join(",")+"}"}dispose(){this.material.removeEventListener("dispose",this.onMaterialDispose),this.onDispose()}}class es{constructor(e,t,s,r,n){this.renderer=e,this.nodes=t,this.geometries=s,this.pipelines=r,this.info=n,this.chainMaps={},this.dataMap=new Zt}get(e,t,s,r,n,i){const o=this.getChainMap(i),a=[e,t,s,r,n];let l=o.get(a);if(void 0===l)l=this.createRenderObject(this.nodes,this.geometries,this.renderer,e,t,s,r,n,i),o.set(a,l);else{const i=this.dataMap.get(l),o=l.getCacheKey();i.cacheKey!==o&&(l.dispose(),l=this.get(e,t,s,r,n))}return l}getChainMap(e="default"){return this.chainMaps[e]||(this.chainMaps[e]=new Kt)}dispose(){this.chainMaps={},this.dataMap=new Zt}createRenderObject(e,t,s,r,n,i,o,a,l){const u=this.getChainMap(l),c=this.dataMap,d=new Qt(e,t,s,r,n,i,o,a);return c.get(d).cacheKey=d.getCacheKey(),d.onDispose=()=>{c.delete(d),this.pipelines.delete(d),this.nodes.delete(d),u.delete(d.getChainArray())},d}}const ts=1,ss=2,rs=4,ns=16;class is extends Zt{constructor(e){super(),this.backend=e}delete(e){void 0!==super.delete(e)&&this.backend.destroyAttribute(e)}update(t,s){const r=this.get(t);if(void 0===r.version)s===ts?this.backend.createAttribute(t):s===ss?this.backend.createIndexAttribute(t):s===rs&&this.backend.createStorageAttribute(t),r.version=this._getBufferAttribute(t).version;else{const s=this._getBufferAttribute(t);(r.version<s.version||s.usage===e)&&(this.backend.updateAttribute(t),r.version=s.version)}}_getBufferAttribute(e){return e.isInterleavedBufferAttribute&&(e=e.data),e}}function os(e){return null!==e.index?e.index.version:e.attributes.position.version}function as(e){const r=[],n=e.index,i=e.attributes.position;if(null!==n){const e=n.array;for(let t=0,s=e.length;t<s;t+=3){const s=e[t+0],n=e[t+1],i=e[t+2];r.push(s,n,n,i,i,s)}}else{for(let e=0,t=i.array.length/3-1;e<t;e+=3){const t=e+0,s=e+1,n=e+2;r.push(t,s,s,n,n,t)}}const o=new(function(e){for(let t=e.length-1;t>=0;--t)if(e[t]>=65535)return!0;return!1}(r)?t:s)(r,1);return o.version=os(e),o}class ls extends Zt{constructor(e,t){super(),this.attributes=e,this.info=t,this.wireframes=new WeakMap,this.attributeFrame=new WeakMap}has(e){const t=e.geometry;return super.has(t)&&!0===this.get(t).initialized}update(e){!1===this.has(e)&&this.initGeometry(e),this.updateAttributes(e)}initGeometry(e){const t=e.geometry;this.get(t).initialized=!0,this.info.memory.geometries++;const s=()=>{this.info.memory.geometries--;const r=t.index,n=e.getAttributes();null!==r&&this.attributes.delete(r);for(const e of n)this.attributes.delete(e);const i=this.wireframes.get(t);void 0!==i&&this.attributes.delete(i),t.removeEventListener("dispose",s)};t.addEventListener("dispose",s)}updateAttributes(e){const t=e.getAttributes();for(const e of t)this.updateAttribute(e,ts);const s=this.getIndex(e);null!==s&&this.updateAttribute(s,ss)}updateAttribute(e,t){const s=this.info.render.frame;this.attributeFrame.get(e)!==s&&(this.attributes.update(e,t),this.attributeFrame.set(e,s))}getIndex(e){const{geometry:t,material:s}=e;let r=t.index;if(!0===s.wireframe){const e=this.wireframes;let s=e.get(t);void 0===s?(s=as(t),e.set(t,s)):s.version!==os(t)&&(this.attributes.delete(s),s=as(t),e.set(t,s)),r=s}return r}}class us{constructor(){this.autoReset=!0,this.render={frame:0,drawCalls:0,triangles:0,points:0,lines:0},this.memory={geometries:0,textures:0}}update(e,t,s){this.render.drawCalls++,e.isMesh||e.isSprite?this.render.triangles+=s*(t/3):e.isPoints?this.render.points+=s*t:e.isLineSegments?this.render.lines+=s*(t/2):e.isLine&&(this.render.lines+=s*(t-1))}reset(){this.render.drawCalls=0,this.render.triangles=0,this.render.points=0,this.render.lines=0}dispose(){this.reset(),this.render.frame=0,this.memory.geometries=0,this.memory.textures=0}}class cs{constructor(e){this.cacheKey=e,this.usedTimes=0}}class ds extends cs{constructor(e,t,s){super(e),this.vertexProgram=t,this.fragmentProgram=s}}class hs extends cs{constructor(e,t){super(e),this.computeProgram=t,this.isComputePipeline=!0}}let ps=0;class ms{constructor(e,t){this.id=ps++,this.code=e,this.stage=t,this.usedTimes=0}}class gs extends Zt{constructor(e,t){super(),this.backend=e,this.nodes=t,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(e){const{backend:t}=this,s=this.get(e);if(void 0===s.pipeline){const r=this._releasePipeline(e),n=this.nodes.getForCompute(e);let i=this.programs.compute.get(n.computeShader);void 0===i&&(r&&this._releaseProgram(r.computeShader),i=new ms(n.computeShader,"compute"),this.programs.compute.set(n.computeShader,i),t.createProgram(i));const o=this._getComputePipeline(i);o.usedTimes++,i.usedTimes++,s.pipeline=o}return s.pipeline}getForRender(e){const{backend:t}=this,s=this.get(e);if(this._needsUpdate(e)){const r=this._releasePipeline(e),n=this.nodes.getForRender(e);let i=this.programs.vertex.get(n.vertexShader);void 0===i&&(r&&this._releaseProgram(r.vertexProgram),i=new ms(n.vertexShader,"vertex"),this.programs.vertex.set(n.vertexShader,i),t.createProgram(i));let o=this.programs.fragment.get(n.fragmentShader);void 0===o&&(r&&this._releaseProgram(r.fragmentShader),o=new ms(n.fragmentShader,"fragment"),this.programs.fragment.set(n.fragmentShader,o),t.createProgram(o));const a=this._getRenderPipeline(e,i,o);a.usedTimes++,i.usedTimes++,o.usedTimes++,s.pipeline=a}return s.pipeline}delete(e){const t=this._releasePipeline(e);t&&0===t.usedTimes&&(t.isComputePipeline?this._releaseProgram(t.computeProgram):(this._releaseProgram(t.vertexProgram),this._releaseProgram(t.fragmentProgram))),super.delete(e)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}_getComputePipeline(e){const t="compute:"+e.id;let s=this.caches.get(t);return void 0===s&&(s=new hs(t,e),this.caches.set(t,s),this.backend.createComputePipeline(s)),s}_getRenderPipeline(e,t,s){const r=this._getRenderCacheKey(e,t,s);let n=this.caches.get(r);return void 0===n?(n=new ds(r,t,s),this.caches.set(r,n),e.pipeline=n,this.backend.createRenderPipeline(e)):e.pipeline=n,n}_getRenderCacheKey(e,t,s){const{material:r}=e;return[t.id,s.id,r.transparent,r.blending,r.premultipliedAlpha,r.blendSrc,r.blendDst,r.blendEquation,r.blendSrcAlpha,r.blendDstAlpha,r.blendEquationAlpha,r.colorWrite,r.depthWrite,r.depthTest,r.depthFunc,r.stencilWrite,r.stencilFunc,r.stencilFail,r.stencilZFail,r.stencilZPass,r.stencilFuncMask,r.stencilWriteMask,r.side,this.backend.getCacheKey(e)].join()}_releasePipeline(e){const t=this.get(e).pipeline;return t&&0==--t.usedTimes&&this.caches.delete(t.cacheKey),t}_releaseProgram(e){if(0==--e.usedTimes){const t=e.code,s=e.stage;this.programs[s].delete(t)}}_needsUpdate(e){const t=this.get(e),s=e.material;let r=this.backend.needsUpdate(e);return t.material===s&&t.materialVersion===s.version&&t.transparent===s.transparent&&t.blending===s.blending&&t.premultipliedAlpha===s.premultipliedAlpha&&t.blendSrc===s.blendSrc&&t.blendDst===s.blendDst&&t.blendEquation===s.blendEquation&&t.blendSrcAlpha===s.blendSrcAlpha&&t.blendDstAlpha===s.blendDstAlpha&&t.blendEquationAlpha===s.blendEquationAlpha&&t.colorWrite===s.colorWrite&&t.depthWrite===s.depthWrite&&t.depthTest===s.depthTest&&t.depthFunc===s.depthFunc&&t.stencilWrite===s.stencilWrite&&t.stencilFunc===s.stencilFunc&&t.stencilFail===s.stencilFail&&t.stencilZFail===s.stencilZFail&&t.stencilZPass===s.stencilZPass&&t.stencilFuncMask===s.stencilFuncMask&&t.stencilWriteMask===s.stencilWriteMask&&t.side===s.side||(t.material=s,t.materialVersion=s.version,t.transparent=s.transparent,t.blending=s.blending,t.premultipliedAlpha=s.premultipliedAlpha,t.blendSrc=s.blendSrc,t.blendDst=s.blendDst,t.blendEquation=s.blendEquation,t.blendSrcAlpha=s.blendSrcAlpha,t.blendDstAlpha=s.blendDstAlpha,t.blendEquationAlpha=s.blendEquationAlpha,t.colorWrite=s.colorWrite,t.depthWrite=s.depthWrite,t.depthTest=s.depthTest,t.depthFunc=s.depthFunc,t.stencilWrite=s.stencilWrite,t.stencilFunc=s.stencilFunc,t.stencilFail=s.stencilFail,t.stencilZFail=s.stencilZFail,t.stencilZPass=s.stencilZPass,t.stencilFuncMask=s.stencilFuncMask,t.stencilWriteMask=s.stencilWriteMask,t.side=s.side,r=!0),r||void 0!==t.pipeline}}class fs extends Zt{constructor(e,t,s,r,n,i){super(),this.backend=e,this.textures=s,this.pipelines=n,this.attributes=r,this.nodes=t,this.info=i,this.pipelines.bindings=this,this.updateMap=new WeakMap}getForRender(e){const t=e.getBindings(),s=this.get(e);if(s.bindings!==t){s.bindings=t,this._init(t);const r=this.pipelines.getForRender(e);this.backend.createBindings(t,r)}return s.bindings}getForCompute(e){const t=this.get(e);if(void 0===t.bindings){const s=this.nodes.getForCompute(e).getBindings();t.bindings=s,this._init(s);const r=this.pipelines.getForCompute(e);this.backend.createBindings(s,r)}return t.bindings}updateForCompute(e){this._update(e,this.getForCompute(e))}updateForRender(e){this._update(e,this.getForRender(e))}_init(e){for(const t of e)if(t.isSampler||t.isSampledTexture)this.textures.updateTexture(t.texture);else if(t.isStorageBuffer){const e=t.attribute;this.attributes.update(e,rs)}}_update(e,t){const{backend:s}=this,r=this.updateMap,n=this.info.render.frame;let i=!1;for(const e of t){const t=e.isShared,o=r.get(e)===n;if(!t||!o){if(e.isUniformBuffer){e.update()&&s.updateBinding(e)}else if(e.isSampledTexture){e.needsBindingsUpdate&&(i=!0);e.update()&&this.textures.updateTexture(e.texture)}r.set(e,n)}}if(!0===i){const s=this.pipelines.getForRender(e);this.backend.updateBindings(t,s)}}dispose(){super.dispose(),this.updateMap=new WeakMap}}const xs="vertex",bs="none",Ns="frame",ys="render",vs="object",Ts=["construct","analyze","generate"],_s=["fragment","vertex","compute"],Ss=["x","y","z","w"];function ws(e){let t="{";!0===e.isNode&&(t+=`uuid:"${e.uuid}"`);for(const{property:s,index:r,childNode:n}of Cs(e)){let e=ws(n);e.includes(",")||(e=e.slice(e.indexOf('"'),e.indexOf("}"))),t+=`,${s}${void 0!==r?"/"+r:""}:${e}`}return t+="}",t}function*Cs(e,t=!1){for(const s in e){if(!0===s.startsWith("_"))continue;const r=e[s];if(!0===Array.isArray(r))for(let e=0;e<r.length;e++){const n=r[e];n&&(!0===n.isNode||t&&"function"==typeof n.toJSON)&&(yield{property:s,index:e,childNode:n})}else if(r&&!0===r.isNode)yield{property:s,childNode:r};else if("object"==typeof r)for(const e in r){const n=r[e];n&&(!0===n.isNode||t&&"function"==typeof n.toJSON)&&(yield{property:s,index:e,childNode:n})}}}function As(e){if(null==e)return null;const t=typeof e;return!0===e.isNode?"node":"number"===t?"float":"boolean"===t?"bool":"string"===t?"string":"function"===t?"shader":!0===e.isVector2?"vec2":!0===e.isVector3?"vec3":!0===e.isVector4?"vec4":!0===e.isMatrix3?"mat3":!0===e.isMatrix4?"mat4":!0===e.isColor?"color":e instanceof ArrayBuffer?"ArrayBuffer":null}function Rs(e,...t){const s=e?e.slice(-4):void 0;return"vec2"!==s&&"vec3"!==s&&"vec4"!==s||1!==t.length||(t="vec2"===s?[t[0],t[0]]:[t[0],t[0],t[0]]),"color"===e?new r(...t):"vec2"===s?new n(...t):"vec3"===s?new i(...t):"vec4"===s?new o(...t):"mat3"===s?new a(...t):"mat4"===s?new l(...t):"bool"===e?t[0]||!1:"float"===e||"int"===e||"uint"===e?t[0]||0:"string"===e?t[0]||"":"ArrayBuffer"===e?Es(t[0]):null}function Ms(e){let t="";const s=new Uint8Array(e);for(let e=0;e<s.length;e++)t+=String.fromCharCode(s[e]);return btoa(t)}function Es(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0))).buffer}const Bs=new Map;let Us=0;class Os{constructor(e=null){this.isNode=!0,this.nodeType=e,this.updateType=bs,this.updateBeforeType=bs,this.uuid=u.generateUUID(),Object.defineProperty(this,"id",{value:Us++})}get type(){return this.constructor.name}isGlobal(){return!1}*getChildren(){const e=this;for(const{property:t,index:s,childNode:r}of Cs(this))yield{childNode:r,replaceNode(r){void 0===s?e[t]=r:e[t][s]=r}}}traverse(e,t=null){e(this,t);for(const{childNode:t,replaceNode:s}of this.getChildren())t.traverse(e,s)}getCacheKey(){return ws(this)}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getNodeType(){return this.nodeType}getReference(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}construct(e){const t=e.getNodeProperties(this);for(const{childNode:e}of this.getChildren())t["_node"+e.id]=e;return null}analyze(e){const t=e.getDataFromNode(this);if(t.dependenciesCount=void 0===t.dependenciesCount?1:t.dependenciesCount+1,1===t.dependenciesCount){const t=e.getNodeProperties(this);for(const s of Object.values(t))s&&!0===s.isNode&&s.build(e)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&!0===s.isNode)return s.build(e,t)}updateBefore(){}update(){}build(e,t=null){const s=this.getReference(e);if(this!==s)return s.build(e,t);e.addNode(this),e.addChain(this);let r=null;const n=e.getBuildStage();if("construct"===n){const t=e.getNodeProperties(this);if(!0!==t.initialized||!1===e.context.tempRead){const s=e.stack.nodes.length;t.initialized=!0,t.outputNode=this.construct(e),null!==t.outputNode&&e.stack.nodes.length!==s&&(t.outputNode=e.stack);for(const s of Object.values(t))s&&!0===s.isNode&&s.build(e)}}else if("analyze"===n)this.analyze(e);else if("generate"===n){if(1===this.generate.length){const s=this.getNodeType(e),n=e.getDataFromNode(this);r=n.snippet,void 0===r&&(r=this.generate(e)||"",n.snippet=r),r=e.format(r,s,t)}else r=this.generate(e,t)||""}return e.removeChain(this),r}getSerializeChildren(){return Cs(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:r,index:n,childNode:i}of t)void 0!==n?(void 0===s[r]&&(s[r]=Number.isInteger(n)?[]:{}),s[r][n]=i.toJSON(e.meta).uuid):s[r]=i.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(void 0!==e.inputNodes){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const r=[];for(const n of e.inputNodes[s])r.push(t[n]);this[s]=r}else if("object"==typeof e.inputNodes[s]){const r={};for(const n in e.inputNodes[s]){const i=e.inputNodes[s][n];r[n]=t[i]}this[s]=r}else{const r=e.inputNodes[s];this[s]=t[r]}}}toJSON(e){const{uuid:t,type:s}=this,r=void 0===e||"string"==typeof e;r&&(e={textures:{},images:{},nodes:{}});let n=e.nodes[t];function i(e){const t=[];for(const s in e){const r=e[s];delete r.metadata,t.push(r)}return t}if(void 0===n&&(n={uuid:t,type:s,meta:e,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},!0!==r&&(e.nodes[n.uuid]=n),this.serialize(n),delete n.meta),r){const t=i(e.textures),s=i(e.images),r=i(e.nodes);t.length>0&&(n.textures=t),s.length>0&&(n.images=s),r.length>0&&(n.nodes=r)}return n}}function Is(e){if("function"!=typeof e||!e.name)throw new Error(`Node class ${e.name} is not a class`);if(Bs.has(e.name))throw new Error(`Redefinition of node class ${e.name}`);Bs.set(e.name,e)}class Fs extends Os{constructor(e,t=null){super(t),this.isInputNode=!0,this.value=e,this.precision=null}getNodeType(){return null===this.nodeType?As(this.value):this.nodeType}getInputType(e){return this.getNodeType(e)}setPrecision(e){return this.precision=e,this}serialize(e){super.serialize(e),e.value=this.value,this.value&&this.value.toArray&&(e.value=this.value.toArray()),e.valueType=As(this.value),e.nodeType=this.nodeType,"ArrayBuffer"===e.valueType&&(e.value=Ms(e.value)),e.precision=this.precision}deserialize(e){super.deserialize(e),this.nodeType=e.nodeType,this.value=Array.isArray(e.value)?Rs(e.valueType,...e.value):e.value,this.precision=e.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(e.value))}generate(){}}Is(Fs);class Ls extends Os{constructor(e,t){super(),this.node=e,this.indexNode=t}getNodeType(e){return this.node.getNodeType(e)}generate(e){return`${this.node.build(e)}[ ${this.indexNode.build(e,"uint")} ]`}}Is(Ls);class Ds extends Os{constructor(e,t){super(),this.node=e,this.convertTo=t}getNodeType(e){const t=this.node.getNodeType(e);let s=null;for(const r of this.convertTo.split("|"))null!==s&&e.getTypeLength(t)!==e.getTypeLength(r)||(s=r);return s}serialize(e){super.serialize(e),e.convertTo=this.convertTo}deserialize(e){super.deserialize(e),this.convertTo=e.convertTo}generate(e,t){const s=this.node,r=this.getNodeType(e),n=s.build(e,r);return e.format(n,r,t)}}Is(Ds);class Gs extends Os{constructor(e){super(e),this.isTempNode=!0}hasDependencies(e){return e.getDataFromNode(this).dependenciesCount>1}build(e,t){if("generate"===e.getBuildStage()){const s=e.getVectorType(this.getNodeType(e,t)),r=e.getDataFromNode(this);if(!1!==e.context.tempRead&&void 0!==r.propertyName)return e.format(r.propertyName,s,t);if(!1!==e.context.tempWrite&&"void"!==s&&"void"!==t&&this.hasDependencies(e)){const n=super.build(e,s),i=e.getVarFromNode(this,s),o=e.getPropertyName(i);return e.addLineFlowCode(`${o} = ${n}`),r.snippet=n,r.propertyName=o,e.format(r.propertyName,s,t)}}return super.build(e,t)}}Is(Gs);class ks extends Gs{constructor(e=[],t=null){super(t),this.nodes=e}getNodeType(e){return null!==this.nodeType?e.getVectorType(this.nodeType):e.getTypeFromLength(this.nodes.reduce(((t,s)=>t+e.getTypeLength(s.getNodeType(e))),0))}generate(e,t){const s=this.getNodeType(e),r=this.nodes,n=[];for(const t of r){const s=t.build(e);n.push(s)}const i=`${e.getType(s)}( ${n.join(", ")} )`;return e.format(i,s,t)}}Is(ks);const zs=Ss.join("");class Ps extends Os{constructor(e,t="x"){super(),this.node=e,this.components=t}getVectorLength(){let e=this.components.length;for(const t of this.components)e=Math.max(Ss.indexOf(t)+1,e);return e}getNodeType(e){return e.getTypeFromLength(this.components.length)}generate(e,t){const s=this.node,r=e.getTypeLength(s.getNodeType(e));let n=null;if(r>1){let i=null;this.getVectorLength()>=r&&(i=e.getTypeFromLength(this.getVectorLength()));const o=s.build(e,i);n=this.components.length===r&&this.components===zs.slice(0,this.components.length)?e.format(o,i,t):e.format(`${o}.${this.components}`,this.getNodeType(e),t)}else n=s.build(e,t);return n}serialize(e){super.serialize(e),e.components=this.components}deserialize(e){super.deserialize(e),this.components=e.components}}Is(Ps);class Vs extends Fs{constructor(e,t=null){super(e,t),this.isConstNode=!0}generateConst(e){return e.getConst(this.getNodeType(e),this.value)}generate(e,t){const s=this.getNodeType(e);return e.format(this.generateConst(e),s,t)}}Is(Vs);const $s=new Map;function qs(e,t){if($s.has(e))throw new Error(`Redefinition of node element ${e}`);if("function"!=typeof t)throw new Error(`Node element ${e} is not a function`);$s.set(e,t)}const js={construct(e,t){const s=t.shift();return e(hr(s),...t)},get:function(e,t,s){if("string"==typeof t&&void 0===e[t]){if($s.has(t)){const e=$s.get(t);return(...t)=>e(s,...t)}if(t.endsWith("Assign")&&$s.has(t.slice(0,t.length-6))){const e=$s.get(t.slice(0,t.length-6));return(...t)=>s.assign(e(s,...t))}if(!0===/^[xyzwrgbastpq]{1,4}$/.test(t))return t=t.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),dr(new Ps(e,t));if("width"===t||"height"===t)return dr(new Ps(e,"width"===t?"x":"y"));if(!0===/^\d+$/.test(t))return dr(new Ls(e,new Vs(Number(t),"uint")))}return e[t]}},Ws=new WeakMap,Hs=function(e,t=null){for(const s in e)e[s]=dr(e[s],t);return e},Xs=function(e,t=null){const s=e.length;for(let r=0;r<s;r++)e[r]=dr(e[r],t);return e},Ys=function(e,t=null,s=null,r=null){const n=e=>dr(null!==r?Object.assign(e,r):e);return null===t?(...t)=>n(new e(...pr(t))):null!==s?(s=dr(s),(...r)=>n(new e(t,...pr(r),s))):(...s)=>n(new e(t,...pr(s)))},Zs=function(e,...t){return dr(new e(...pr(t)))};class Ks extends Os{constructor(e){super(),this._jsFunc=e}call(e,t,s){return e=hr(e),dr(this._jsFunc(e,t,s))}getNodeType(e){const{outputNode:t}=e.getNodeProperties(this);return t?t.getNodeType(e):super.getNodeType(e)}construct(e){return e.addStack(),e.stack.outputNode=dr(this._jsFunc(e.stack,e)),e.removeStack()}}const Js=[!1,!0],Qs=[0,1,2,3],er=[-1,-2],tr=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],sr=new Map;for(const e of Js)sr.set(e,new Vs(e));const rr=new Map;for(const e of Qs)rr.set(e,new Vs(e,"uint"));const nr=new Map([...rr].map((e=>new Vs(e.value,"int"))));for(const e of er)nr.set(e,new Vs(e,"int"));const ir=new Map([...nr].map((e=>new Vs(e.value))));for(const e of tr)ir.set(e,new Vs(e));for(const e of tr)ir.set(-e,new Vs(-e));const or={bool:sr,uint:rr,ints:nr,float:ir},ar=new Map([...sr,...ir]),lr=(e,t)=>ar.has(e)?ar.get(e):!0===e.isNode?e:new Vs(e,t),ur=function(e,t=null){return(...s)=>{if((0===s.length||!["bool","float","int","uint"].includes(e)&&s.every((e=>"object"!=typeof e)))&&(s=[Rs(e,...s)]),1===s.length&&null!==t&&t.has(s[0]))return dr(t.get(s[0]));if(1===s.length){const t=lr(s[0],e);return(e=>{try{return e.getNodeType()}catch{return}})(t)===e?dr(t):dr(new Ds(t,e))}const r=s.map((e=>lr(e)));return dr(new ks(r,e))}};function cr(e){return new Proxy(new Ks(e),js)}const dr=(e,t=null)=>function(e,t=null){const s=As(e);if("node"===s){let t=Ws.get(e);return void 0===t&&(t=new Proxy(e,js),Ws.set(e,t),Ws.set(t,t)),t}return null===t&&("float"===s||"boolean"===s)||s&&"shader"!==s&&"string"!==s?dr(lr(e,t)):"shader"===s?xr(e):e}(e,t),hr=(e,t=null)=>new Hs(e,t),pr=(e,t=null)=>new Xs(e,t),mr=(...e)=>new Ys(...e),gr=(...e)=>new Zs(...e),fr=e=>new cr(e),xr=e=>{let t=null;return(...s)=>(null===t&&(t=new cr(e)),t.call(...s))};Is(cr);const br=new ur("color"),Nr=new ur("float",or.float),yr=new ur("int",or.int),vr=new ur("uint",or.uint),Tr=new ur("bool",or.bool),_r=new ur("vec2"),Sr=new ur("ivec2"),wr=new ur("uvec2"),Cr=new ur("bvec2"),Ar=new ur("vec3"),Rr=new ur("ivec3"),Mr=new ur("uvec3"),Er=new ur("bvec3"),Br=new ur("vec4"),Ur=new ur("ivec4"),Or=new ur("uvec4"),Ir=new ur("bvec4"),Fr=new ur("mat3"),Lr=new ur("imat3"),Dr=new ur("umat3"),Gr=new ur("bmat3"),kr=new ur("mat4"),zr=new ur("imat4"),Pr=new ur("umat4"),Vr=new ur("bmat4");qs("color",br),qs("float",Nr),qs("int",yr),qs("uint",vr),qs("bool",Tr),qs("vec2",_r),qs("ivec2",Sr),qs("uvec2",wr),qs("bvec2",Cr),qs("vec3",Ar),qs("ivec3",Rr),qs("uvec3",Mr),qs("bvec3",Er),qs("vec4",Br),qs("ivec4",Ur),qs("uvec4",Or),qs("bvec4",Ir),qs("mat3",Fr),qs("imat3",Lr),qs("umat3",Dr),qs("bmat3",Gr),qs("mat4",kr),qs("imat4",zr),qs("umat4",Pr),qs("bmat4",Vr),qs("string",((e="")=>dr(new Vs(e,"string")))),qs("arrayBuffer",(e=>dr(new Vs(e,"ArrayBuffer"))));qs("element",mr(Ls)),qs("convert",((e,t)=>dr(new Ds(dr(e),t))));class $r extends Fs{constructor(e,t=null){super(e,t),this.isUniformNode=!0}getUniformHash(e){return this.getHash(e)}generate(e,t){const s=this.getNodeType(e),r=this.getUniformHash(e);let n=e.getNodeFromHash(r);void 0===n&&(e.setHashNode(this,r),n=this);const i=n.getInputType(e),o=e.getUniformFromNode(n,i,e.shaderStage,e.context.label),a=e.getPropertyName(o);return e.format(a,s,t)}}const qr=(e,t)=>{const s=(e=>null!=e?e.nodeType||e.convertTo||("string"==typeof e?e:null):null)(t||e),r=e&&!0===e.isNode?e.node&&e.node.value||e.value:e;return dr(new $r(r,s))};Is($r);Is(class ArrayUniformNode extends $r{constructor(e=[]){super(),this.isArrayUniformNode=!0,this.nodes=e}getNodeType(e){return this.nodes[0].getNodeType(e)}});class jr extends Os{constructor(e,t=null){super(),this.node=e,this.name=t}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{name:t,node:s}=this,r=this.getNodeType(e),n=e.getVaryingFromNode(this,r);n.needsInterpolation||(n.needsInterpolation="fragment"===e.shaderStage),null!==t&&(n.name=t);const i=e.getPropertyName(n,xs);return e.flowNodeFromShaderStage(xs,s,r,i),e.getPropertyName(n)}}const Wr=mr(jr);qs("varying",Wr),Is(jr);class Hr extends Os{constructor(e,t=null){super(t),this._attributeName=e}getHash(e){return this.getAttributeName(e)}getNodeType(e){const t=this.getAttributeName(e);let s=super.getNodeType(e);if(null===s)if(e.hasGeometryAttribute(t)){const r=e.geometry.getAttribute(t);s=e.getTypeFromAttribute(r)}else s="float";return s}setAttributeName(e){return this._attributeName=e,this}getAttributeName(){return this._attributeName}generate(e){const t=this.getAttributeName(e),s=this.getNodeType(e);if(!0===e.hasGeometryAttribute(t)){const r=e.geometry.getAttribute(t),n=e.getTypeFromAttribute(r),i=e.getAttribute(t,n);if("vertex"===e.shaderStage)return e.format(i.name,n,s);return Wr(this).build(e,s)}return e.getConst(s)}}const Xr=(e,t)=>dr(new Hr(e,t));Is(Hr);class Yr extends Os{constructor(e,t){super(),this.isBypassNode=!0,this.outputNode=e,this.callNode=t}getNodeType(e){return this.outputNode.getNodeType(e)}generate(e){const t=this.callNode.build(e,"void");return""!==t&&e.addLineFlowCode(t),this.outputNode.build(e)}}const Zr=mr(Yr);qs("bypass",Zr),Is(Yr);let Kr=0;class Jr{constructor(){this.id=Kr++,this.nodesData=new WeakMap}getNodeData(e){return this.nodesData.get(e)}setNodeData(e,t){this.nodesData.set(e,t)}}class Qr extends Os{constructor(e,t=new Jr){super(),this.isCacheNode=!0,this.node=e,this.cache=t}getNodeType(e){return this.node.getNodeType(e)}build(e,...t){const s=e.getCache();e.setCache(this.cache);const r=this.node.build(e,...t);return e.setCache(s),r}}const en=mr(Qr);qs("cache",en),Is(Qr);class tn extends Os{constructor(e,t={}){super(),this.isContextNode=!0,this.node=e,this.context=t}getNodeType(e){return this.node.getNodeType(e)}construct(e){const t=e.getContext();e.setContext({...e.context,...this.context});const s=this.node.build(e);return e.setContext(t),s}generate(e,t){const s=e.getContext();e.setContext({...e.context,...this.context});const r=this.node.build(e,t);return e.setContext(s),r}}const sn=mr(tn),rn=(e,t)=>sn(e,{label:t});qs("context",sn),qs("label",rn),Is(tn);class nn extends Os{constructor(e){super("uint"),this.scope=e,this.isInstanceIndexNode=!0}generate(e){const t=this.getNodeType(e),s=this.scope;let r,n;if(s===nn.VERTEX)r=e.getVertexIndex();else{if(s!==nn.INSTANCE)throw new Error("THREE.IndexNode: Unknown scope: "+s);r=e.getInstanceIndex()}if("vertex"===e.shaderStage||"compute"===e.shaderStage)n=r;else{n=Wr(this).build(e,t)}return n}}nn.VERTEX="vertex",nn.INSTANCE="instance",gr(nn,nn.VERTEX);const on=gr(nn,nn.INSTANCE);Is(nn);class an{constructor(e=null,t=null,s=null,r=null,n=null){this.init=e,this.direct=t,this.indirectDiffuse=s,this.indirectSpecular=r,this.ambientOcclusion=n}}const ln=(...e)=>new an(...e);class un{constructor(e,t,s=null){this.isNodeAttribute=!0,this.name=e,this.type=t,this.node=s}}class cn{constructor(e,t,s,r=void 0){this.isNodeUniform=!0,this.name=e,this.type=t,this.node=s,this.needsUpdate=r}get value(){return this.node.value}set value(e){this.node.value=e}}class dn{constructor(e,t){this.isNodeVar=!0,this.name=e,this.type=t}}class hn extends dn{constructor(e,t){super(e,t),this.needsInterpolation=!1,this.isNodeVarying=!0}}class pn{constructor(e,t,s=""){this.name=e,this.type=t,this.code=s,Object.defineProperty(this,"isNodeCode",{value:!0})}}class mn{constructor(){this.keywords=[],this.nodes=[],this.keywordsCallback={}}getNode(e){let t=this.nodes[e];return void 0===t&&void 0!==this.keywordsCallback[e]&&(t=this.keywordsCallback[e](e),this.nodes[e]=t),t}addKeyword(e,t){return this.keywords.push(e),this.keywordsCallback[e]=t,this}parse(e){const t=this.keywords,s=new RegExp(`\\b${t.join("\\b|\\b")}\\b`,"g"),r=e.match(s),n=[];if(null!==r)for(const e of r){const t=this.getNode(e);void 0!==t&&-1===n.indexOf(t)&&n.push(t)}return n}include(e,t){const s=this.parse(t);for(const t of s)t.build(e)}}class gn extends Os{constructor(e,t=null){super(e),this.name=t}getHash(e){return this.name||super.getHash(e)}isGlobal(){return!0}generate(e){const t=e.getVarFromNode(this,this.getNodeType(e)),s=this.name;return null!==s&&(t.name=s),e.getPropertyName(t)}}const fn=(e,t)=>dr(new gn(e,t)),xn=gr(gn,"vec4","DiffuseColor"),bn=gr(gn,"float","Roughness"),Nn=gr(gn,"float","Metalness"),yn=gr(gn,"float","Clearcoat"),vn=gr(gn,"float","ClearcoatRoughness"),Tn=gr(gn,"vec3","Sheen"),_n=gr(gn,"float","SheenRoughness"),Sn=gr(gn,"color","SpecularColor"),wn=gr(gn,"float","Shininess");Is(gn);class Cn extends Hr{constructor(e=0){super(null,"vec2"),this.isUVNode=!0,this.index=e}getAttributeName(){const e=this.index;return"uv"+(e>0?e:"")}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}const An=(...e)=>dr(new Cn(...e));Is(Cn);class Rn extends Os{constructor(e,t=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=e,this.levelNode=t}generate(e,t){const s=this.textureNode.build(e,"property"),r=this.levelNode.build(e,"int");return e.format(`textureDimensions( ${s}, ${r} )`,this.getNodeType(e),t)}}const Mn=mr(Rn);qs("textureSize",Mn),Is(Rn);class En extends Gs{constructor(e,t,s,...r){if(super(),this.op=e,r.length>0){let t=s;for(let s=0;s<r.length;s++)t=new En(e,t,r[s]);s=t}this.aNode=t,this.bNode=s}hasDependencies(e){return"="!==this.op&&super.hasDependencies(e)}getNodeType(e,t){const s=this.op,r=this.aNode,n=this.bNode,i=r.getNodeType(e),o=n.getNodeType(e);if("void"===i||"void"===o)return"void";if("="===s||"%"===s)return i;if("&"===s||"|"===s||"^"===s||">>"===s||"<<"===s)return e.getIntegerType(i);if("=="===s||"&&"===s||"||"===s||"^^"===s)return"bool";if("<"===s||">"===s||"<="===s||">="===s){const s=t?e.getTypeLength(t):Math.max(e.getTypeLength(i),e.getTypeLength(o));return s>1?`bvec${s}`:"bool"}return"float"===i&&e.isMatrix(o)?o:e.isMatrix(i)&&e.isVector(o)?e.getVectorFromMatrix(i):e.isVector(i)&&e.isMatrix(o)?e.getVectorFromMatrix(o):e.getTypeLength(o)>e.getTypeLength(i)?o:i}generate(e,t){const s=this.op,r=this.aNode,n=this.bNode,i=this.getNodeType(e,t);let o=null,a=null;"void"!==i?(o=r.getNodeType(e),a=n.getNodeType(e),"="===s?a=o:"<"===s||">"===s||"<="===s||">="===s||"=="===s?e.isVector(o)?a=o:o=a="float":">>"===s||"<<"===s?(o=i,a=e.changeComponentType(a,"uint")):e.isMatrix(o)&&e.isVector(a)?a=e.getVectorFromMatrix(o):o=e.isVector(o)&&e.isMatrix(a)?e.getVectorFromMatrix(a):a=i):o=a=i;const l=r.build(e,o),u=n.build(e,a),c=e.getTypeLength(t);return"void"!==t?"="===s?(e.addLineFlowCode(`${l} ${this.op} ${u}`),l):"<"===s&&c>1?e.format(`${e.getMethod("lessThan")}( ${l}, ${u} )`,i,t):"<="===s&&c>1?e.format(`${e.getMethod("lessThanEqual")}( ${l}, ${u} )`,i,t):">"===s&&c>1?e.format(`${e.getMethod("greaterThan")}( ${l}, ${u} )`,i,t):">="===s&&c>1?e.format(`${e.getMethod("greaterThanEqual")}( ${l}, ${u} )`,i,t):e.format(`( ${l} ${this.op} ${u} )`,i,t):"void"!==o?e.format(`${l} ${this.op} ${u}`,i,t):void 0}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}const Bn=mr(En,"+"),Un=mr(En,"-"),On=mr(En,"*"),In=mr(En,"/"),Fn=mr(En,"%"),Ln=mr(En,"=="),Dn=mr(En,"="),Gn=mr(En,"<"),kn=mr(En,">"),zn=mr(En,"<="),Pn=mr(En,">="),Vn=mr(En,"&&"),$n=mr(En,"||"),qn=mr(En,"^^"),jn=mr(En,"&"),Wn=mr(En,"|"),Hn=mr(En,"^"),Xn=mr(En,"<<"),Yn=mr(En,">>");qs("add",Bn),qs("sub",Un),qs("mul",On),qs("div",In),qs("remainder",Fn),qs("equal",Ln),qs("assign",Dn),qs("lessThan",Gn),qs("greaterThan",kn),qs("lessThanEqual",zn),qs("greaterThanEqual",Pn),qs("and",Vn),qs("or",$n),qs("xor",qn),qs("bitAnd",jn),qs("bitOr",Wn),qs("bitXor",Hn),qs("shiftLeft",Xn),qs("shiftRight",Yn),Is(En);class Zn extends Gs{constructor(e,t,s=null,r=null){super(),this.method=e,this.aNode=t,this.bNode=s,this.cNode=r}getInputType(e){const t=this.aNode.getNodeType(e),s=this.bNode?this.bNode.getNodeType(e):null,r=this.cNode?this.cNode.getNodeType(e):null,n=e.isMatrix(t)?0:e.getTypeLength(t),i=e.isMatrix(s)?0:e.getTypeLength(s),o=e.isMatrix(r)?0:e.getTypeLength(r);return n>i&&n>o?t:i>o?s:o>n?r:t}getNodeType(e){const t=this.method;return t===Zn.LENGTH||t===Zn.DISTANCE||t===Zn.DOT?"float":t===Zn.CROSS?"vec3":this.getInputType(e)}generate(e,t){const s=this.method,r=this.getNodeType(e),n=this.getInputType(e),i=this.aNode,o=this.bNode,a=this.cNode,l=!0===e.renderer.isWebGLRenderer;if(s===Zn.TRANSFORM_DIRECTION){let s=i,r=o;e.isMatrix(s.getNodeType(e))?r=Br(Ar(r),0):s=Br(Ar(s),0);const n=On(s,r).xyz;return li(n).build(e,t)}if(s===Zn.NEGATE)return e.format("-"+i.build(e,n),r,t);if(s===Zn.ONE_MINUS)return Un(1,i).build(e,t);if(s===Zn.RECIPROCAL)return In(1,i).build(e,t);if(s===Zn.DIFFERENCE)return fi(Un(i,o)).build(e,t);{const u=[];return s===Zn.CROSS?u.push(i.build(e,r),o.build(e,r)):s===Zn.STEP?u.push(i.build(e,1===e.getTypeLength(i.getNodeType(e))?"float":n),o.build(e,n)):l&&(s===Zn.MIN||s===Zn.MAX)||s===Zn.MOD?u.push(i.build(e,n),o.build(e,1===e.getTypeLength(o.getNodeType(e))?"float":n)):s===Zn.REFRACT?u.push(i.build(e,n),o.build(e,n),a.build(e,"float")):s===Zn.MIX?u.push(i.build(e,n),o.build(e,n),a.build(e,1===e.getTypeLength(a.getNodeType(e))?"float":n)):(u.push(i.build(e,n)),null!==o&&u.push(o.build(e,n)),null!==a&&u.push(a.build(e,n))),e.format(`${e.getMethod(s)}( ${u.join(", ")} )`,r,t)}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}Zn.RADIANS="radians",Zn.DEGREES="degrees",Zn.EXP="exp",Zn.EXP2="exp2",Zn.LOG="log",Zn.LOG2="log2",Zn.SQRT="sqrt",Zn.INVERSE_SQRT="inversesqrt",Zn.FLOOR="floor",Zn.CEIL="ceil",Zn.NORMALIZE="normalize",Zn.FRACT="fract",Zn.SIN="sin",Zn.COS="cos",Zn.TAN="tan",Zn.ASIN="asin",Zn.ACOS="acos",Zn.ATAN="atan",Zn.ABS="abs",Zn.SIGN="sign",Zn.LENGTH="length",Zn.NEGATE="negate",Zn.ONE_MINUS="oneMinus",Zn.DFDX="dFdx",Zn.DFDY="dFdy",Zn.ROUND="round",Zn.RECIPROCAL="reciprocal",Zn.TRUNC="trunc",Zn.FWIDTH="fwidth",Zn.ATAN2="atan2",Zn.MIN="min",Zn.MAX="max",Zn.MOD="mod",Zn.STEP="step",Zn.REFLECT="reflect",Zn.DISTANCE="distance",Zn.DIFFERENCE="difference",Zn.DOT="dot",Zn.CROSS="cross",Zn.POW="pow",Zn.TRANSFORM_DIRECTION="transformDirection",Zn.MIX="mix",Zn.CLAMP="clamp",Zn.REFRACT="refract",Zn.SMOOTHSTEP="smoothstep",Zn.FACEFORWARD="faceforward";const Kn=Nr(1e-6);Nr(1e6);const Jn=mr(Zn,Zn.RADIANS),Qn=mr(Zn,Zn.DEGREES),ei=mr(Zn,Zn.EXP),ti=mr(Zn,Zn.EXP2),si=mr(Zn,Zn.LOG),ri=mr(Zn,Zn.LOG2),ni=mr(Zn,Zn.SQRT),ii=mr(Zn,Zn.INVERSE_SQRT),oi=mr(Zn,Zn.FLOOR),ai=mr(Zn,Zn.CEIL),li=mr(Zn,Zn.NORMALIZE),ui=mr(Zn,Zn.FRACT),ci=mr(Zn,Zn.SIN),di=mr(Zn,Zn.COS),hi=mr(Zn,Zn.TAN),pi=mr(Zn,Zn.ASIN),mi=mr(Zn,Zn.ACOS),gi=mr(Zn,Zn.ATAN),fi=mr(Zn,Zn.ABS),xi=mr(Zn,Zn.SIGN),bi=mr(Zn,Zn.LENGTH),Ni=mr(Zn,Zn.NEGATE),yi=mr(Zn,Zn.ONE_MINUS),vi=mr(Zn,Zn.DFDX),Ti=mr(Zn,Zn.DFDY),_i=mr(Zn,Zn.ROUND),Si=mr(Zn,Zn.RECIPROCAL),wi=mr(Zn,Zn.TRUNC),Ci=mr(Zn,Zn.FWIDTH),Ai=mr(Zn,Zn.ATAN2),Ri=mr(Zn,Zn.MIN),Mi=mr(Zn,Zn.MAX),Ei=mr(Zn,Zn.MOD),Bi=mr(Zn,Zn.STEP),Ui=mr(Zn,Zn.REFLECT),Oi=mr(Zn,Zn.DISTANCE),Ii=mr(Zn,Zn.DIFFERENCE),Fi=mr(Zn,Zn.DOT),Li=mr(Zn,Zn.CROSS),Di=mr(Zn,Zn.POW),Gi=mr(Zn,Zn.POW,2),ki=mr(Zn,Zn.POW,3),zi=mr(Zn,Zn.POW,4),Pi=mr(Zn,Zn.TRANSFORM_DIRECTION),Vi=mr(Zn,Zn.MIX),$i=(e,t=0,s=1)=>dr(new Zn(Zn.CLAMP,dr(e),dr(t),dr(s))),qi=mr(Zn,Zn.REFRACT),ji=mr(Zn,Zn.SMOOTHSTEP),Wi=mr(Zn,Zn.FACEFORWARD);qs("radians",Jn),qs("degrees",Qn),qs("exp",ei),qs("exp2",ti),qs("log",si),qs("log2",ri),qs("sqrt",ni),qs("inverseSqrt",ii),qs("floor",oi),qs("ceil",ai),qs("normalize",li),qs("fract",ui),qs("sin",ci),qs("cos",di),qs("tan",hi),qs("asin",pi),qs("acos",mi),qs("atan",gi),qs("abs",fi),qs("sign",xi),qs("length",bi),qs("negate",Ni),qs("oneMinus",yi),qs("dFdx",vi),qs("dFdy",Ti),qs("round",_i),qs("reciprocal",Si),qs("trunc",wi),qs("fwidth",Ci),qs("atan2",Ai),qs("min",Ri),qs("max",Mi),qs("mod",Ei),qs("step",Bi),qs("reflect",Ui),qs("distance",Oi),qs("dot",Fi),qs("cross",Li),qs("pow",Di),qs("pow2",Gi),qs("pow3",ki),qs("pow4",zi),qs("transformDirection",Pi),qs("mix",((e,t,s)=>Vi(t,s,e))),qs("clamp",$i),qs("refract",qi),qs("smoothstep",((e,t,s)=>ji(t,s,e))),qs("faceForward",Wi),qs("difference",Ii),qs("saturate",(e=>$i(e))),Is(Zn);const Hi=xr((e=>{const{value:t}=e,{rgb:s}=t,r=s.mul(.9478672986).add(.0521327014).pow(2.4),n=s.mul(.0773993808),i=s.lessThanEqual(.04045),o=Vi(r,n,i);return Br(o,t.a)})),Xi=xr((e=>{const{value:t}=e,{rgb:s}=t,r=s.pow(.41666).mul(1.055).sub(.055),n=s.mul(12.92),i=s.lessThanEqual(.0031308),o=Vi(r,n,i);return Br(o,t.a)})),Yi=e=>{let t=null;return e===c?t="Linear":e===d&&(t="sRGB"),t},Zi=(e,t)=>Yi(e)+"To"+Yi(t);class Ki extends Gs{constructor(e,t){super("vec4"),this.method=e,this.node=t}construct(){const{method:e,node:t}=this;return e===Ki.LINEAR_TO_LINEAR?t:Ji[e]({value:t})}}Ki.LINEAR_TO_LINEAR="LinearToLinear",Ki.LINEAR_TO_sRGB="LinearTosRGB",Ki.sRGB_TO_LINEAR="sRGBToLinear";const Ji={[Ki.LINEAR_TO_sRGB]:Xi,[Ki.sRGB_TO_LINEAR]:Hi},Qi=(e,t)=>dr(new Ki(Zi(t,c),dr(e))),eo=mr(Ki,Ki.LINEAR_TO_sRGB),to=mr(Ki,Ki.sRGB_TO_LINEAR);qs("linearTosRGB",eo),qs("sRGBToLinear",to),qs("linearToColorSpace",((e,t)=>dr(new Ki(Zi(c,t),dr(e))))),qs("colorSpaceToLinear",Qi),Is(Ki);class so extends Os{constructor(e="",t="void"){super(t),this.snippet=e}generate(e,t){const s=this.getNodeType(e),r=this.snippet;if("void"!==s)return e.format(`( ${r} )`,s,t);e.addLineFlowCode(r)}}const ro=mr(so);Is(so);class no extends $r{constructor(e,t=null,s=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=s,this.updateType=Ns}getUniformHash(){return this.value.uuid}getNodeType(){return!0===this.value.isDepthTexture?"float":"vec4"}getInputType(){return"texture"}getDefaultUV(){const e=this.value;return qr(e.matrix).mul(Ar(An(e.channel),1))}construct(e){const t=e.getNodeProperties(this);let s=this.uvNode;null===s&&e.context.getUVNode&&(s=e.context.getUVNode(this)),s||(s=this.getDefaultUV());let r=this.levelNode;null===r&&e.context.getSamplerLevelNode&&(r=e.context.getSamplerLevelNode(this)),t.uvNode=s,t.levelNode=r?e.context.getMIPLevelAlgorithmNode(this,r):null}generate(e,t){const{uvNode:s,levelNode:r}=e.getNodeProperties(this),n=this.value;if(!n||!0!==n.isTexture)throw new Error("TextureNode: Need a three.js texture.");const i=super.generate(e,"property");if("sampler"===t)return i+"_sampler";if(e.isReference(t))return i;{const o=this.getNodeType(e),a=e.getDataFromNode(this);let l=a.propertyName;if(void 0===l){const t=s.build(e,"vec2"),u=e.getVarFromNode(this,o);l=e.getPropertyName(u);let c=null;if(r&&!0===r.isNode){const s=r.build(e,"float");c=e.getTextureLevel(n,i,t,s)}else c=e.getTexture(n,i,t);e.addLineFlowCode(`${l} = ${c}`),a.snippet=c,a.propertyName=l}let u=l;return e.needsColorSpaceToLinear(this.value)&&(u=Qi(ro(u,o),this.value.colorSpace).construct(e).build(e,o)),e.format(u,o,t)}}uv(e){const t=this.clone();return t.uvNode=e,t}level(e){const t=this.clone();return t.levelNode=e,sn(t,{getMIPLevelAlgorithmNode:(e,t)=>t})}size(e){return Mn(this,e)}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value]}update(){const e=this.value;!0===e.matrixAutoUpdate&&e.updateMatrix()}clone(){return new this.constructor(this.value,this.uvNode,this.levelNode)}}const io=mr(no);qs("texture",io),Is(no);class oo extends Os{constructor(e,t,s=null){super(),this.property=e,this.uniformType=t,this.object=s,this.node=null,this.updateType=vs,this.setNodeType(t)}setNodeType(e){let t=null;t="texture"===e?io(null):qr(e),this.node=t}getNodeType(e){return this.node.getNodeType(e)}update(e){const t=null!==this.object?this.object:e.object,s=this.property;this.node.value=t[s]}construct(){return this.node}}const ao=(e,t,s)=>dr(new oo(e,t,s));Is(oo);class MaterialReferenceNode extends oo{constructor(e,t,s=null){super(e,t,s),this.material=s}construct(e){const t=null!==this.material?this.material:e.material;return this.node.value=t[this.property],super.construct(e)}update(e){this.object=null!==this.material?this.material:e.material,super.update(e)}}const lo=(e,t,s)=>dr(new MaterialReferenceNode(e,t,s));Is(MaterialReferenceNode);class MaterialNode extends Os{constructor(e){super(),this.scope=e}getNodeType(e){const t=this.scope,s=e.context.material;return t===MaterialNode.COLOR?null!==s.map?"vec4":"vec3":t===MaterialNode.OPACITY||t===MaterialNode.ROTATION?"float":t===MaterialNode.EMISSIVE||t===MaterialNode.SHEEN?"vec3":t===MaterialNode.ROUGHNESS||t===MaterialNode.METALNESS||t===MaterialNode.SPECULAR||t===MaterialNode.SHININESS||t===MaterialNode.CLEARCOAT_ROUGHNESS||t===MaterialNode.SHEEN_ROUGHNESS?"float":void 0}getFloat(e){return lo(e,"float")}getColor(e){return lo(e,"color")}getTexture(e){return lo(e,"texture")}construct(e){const t=e.context.material,s=this.scope;let r=null;if(s===MaterialNode.ALPHA_TEST)r=this.getFloat("alphaTest");else if(s===MaterialNode.COLOR){const e=this.getColor("color");r=t.map&&!0===t.map.isTexture?e.mul(this.getTexture("map")):e}else if(s===MaterialNode.OPACITY){const e=this.getFloat("opacity");r=t.alphaMap&&!0===t.alphaMap.isTexture?e.mul(this.getTexture("alphaMap")):e}else if(s===MaterialNode.SHININESS)r=this.getFloat("shininess");else if(s===MaterialNode.SPECULAR_COLOR)r=this.getColor("specular");else if(s===MaterialNode.REFLECTIVITY){const e=this.getFloat("reflectivity");r=t.specularMap&&!0===t.specularMap.isTexture?e.mul(this.getTexture("specularMap").r):e}else if(s===MaterialNode.ROUGHNESS){const e=this.getFloat("roughness");r=t.roughnessMap&&!0===t.roughnessMap.isTexture?e.mul(this.getTexture("roughnessMap").g):e}else if(s===MaterialNode.METALNESS){const e=this.getFloat("metalness");r=t.metalnessMap&&!0===t.metalnessMap.isTexture?e.mul(this.getTexture("metalnessMap").b):e}else if(s===MaterialNode.EMISSIVE){const e=this.getColor("emissive");r=t.emissiveMap&&!0===t.emissiveMap.isTexture?e.mul(this.getTexture("emissiveMap")):e}else if(s===MaterialNode.CLEARCOAT){const e=this.getFloat("clearcoat");r=t.clearcoatMap&&!0===t.clearcoatMap.isTexture?e.mul(this.getTexture("clearcoatMap").r):e}else if(s===MaterialNode.CLEARCOAT_ROUGHNESS){const e=this.getFloat("clearcoatRoughness");r=t.clearcoatRoughnessMap&&!0===t.clearcoatRoughnessMap.isTexture?e.mul(this.getTexture("clearcoatRoughnessMap").r):e}else if(s===MaterialNode.SHEEN){const e=this.getColor("sheenColor").mul(this.getFloat("sheen"));r=t.sheenColorMap&&!0===t.sheenColorMap.isTexture?e.mul(this.getTexture("sheenColorMap").rgb):e}else if(s===MaterialNode.SHEEN_ROUGHNESS){const e=this.getFloat("sheenRoughness");r=t.sheenRoughnessMap&&!0===t.sheenRoughnessMap.isTexture?e.mul(this.getTexture("sheenRoughnessMap").a):e,r=r.clamp(.07,1)}else if(s===MaterialNode.ROTATION)r=this.getFloat("rotation");else{const t=this.getNodeType(e);r=lo(s,t)}return r}}MaterialNode.ALPHA_TEST="alphaTest",MaterialNode.COLOR="color",MaterialNode.OPACITY="opacity",MaterialNode.SHININESS="shininess",MaterialNode.SPECULAR_COLOR="specularColor",MaterialNode.REFLECTIVITY="reflectivity",MaterialNode.ROUGHNESS="roughness",MaterialNode.METALNESS="metalness",MaterialNode.CLEARCOAT="clearcoat",MaterialNode.CLEARCOAT_ROUGHNESS="clearcoatRoughness",MaterialNode.EMISSIVE="emissive",MaterialNode.ROTATION="rotation",MaterialNode.SHEEN="sheen",MaterialNode.SHEEN_ROUGHNESS="sheenRoughness";const uo=gr(MaterialNode,MaterialNode.ALPHA_TEST),co=gr(MaterialNode,MaterialNode.COLOR),ho=gr(MaterialNode,MaterialNode.SHININESS),po=gr(MaterialNode,MaterialNode.EMISSIVE),mo=gr(MaterialNode,MaterialNode.OPACITY),go=gr(MaterialNode,MaterialNode.SPECULAR_COLOR),fo=gr(MaterialNode,MaterialNode.REFLECTIVITY),xo=gr(MaterialNode,MaterialNode.ROUGHNESS),bo=gr(MaterialNode,MaterialNode.METALNESS),No=gr(MaterialNode,MaterialNode.CLEARCOAT),yo=gr(MaterialNode,MaterialNode.CLEARCOAT_ROUGHNESS),vo=gr(MaterialNode,MaterialNode.ROTATION),To=gr(MaterialNode,MaterialNode.SHEEN),_o=gr(MaterialNode,MaterialNode.SHEEN_ROUGHNESS);Is(MaterialNode);class So extends Os{constructor(e=So.VIEW_MATRIX,t=null){super(),this.scope=e,this.object3d=t,this.updateType=vs,this._uniformNode=qr(null)}getNodeType(){const e=this.scope;return e===So.WORLD_MATRIX||e===So.VIEW_MATRIX?"mat4":e===So.NORMAL_MATRIX?"mat3":e===So.POSITION||e===So.VIEW_POSITION||e===So.DIRECTION||e===So.SCALE?"vec3":void 0}update(e){const t=this.object3d,s=this._uniformNode,r=this.scope;if(r===So.VIEW_MATRIX)s.value=t.modelViewMatrix;else if(r===So.NORMAL_MATRIX)s.value=t.normalMatrix;else if(r===So.WORLD_MATRIX)s.value=t.matrixWorld;else if(r===So.POSITION)s.value=s.value||new i,s.value.setFromMatrixPosition(t.matrixWorld);else if(r===So.SCALE)s.value=s.value||new i,s.value.setFromMatrixScale(t.matrixWorld);else if(r===So.DIRECTION)s.value=s.value||new i,t.getWorldDirection(s.value);else if(r===So.VIEW_POSITION){const r=e.camera;s.value=s.value||new i,s.value.setFromMatrixPosition(t.matrixWorld),s.value.applyMatrix4(r.matrixWorldInverse)}}generate(e){const t=this.scope;return t===So.WORLD_MATRIX||t===So.VIEW_MATRIX?this._uniformNode.nodeType="mat4":t===So.NORMAL_MATRIX?this._uniformNode.nodeType="mat3":t!==So.POSITION&&t!==So.VIEW_POSITION&&t!==So.DIRECTION&&t!==So.SCALE||(this._uniformNode.nodeType="vec3"),this._uniformNode.build(e)}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}So.VIEW_MATRIX="viewMatrix",So.NORMAL_MATRIX="normalMatrix",So.WORLD_MATRIX="worldMatrix",So.POSITION="position",So.SCALE="scale",So.VIEW_POSITION="viewPosition",So.DIRECTION="direction",mr(So,So.DIRECTION),mr(So,So.VIEW_MATRIX),mr(So,So.NORMAL_MATRIX),mr(So,So.WORLD_MATRIX);const wo=mr(So,So.POSITION);mr(So,So.SCALE);const Co=mr(So,So.VIEW_POSITION);Is(So);class Ao extends So{constructor(e=Ao.POSITION){super(e)}getNodeType(e){const t=this.scope;return t===Ao.PROJECTION_MATRIX?"mat4":t===Ao.NEAR||t===Ao.FAR?"float":super.getNodeType(e)}update(e){const t=e.camera,s=this._uniformNode,r=this.scope;r===Ao.VIEW_MATRIX?s.value=t.matrixWorldInverse:r===Ao.PROJECTION_MATRIX?s.value=t.projectionMatrix:r===Ao.NEAR?s.value=t.near:r===Ao.FAR?s.value=t.far:(this.object3d=t,super.update(e))}generate(e){const t=this.scope;return t===Ao.PROJECTION_MATRIX?this._uniformNode.nodeType="mat4":t!==Ao.NEAR&&t!==Ao.FAR||(this._uniformNode.nodeType="float"),super.generate(e)}}Ao.PROJECTION_MATRIX="projectionMatrix",Ao.NEAR="near",Ao.FAR="far";const Ro=rn(gr(Ao,Ao.PROJECTION_MATRIX),"projectionMatrix"),Mo=gr(Ao,Ao.NEAR),Eo=gr(Ao,Ao.FAR),Bo=gr(Ao,Ao.VIEW_MATRIX);gr(Ao,Ao.NORMAL_MATRIX),gr(Ao,Ao.WORLD_MATRIX),gr(Ao,Ao.POSITION),Is(Ao);class Uo extends So{constructor(e=Uo.VIEW_MATRIX){super(e)}update(e){this.object3d=e.object,super.update(e)}}gr(Uo,Uo.DIRECTION);const Oo=rn(gr(Uo,Uo.VIEW_MATRIX),"modelViewMatrix"),Io=gr(Uo,Uo.NORMAL_MATRIX),Fo=gr(Uo,Uo.WORLD_MATRIX);gr(Uo,Uo.POSITION),gr(Uo,Uo.SCALE),gr(Uo,Uo.VIEW_POSITION),Is(Uo);class Lo extends Os{constructor(e=Lo.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`normal-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===Lo.GEOMETRY)s=Xr("normal","vec3");else if(t===Lo.LOCAL)s=Wr(Do);else if(t===Lo.VIEW){const e=Io.mul(Go);s=li(Wr(e))}else if(t===Lo.WORLD){const e=ko.transformDirection(Bo);s=li(Wr(e))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}Lo.GEOMETRY="geometry",Lo.LOCAL="local",Lo.VIEW="view",Lo.WORLD="world";const Do=gr(Lo,Lo.GEOMETRY),Go=gr(Lo,Lo.LOCAL),ko=gr(Lo,Lo.VIEW),zo=gr(Lo,Lo.WORLD),Po=fn("vec3","TransformedNormalView"),Vo=Po.transformDirection(Bo).normalize(),$o=fn("vec3","TransformedClearcoatNormalView");Is(Lo);class qo extends Os{constructor(e,t=null){super(),this.node=e,this.name=t}assign(e){return e.traverse(((e,t)=>{t&&e.uuid===this.uuid&&t(this.node)})),this.node=e,this}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const t=this.node,s=this.name;if(null===s&&!0===t.isTempNode)return t.build(e);const r=e.getVectorType(this.getNodeType(e)),n=t.build(e,r),i=e.getVarFromNode(this,r);null!==s&&(i.name=s);const o=e.getPropertyName(i);return e.addLineFlowCode(`${o} = ${n}`),o}}const jo=mr(qo);qs("temp",jo),Is(qo);class Wo extends Os{constructor(e=Wo.LOCAL){super(),this.scope=e}getHash(){return`tangent-${this.scope}`}getNodeType(){return this.scope===Wo.GEOMETRY?"vec4":"vec3"}generate(e){const t=this.scope;let s=null;if(t===Wo.GEOMETRY)s=Xr("tangent","vec4");else if(t===Wo.LOCAL)s=Wr(Ho.xyz);else if(t===Wo.VIEW){const e=Oo.mul(Xo).xyz;s=li(Wr(e))}else if(t===Wo.WORLD){const e=Yo.transformDirection(Bo);s=li(Wr(e))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}Wo.GEOMETRY="geometry",Wo.LOCAL="local",Wo.VIEW="view",Wo.WORLD="world";const Ho=gr(Wo,Wo.GEOMETRY),Xo=gr(Wo,Wo.LOCAL),Yo=gr(Wo,Wo.VIEW),Zo=gr(Wo,Wo.WORLD),Ko=jo(Yo,"TransformedTangentView");li(Ko.transformDirection(Bo)),Is(Wo);class Jo extends Os{constructor(e=Jo.LOCAL){super("vec3"),this.scope=e}getHash(){return`bitangent-${this.scope}`}generate(e){const t=this.scope;let s;t===Jo.GEOMETRY?s=Do.cross(Ho):t===Jo.LOCAL?s=Go.cross(Xo):t===Jo.VIEW?s=ko.cross(Yo):t===Jo.WORLD&&(s=zo.cross(Zo));const r=s.mul(Ho.w).xyz;return li(Wr(r)).build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}Jo.GEOMETRY="geometry",Jo.LOCAL="local",Jo.VIEW="view",Jo.WORLD="world",gr(Jo,Jo.GEOMETRY),gr(Jo,Jo.LOCAL);const Qo=gr(Jo,Jo.VIEW);gr(Jo,Jo.WORLD);const ea=li(Po.cross(Ko).mul(Ho.w));li(ea.transformDirection(Bo)),Is(Jo);class ta extends Os{constructor(e=ta.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`position-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===ta.GEOMETRY)s=Xr("position","vec3");else if(t===ta.LOCAL)s=Wr(sa);else if(t===ta.WORLD){const e=Fo.mul(ra);s=Wr(e)}else if(t===ta.VIEW){const e=Oo.mul(ra);s=Wr(e)}else if(t===ta.VIEW_DIRECTION){const e=oa.negate();s=li(Wr(e))}else if(t===ta.WORLD_DIRECTION){const e=ra.transformDirection(Fo);s=li(Wr(e))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}ta.GEOMETRY="geometry",ta.LOCAL="local",ta.WORLD="world",ta.WORLD_DIRECTION="worldDirection",ta.VIEW="view",ta.VIEW_DIRECTION="viewDirection";const sa=gr(ta,ta.GEOMETRY),ra=gr(ta,ta.LOCAL),na=gr(ta,ta.WORLD),ia=gr(ta,ta.WORLD_DIRECTION),oa=gr(ta,ta.VIEW),aa=gr(ta,ta.VIEW_DIRECTION);Is(ta);class la extends Os{constructor(){super("bool"),this.isFrontFacingNode=!0}generate(e){return e.getFrontFacing()}}const ua=gr(la),ca=Nr(ua).mul(2).sub(1);Is(la);const da=xr((e=>{const{eye_pos:t,surf_norm:s,mapN:r,uv:n}=e,i=t.dFdx(),o=t.dFdy(),a=n.dFdx(),l=n.dFdy(),u=s,c=o.cross(u),d=u.cross(i),h=c.mul(a.x).add(d.mul(l.x)),p=c.mul(a.y).add(d.mul(l.y)),m=h.dot(h).max(p.dot(p)),g=ca.mul(m.inverseSqrt());return Bn(h.mul(r.x,g),p.mul(r.y,g),u.mul(r.z)).normalize()}));class ha extends Gs{constructor(e,t=null){super("vec3"),this.node=e,this.scaleNode=t,this.normalMapType=h}construct(e){const{normalMapType:t,scaleNode:s}=this;let r=this.node.mul(2).sub(1);null!==s&&(r=Ar(r.xy.mul(s),r.z));let n=null;if(t===p)n=Io.mul(r).normalize();else if(t===h){n=!0===e.hasGeometryAttribute("tangent")?ma.mul(r).normalize():da({eye_pos:oa,surf_norm:ko,mapN:r,uv:An()})}return n}}const pa=mr(ha),ma=Fr(Yo,Qo,ko);Is(ha);class ExtendedMaterialNode extends MaterialNode{constructor(e){super(e)}getNodeType(e){const t=this.scope;let s=null;return t!==ExtendedMaterialNode.NORMAL&&t!==ExtendedMaterialNode.CLEARCOAT_NORMAL||(s="vec3"),s||super.getNodeType(e)}construct(e){const t=e.material,s=this.scope;let r=null;return s===ExtendedMaterialNode.NORMAL?r=t.normalMap?pa(this.getTexture("normalMap"),lo("normalScale","vec2")):ko:s===ExtendedMaterialNode.CLEARCOAT_NORMAL&&(r=t.clearcoatNormalMap?pa(this.getTexture("clearcoatNormalMap"),lo("clearcoatNormalScale","vec2")):ko),r||super.construct(e)}}ExtendedMaterialNode.NORMAL="normal",ExtendedMaterialNode.CLEARCOAT_NORMAL="clearcoatNormal";const ga=gr(ExtendedMaterialNode,ExtendedMaterialNode.NORMAL),fa=gr(ExtendedMaterialNode,ExtendedMaterialNode.CLEARCOAT_NORMAL);Is(ExtendedMaterialNode);class xa extends Os{constructor(e=ra){super("vec4"),this.positionNode=e}construct(){return Ro.mul(Oo).mul(this.positionNode)}}const ba=mr(xa);Is(xa);class Na extends Fs{constructor(e,t,s=0,r=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferStride=s,this.bufferOffset=r,this.usage=m,this.instanced=!1}construct(e){const t=this.getNodeType(e),s=this.value,r=e.getTypeLength(t),n=this.bufferStride||r,i=this.bufferOffset,o=!0===s.isInterleavedBuffer?s:new g(s,n),a=new f(o,r,i);o.setUsage(this.usage),this.attribute=a,this.attribute.isInstancedBufferAttribute=this.instanced}generate(e){const t=this.getNodeType(e),s=e.getBufferAttributeFromNode(this,t),r=e.getPropertyName(s);let n=null;if("vertex"===e.shaderStage)n=r;else{n=Wr(this).build(e,t)}return n}getInputType(){return"bufferAttribute"}setUsage(e){return this.usage=e,this}setInstanced(e){return this.instanced=e,this}}const ya=(e,t,s,r)=>dr(new Na(e,t,s,r)),va=(e,t,s,r)=>ya(e,t,s,r).setInstanced(!0),Ta=(t,s,r,n)=>((t,s,r,n)=>ya(t,s,r,n).setUsage(e))(t,s,r,n).setInstanced(!0);Is(Na);class _a extends Os{constructor(e){super("void"),this.instanceMesh=e,this.instanceMatrixNode=null}construct(t){let s=this.instanceMatrixNode;if(null===s){const t=this.instanceMesh.instanceMatrix,r=new x(t.array,16,1),n=t.usage===e?Ta:va,i=[n(r,"vec4",16,0),n(r,"vec4",16,4),n(r,"vec4",16,8),n(r,"vec4",16,12)];s=kr(...i),this.instanceMatrixNode=s}const r=s.mul(ra).xyz,n=Fr(s[0].xyz,s[1].xyz,s[2].xyz),i=Go.div(Ar(n[0].dot(n[0]),n[1].dot(n[1]),n[2].dot(n[2]))),o=n.mul(i).xyz;t.stack.assign(ra,r),t.stack.assign(Go,o)}}const Sa=mr(_a);Is(_a);class wa extends $r{constructor(e,t,s=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferCount=s}getInputType(){return"buffer"}}const Ca=(e,t,s)=>dr(new wa(e,t,s));Is(wa);class Aa extends Os{constructor(e){super("void"),this.skinnedMesh=e,this.updateType=vs,this.skinIndexNode=Xr("skinIndex","uvec4"),this.skinWeightNode=Xr("skinWeight","vec4"),this.bindMatrixNode=qr(e.bindMatrix,"mat4"),this.bindMatrixInverseNode=qr(e.bindMatrixInverse,"mat4"),this.boneMatricesNode=Ca(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length)}construct(e){const{skinIndexNode:t,skinWeightNode:s,bindMatrixNode:r,bindMatrixInverseNode:n,boneMatricesNode:i}=this,o=i.element(t.x),a=i.element(t.y),l=i.element(t.z),u=i.element(t.w),c=r.mul(ra),d=Bn(o.mul(s.x).mul(c),a.mul(s.y).mul(c),l.mul(s.z).mul(c),u.mul(s.w).mul(c)),h=n.mul(d).xyz;let p=Bn(s.x.mul(o),s.y.mul(a),s.z.mul(l),s.w.mul(u));p=n.mul(p).mul(r);const m=p.transformDirection(Go).xyz;e.stack.assign(ra,h),e.stack.assign(Go,m),e.hasGeometryAttribute("tangent")&&e.stack.assign(Xo,m)}update(){this.skinnedMesh.skeleton.update()}}const Ra=mr(Aa);Is(Aa);class Ma extends Os{constructor(e){super("void"),this.mesh=e,this.morphBaseInfluence=qr(1),this.updateType=vs}constructAttribute(e,t,s=ra){const r=this.mesh,n=r.geometry.morphAttributes[t];e.stack.assign(s,s.mul(this.morphBaseInfluence));for(let t=0;t<n.length;t++){const i=n[t],o=ya(i.array,"vec3"),a=ao(t,"float",r.morphTargetInfluences);e.stack.assign(s,s.add(o.mul(a)))}}construct(e){this.constructAttribute(e,"position")}update(){const e=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?e.value=1:e.value=1-this.mesh.morphTargetInfluences.reduce(((e,t)=>e+t),0)}}const Ea=mr(Ma);Is(Ma);class Ba extends Os{constructor(){super("vec3")}getHash(){return"reflectVector"}construct(){return aa.negate().reflect(Po).transformDirection(Bo)}}const Ua=gr(Ba);Is(Ba);class Oa extends no{constructor(e,t=null,s=null){super(e,t,s),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){return Ua}generate(e,t){const{uvNode:s,levelNode:r}=e.getNodeProperties(this),n=this.value;if(!n||!0!==n.isCubeTexture)throw new Error("CubeTextureNode: Need a three.js cube texture.");const i=$r.prototype.generate.call(this,e,"cubeTexture");if("sampler"===t)return i+"_sampler";if(e.isReference(t))return i;{const n=e.getDataFromNode(this);let o=n.propertyName;if(void 0===o){const t=Ar(s.x.negate(),s.yz).build(e,"vec3"),a=e.getVarFromNode(this,"vec4");o=e.getPropertyName(a);let l=null;if(r&&!0===r.isNode){const s=r.build(e,"float");l=e.getTextureLevel(this,i,t,s)}else l=e.getTexture(this,i,t);e.addLineFlowCode(`${o} = ${l}`),n.snippet=l,n.propertyName=o}return e.format(o,"vec4",t)}}}const Ia=mr(Oa);qs("cubeTexture",Ia),Is(Oa);class Fa extends Os{constructor(){super("vec3")}generate(){}}Is(Fa);class La extends Os{constructor(e,t,s=null){super(),this.condNode=e,this.ifNode=t,this.elseNode=s}getNodeType(e){const t=this.ifNode.getNodeType(e);if(null!==this.elseNode){const s=this.elseNode.getNodeType(e);if(e.getTypeLength(s)>e.getTypeLength(t))return s}return t}generate(e){const t=this.getNodeType(e),s={tempWrite:!1},{ifNode:r,elseNode:n}=this,i="void"!==r.getNodeType(e)||n&&"void"!==n.getNodeType(e),o=i?fn(t).build(e):"",a=sn(this.condNode).build(e,"bool");e.addFlowCode(`\n${e.tab}if ( ${a} ) {\n\n`).addFlowTab();let l=sn(this.ifNode,s).build(e,t);if(l=i?o+" = "+l+";":l,e.removeFlowTab().addFlowCode(e.tab+"\t"+l+"\n\n"+e.tab+"}"),null!==n){e.addFlowCode(" else {\n\n").addFlowTab();let r=sn(n,s).build(e,t);r=o?o+" = "+r+";":r,e.removeFlowTab().addFlowCode(e.tab+"\t"+r+"\n\n"+e.tab+"}\n\n")}else e.addFlowCode("\n\n");return o}}const Da=mr(La);qs("cond",Da),Is(La);let Ga=null;class ka extends Fa{constructor(e=null){super(),this.updateType=Ns,this.light=e,this.rtt=null,this.shadowNode=null,this.color=new r,this.colorNode=qr(this.color)}getHash(){return this.light.uuid}constructShadow(e){let t=this.shadowNode;if(null===t){null===Ga&&(Ga=e.createNodeMaterial("MeshBasicNodeMaterial"));const s=this.light.shadow,r=e.getRenderTarget(s.mapSize.width,s.mapSize.height),n=new b;n.minFilter=N,n.magFilter=N,n.image.width=s.mapSize.width,n.image.height=s.mapSize.height,r.depthTexture=n,s.camera.updateProjectionMatrix();const i=ao("bias","float",s);let o=qr(s.matrix).mul(na);o=o.xyz.div(o.w),o=Ar(o.x,o.y.oneMinus(),o.z);let a=io(n,o.xy);a=a.mul(.5).add(.5).add(i),t=Da(o.z.lessThan(a).or(o.y.lessThan(1e-6)),1,0),this.rtt=r,this.colorNode=this.colorNode.mul(t),this.shadowNode=t,this.updateBeforeType=ys}}construct(e){this.light.castShadow&&this.constructShadow(e)}updateShadow(e){const{rtt:t,light:s}=this,{renderer:r,scene:n}=e;n.overrideMaterial=Ga,t.setSize(s.shadow.mapSize.width,s.shadow.mapSize.height),s.shadow.updateMatrices(s),r.setRenderTarget(t),r.render(n,s.shadow.camera),r.setRenderTarget(null),n.overrideMaterial=null}updateBefore(e){const{light:t}=this;t.castShadow&&this.updateShadow(e)}update(){const{light:e}=this;this.color.copy(e.color).multiplyScalar(e.intensity)}}Is(ka);const za=new WeakMap;class LightsNode extends Os{constructor(e=[]){super("vec3"),this.lightNodes=e,this._hash=null}get hasLight(){return this.lightNodes.length>0}construct(e){const t=this.lightNodes;for(const s of t)s.build(e)}getHash(e){if(null===this._hash){let t="";const s=this.lightNodes;for(const r of s)t+=r.getHash(e)+" ";this._hash=t}return this._hash}getLightNodeByHash(e){const t=this.lightNodes;for(const s of t)if(s.light.uuid===e)return s;return null}fromLights(e=[]){const t=[];e=(e=>e.sort(((e,t)=>e.id-t.id)))(e);for(const s of e){let e=this.getLightNodeByHash(s.uuid);if(null===e){const t=s.constructor,r=za.has(t)?za.get(t):ka;e=dr(new r(s))}t.push(e)}return this.lightNodes=t,this._hash=null,this}}const Pa=mr(LightsNode);function Va(e,t){if(za.has(e))throw new Error(`Redefinition of light node ${t.name}`);if("function"!=typeof e||!e.name)throw new Error(`Light ${e.name} is not a class`);if("function"!=typeof t||!t.name)throw new Error(`Light node ${t.name} is not a class`);za.set(e,t)}class $a extends Fa{constructor(e=null){super(),this.aoNode=e}construct(e){const t=this.aoNode.sub(1).mul(1).add(1);e.context.ambientOcclusion.mulAssign(t)}}Is($a);class qa extends Gs{constructor(e=ia){super("vec2"),this.dirNode=e}construct(){const e=this.dirNode,t=e.z.atan2(e.x).mul(1/(2*Math.PI)).add(.5),s=e.y.negate().clamp(-1,1).asin().mul(1/Math.PI).add(.5);return _r(t,s)}}const ja=mr(qa);Is(qa);class Wa extends $r{constructor(e){super(0),this.textureNode=e,this.updateType=Ns}get texture(){return this.textureNode.value}update(){const e=this.texture,t=e.images,s=t&&t.length>0?t[0]&&t[0].image||t[0]:e.image;if(s&&void 0!==s.width){const{width:e,height:t}=s;this.value=Math.log2(Math.max(e,t))}}}const Ha=mr(Wa);Is(Wa);class Xa extends Os{constructor(e,t=null){super("float"),this.textureNode=e,this.roughnessNode=t}construct(){const{textureNode:e,roughnessNode:t}=this,s=Ha(e),r=t.mul(t).mul(Math.PI).div(t.add(1));return s.add(r.log2()).clamp(0,s)}}const Ya=mr(Xa);Is(Xa);class Za extends Fa{constructor(e=null){super(),this.envNode=e}construct(e){let t=this.envNode;const s=e.getNodeProperties(this);if(t.isTextureNode&&!0!==t.value.isCubeTexture){const s=t.value,r=e.renderer,n=e.getCubeRenderTarget(512).fromEquirectangularTexture(r,s);t=Ia(n.texture)}const r=ao("envMapIntensity","float",e.material),n=sn(t,Ka(bn,Po)).mul(r),i=sn(t,Ja(Vo)).mul(Math.PI).mul(r),o=en(n);e.context.radiance.addAssign(o),e.context.iblIrradiance.addAssign(i);let a=null;if(e.context.clearcoatRadiance){const s=sn(t,Ka(vn,$o)).mul(r);a=en(s),e.context.clearcoatRadiance.addAssign(a)}s.radiance=o,s.clearcoatRadiance=a,s.irradiance=i}}const Ka=(e,t)=>{let s=null,r=null;return{getUVNode:n=>{let i=null;return null===s&&(s=aa.negate().reflect(t),s=e.mul(e).mix(s,t).normalize(),s=s.transformDirection(Bo)),n.isCubeTextureNode?i=s:n.isTextureNode&&(null===r&&(r=ja(s)),i=r),i},getSamplerLevelNode:()=>e,getMIPLevelAlgorithmNode:(e,t)=>Ya(e,t)}},Ja=e=>{let t=null;return{getUVNode:s=>{let r=null;return s.isCubeTextureNode?r=e:s.isTextureNode&&(null===t&&(t=ja(e),t=_r(t.x,t.y.oneMinus())),r=t),r},getSamplerLevelNode:()=>Nr(1),getMIPLevelAlgorithmNode:(e,t)=>Ya(e,t)}};Is(Za);const Qa=new Map;class NodeMaterial extends y{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.name,this.forceSinglePass=!1,this.lights=!0,this.normals=!0,this.lightsNode=null,this.envNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.outputNode=null}customProgramCacheKey(){return this.type+ws(this)}build(e){this.construct(e)}construct(e){if(e.addStack(),e.stack.outputNode=this.constructPosition(e),e.addFlow("vertex",e.removeStack()),e.addStack(),!1===this.isUnlit){!0===this.normals&&this.constructNormal(e),this.constructDiffuseColor(e),this.constructVariants(e);const t=this.constructLighting(e);e.stack.outputNode=this.constructOutput(e,Br(t,xn.a))}else e.stack.outputNode=this.constructOutput(e,this.outputNode||Br(0,0,0,1));e.addFlow("fragment",e.removeStack())}constructPosition(e){const t=e.object,s=t.geometry;return e.addStack(),(s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color)&&e.stack.add(Ea(t)),!0===t.isSkinnedMesh&&e.stack.add(Ra(t)),t.instanceMatrix&&!0===t.instanceMatrix.isInstancedBufferAttribute&&!0===e.isAvailable("instance")&&e.stack.add(Sa(t)),null!==this.positionNode&&e.stack.assign(ra,this.positionNode),e.context.vertex=e.removeStack(),ba()}constructDiffuseColor({stack:e,geometry:t}){let s=this.colorNode?Br(this.colorNode):co;!0===this.vertexColors&&t.hasAttribute("color")&&(s=Br(s.xyz.mul(Xr("color")),s.a)),e.assign(xn,s);const r=this.opacityNode?Nr(this.opacityNode):mo;if(e.assign(xn.a,xn.a.mul(r)),null!==this.alphaTestNode||this.alphaTest>0){const t=null!==this.alphaTestNode?Nr(this.alphaTestNode):uo;e.add(xn.a.lessThanEqual(t).discard())}}constructVariants(){}constructNormal({stack:e}){if(!0===this.flatShading){const t=vi(oa),s=Ti(oa.negate()),r=t.cross(s).normalize();e.assign(Po,r)}else{const t=this.normalNode?Ar(this.normalNode):ga;e.assign(Po,t)}}getEnvNode(e){let t=null;return this.envNode?t=this.envNode:this.envMap?t=this.envMap.isCubeTexture?Ia(this.envMap):io(this.envMap):e.environmentNode&&(t=e.environmentNode),t}constructLights(e){const t=this.getEnvNode(e),s=[];t&&s.push(new Za(t)),e.material.aoMap&&s.push(new $a(io(e.material.aoMap)));let r=this.lightsNode||e.lightsNode;return s.length>0&&(r=Pa([...r.lightNodes,...s])),r}constructLightingModel(){}constructLighting(e){const{material:t}=e,{backdropNode:s,backdropAlphaNode:r,emissiveNode:n}=this,i=!0===this.lights||null!==this.lightsNode?this.constructLights(e):null;let o=xn.rgb;if(i&&!1!==i.hasLight){const t=this.constructLightingModel(e);o=i.lightingContext(t,s,r)}else null!==s&&(o=Ar(null!==r?Vi(o,s,r):s));return(n&&!0===n.isNode||t.emissive&&!0===t.emissive.isColor)&&(o=o.add(n?Ar(n):po)),o}constructOutput(e,t){const s=e.renderer,r=e.toneMappingNode;r&&(t=Br(r.context({color:t.rgb}),t.a));const n=s.getRenderTarget();let i;i=null!==n?n.texture.colorSpace:s.outputColorSpace,i!==v&&(t=t.linearToColorSpace(i));const o=e.fogNode;return o&&(t=Br(o.mixAssign(t.rgb),t.a)),t}setDefaultValues(e){for(const t in e){const s=e[t];void 0===this[t]&&(this[t]=s,s&&s.clone&&(this[t]=s.clone()))}Object.assign(this.defines,e.defines);const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const e in t)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,e)&&void 0!==t[e].get&&Object.defineProperty(this.constructor.prototype,e,t[e])}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{},nodes:{}});const s=T.prototype.toJSON.call(this,e),r=Cs(this);s.inputNodes={};for(const{property:t,childNode:n}of r)s.inputNodes[t]=n.toJSON(e).uuid;function n(e){const t=[];for(const s in e){const r=e[s];delete r.metadata,t.push(r)}return t}if(t){const t=n(e.textures),r=n(e.images),i=n(e.nodes);t.length>0&&(s.textures=t),r.length>0&&(s.images=r),i.length>0&&(s.nodes=i)}return s}get isUnlit(){return this.constructor===NodeMaterial.prototype.constructor}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.positionNode=e.positionNode,this.outputNode=e.outputNode,super.copy(e)}static fromMaterial(e){if(!0===e.isNodeMaterial)return e;const t=tl(e.type.replace("Material","NodeMaterial"));if(void 0===t)throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);for(const s in e)t[s]=e[s];return t}}function el(e){if("function"!=typeof e||!e.name)throw new Error(`Node material ${e.name} is not a class`);if(Qa.has(e.name))throw new Error(`Redefinition of node material ${e.name}`);Qa.set(e.name,e)}function tl(e){const t=Qa.get(e);if(void 0!==t)return new t}el(NodeMaterial);class sl extends Os{constructor(e=[]){super(),this.params=e}getVarName(e){return String.fromCharCode("i".charCodeAt()+e)}getProperties(e){const t=e.getNodeProperties(this);if(void 0!==t.stackNode)return t;const s={};for(let e=0,t=this.params.length-1;e<t;e++){const t=this.getVarName(e);s[t]=ro(t,"int")}return t.returnsNode=this.params[this.params.length-1](s,e.addStack(),e),t.stackNode=e.removeStack(),t}getNodeType(e){const{returnsNode:t}=this.getProperties(e);return t?t.getNodeType(e):"void"}construct(e){this.getProperties(e)}generate(e){const t=this.getProperties(e),s=this.params,r=t.stackNode,n=t.returnsNode?t.returnsNode.build(e):"";for(let t=0,r=s.length-1;t<r;t++){const r=s[t],n=this.getVarName(t);let i=null,o=null,a=null;r.isNode?(i="0",o=r.generate(e,"int"),a="forward"):(i=r.start,o=r.end,a=r.direction,"number"==typeof i?i=i.toString():i&&i.isNode&&(i=i.generate(e,"int")),"number"==typeof o?o=o.toString():o&&o.isNode&&(o=o.generate(e,"int")),void 0!==i&&void 0===o?(i+=" - 1",o="0",a="backwards"):void 0!==o&&void 0===i&&(i="0",a="forward"),void 0===a&&(a=Number(i)>Number(o)?"backwards":"forward"));const l={start:i,end:o,direction:a},u=l.start,c=l.end;let d="",h="",p="";d+=e.getVar("int",n)+" = "+u,"backwards"===l.direction?(h+=n+" >= "+c,p+=n+" --"):(h+=n+" < "+c,p+=n+" ++");const m=`for ( ${d}; ${h}; ${p} )`;e.addFlowCode((0===t?"\n":"")+e.tab+m+" {\n\n").addFlowTab()}const i=sn(r,{tempWrite:!1}).build(e,"void");e.removeFlowTab().addFlowCode("\n"+e.tab+i);for(let t=0,s=this.params.length-1;t<s;t++)e.addFlowCode((0===t?"":e.tab)+"}\n\n").removeFlowTab();return e.addFlowTab(),n}}const rl=(...e)=>dr(new sl(pr(e,"int")));qs("loop",((e,...t)=>Zr(e,rl(...t)))),Is(sl);class nl extends Os{constructor(e=null){super(),this.nodes=[],this.outputNode=null,this.parent=e,this._currentCond=null,this.isStackNode=!0}getNodeType(e){return this.outputNode?this.outputNode.getNodeType(e):"void"}add(e){return this.nodes.push(Zr(ro(),e)),this}if(e,t){const s=fr(t);return this._currentCond=Da(e,s),this.add(this._currentCond)}elseif(e,t){const s=fr(t),r=Da(e,s);return this._currentCond.elseNode=r,this._currentCond=r,this}else(e){return this._currentCond.elseNode=fr(e),this}assign(e,t){return this.add(Dn(e,t))}loop(...e){return this.add(rl(...e))}build(e,...t){for(const t of this.nodes)t.build(e,"void");return this.outputNode?this.outputNode.build(e,...t):super.build(e,...t)}}const il=mr(nl);Is(nl);const ol=new Map([[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),al=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),ll=new Set([Int32Array,Uint32Array,Float32Array]),ul=e=>(e=Number(e))+(e%1?"":".0");class cl{constructor(e,t,s,r=null){this.object=e,this.material=e&&e.material||null,this.geometry=e&&e.geometry||null,this.renderer=t,this.parser=s,this.scene=r,this.nodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.hashNodes={},this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.toneMappingNode=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:[]},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.codes={vertex:[],fragment:[],compute:[]},this.bindings={vertex:[],fragment:[],compute:[]},this.bindingsOffset={vertex:0,fragment:0,compute:0},this.bindingsArray=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.vars={vertex:[],fragment:[],compute:[]},this.flow={code:""},this.chaining=[],this.stack=il(),this.tab="\t",this.context={keywords:new mn,material:this.material,getMIPLevelAlgorithmNode:(e,t)=>t.mul(Ha(e))},this.cache=new Jr,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null}includes(e){return this.nodes.includes(e)}getBindings(){let e=this.bindingsArray;if(null===e){const t=this.bindings;this.bindingsArray=e=null!==this.material?[...t.vertex,...t.fragment]:t.compute}return e}setHashNode(e,t){this.hashNodes[t]=e}addNode(e){if(-1===this.nodes.indexOf(e)){const t=e.getUpdateType(),s=e.getUpdateBeforeType();t!==bs&&this.updateNodes.push(e),s!==bs&&this.updateBeforeNodes.push(e),this.nodes.push(e),this.setHashNode(e,e.getHash(this))}}get currentNode(){return this.chaining[this.chaining.length-1]}addChain(e){this.chaining.push(e)}removeChain(e){if(this.chaining.pop()!==e)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(e){return e}getNodeFromHash(e){return this.hashNodes[e]}addFlow(e,t){return this.flowNodes[e].push(t),t}setContext(e){this.context=e}getContext(){return this.context}setCache(e){this.cache=e}getCache(){return this.cache}isAvailable(){return!1}getVertexIndex(){}getInstanceIndex(){}getFrontFacing(){}getFragCoord(){}isFlipY(){return!1}getTexture(){}getTextureLevel(){}getConst(e,t=null){if(null===t&&("float"===e||"int"===e||"uint"===e?t=0:"bool"===e?t=!1:"color"===e?t=new r:"vec2"===e?t=new n:"vec3"===e?t=new i:"vec4"===e&&(t=new o)),"float"===e)return ul(t);if("int"===e)return`${Math.round(t)}`;if("uint"===e)return t>=0?`${Math.round(t)}u`:"0u";if("bool"===e)return t?"true":"false";if("color"===e)return`${this.getType("vec3")}( ${ul(t.r)}, ${ul(t.g)}, ${ul(t.b)} )`;const s=this.getTypeLength(e),a=this.getComponentType(e),l=e=>this.getConst(a,e);if(2===s)return`${this.getType(e)}( ${l(t.x)}, ${l(t.y)} )`;if(3===s)return`${this.getType(e)}( ${l(t.x)}, ${l(t.y)}, ${l(t.z)} )`;if(4===s)return`${this.getType(e)}( ${l(t.x)}, ${l(t.y)}, ${l(t.z)}, ${l(t.w)} )`;if(s>4&&t&&(t.isMatrix3||t.isMatrix4))return`${this.getType(e)}( ${t.elements.map(l).join(", ")} )`;if(s>4)return`${this.getType(e)}()`;throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`)}getType(e){return e}generateMethod(e){return e}hasGeometryAttribute(e){return this.geometry&&void 0!==this.geometry.getAttribute(e)}getAttribute(e,t){const s=this.attributes;for(const t of s)if(t.name===e)return t;const r=new un(e,t);return s.push(r),r}getPropertyName(e){return e.name}isVector(e){return/vec\d/.test(e)}isMatrix(e){return/mat\d/.test(e)}isReference(e){return"void"===e||"property"===e||"sampler"===e||"texture"===e||"cubeTexture"===e}needsColorSpaceToLinear(){return!1}getTextureEncodingFromMap(e){return this.getTextureColorSpaceFromMap(e)===d?_:S}getTextureColorSpaceFromMap(e){let t;return t=e&&e.isTexture?e.colorSpace:e&&e.isWebGLRenderTarget?e.texture.colorSpace:v,t}getComponentType(e){if("float"===(e=this.getVectorType(e))||"bool"===e||"int"===e||"uint"===e)return e;const t=/(b|i|u|)(vec|mat)([2-4])/.exec(e);return null===t?null:"b"===t[1]?"bool":"i"===t[1]?"int":"u"===t[1]?"uint":"float"}getVectorType(e){return"color"===e?"vec3":"texture"===e?"vec4":e}getTypeFromLength(e,t="float"){if(1===e)return t;const s=ol.get(e);return("float"===t?"":t[0])+s}getTypeFromArray(e){return al.get(e.constructor)}getTypeFromAttribute(e){let t=e;e.isInterleavedBufferAttribute&&(t=e.data);const s=t.array,r=ll.has(s.constructor)?e.itemSize:t.stride||e.itemSize,n=e.normalized;let i;return e instanceof w||!0===n||(i=this.getTypeFromArray(s)),this.getTypeFromLength(r,i)}getTypeLength(e){const t=this.getVectorType(e),s=/vec([2-4])/.exec(t);return null!==s?Number(s[1]):"float"===t||"bool"===t||"int"===t||"uint"===t?1:!0===/mat3/.test(e)?9:!0===/mat4/.test(e)?16:0}getVectorFromMatrix(e){return e.replace("mat","vec")}changeComponentType(e,t){return this.getTypeFromLength(this.getTypeLength(e),t)}getIntegerType(e){const t=this.getComponentType(e);return"int"===t||"uint"===t?e:this.changeComponentType(e,"int")}addStack(){return this.stack=il(this.stack),this.stack}removeStack(){const e=this.stack;return this.stack=e.parent,e}getDataFromNode(e,t=this.shaderStage){const s=e.isGlobal(this)?this.globalCache:this.cache;let r=s.getNodeData(e);return void 0===r&&(r={vertex:{},fragment:{},compute:{}},s.setNodeData(e,r)),null!==t?r[t]:r}getNodeProperties(e,t=this.shaderStage){const s=this.getDataFromNode(e,t);return s.properties||(s.properties={outputNode:null})}getBufferAttributeFromNode(e,t){const s=this.getDataFromNode(e);let r=s.bufferAttribute;if(void 0===r){const n=this.uniforms.index++;r=new un("nodeAttribute"+n,t,e),this.bufferAttributes.push(r),s.bufferAttribute=r}return r}getUniformFromNode(e,t,s=this.shaderStage,r=null){const n=this.getDataFromNode(e,s);let i=n.uniform;if(void 0===i){const o=this.uniforms.index++;i=new cn(r||"nodeUniform"+o,t,e),this.uniforms[s].push(i),n.uniform=i}return i}getVarFromNode(e,t,s=this.shaderStage){const r=this.getDataFromNode(e,s);let n=r.variable;if(void 0===n){const e=this.vars[s],i=e.length;n=new dn("nodeVar"+i,t),e.push(n),r.variable=n}return n}getVaryingFromNode(e,t){const s=this.getDataFromNode(e,null);let r=s.varying;if(void 0===r){const e=this.varyings,n=e.length;r=new hn("nodeVarying"+n,t),e.push(r),s.varying=r}return r}getCodeFromNode(e,t,s=this.shaderStage){const r=this.getDataFromNode(e);let n=r.code;if(void 0===n){const e=this.codes[s],i=e.length;n=new pn("nodeCode"+i,t),e.push(n),r.code=n}return n}addLineFlowCode(e){return""===e||(e=this.tab+e,/;\s*$/.test(e)||(e+=";\n"),this.flow.code+=e),this}addFlowCode(e){return this.flow.code+=e,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(e){return this.flowsData.get(e)}flowNode(e){const t=e.getNodeType(this),s=this.flowChildNode(e,t);return this.flowsData.set(e,s),s}flowChildNode(e,t=null){const s=this.flow,r={code:""};return this.flow=r,r.result=e.build(this,t),this.flow=s,r}flowNodeFromShaderStage(e,t,s=null,r=null){const n=this.shaderStage;this.setShaderStage(e);const i=this.flowChildNode(t,s);return null!==r&&(i.code+=`${this.tab+r} = ${i.result};\n`),this.flowCode[e]=this.flowCode[e]+i.code,this.setShaderStage(n),i}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){}getVaryings(){}getVar(e,t){return`${e} ${t}`}getVars(e){let t="";const s=this.vars[e];for(const e of s)t+=`${this.getVar(e.type,e.name)}; `;return t}getUniforms(){}getCodes(e){const t=this.codes[e];let s="";for(const e of t)s+=e.code+"\n";return s}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(e){this.shaderStage=e}getShaderStage(){return this.shaderStage}setBuildStage(e){this.buildStage=e}getBuildStage(){return this.buildStage}buildCode(){}build(){for(const e of Ts){this.setBuildStage(e),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const t of _s){this.setShaderStage(t);const s=this.flowNodes[t];for(const t of s)"generate"===e?this.flowNode(t):t.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this}createNodeMaterial(e){return tl(e)}format(e,t,s){if((t=this.getVectorType(t))===(s=this.getVectorType(s))||null===s||this.isReference(s))return e;const r=this.getTypeLength(t),n=this.getTypeLength(s);return r>4||n>4||0===n?e:r===n?`${this.getType(s)}( ${e} )`:r>n?this.format(`${e}.${"xyz".slice(0,n)}`,this.getTypeFromLength(n,this.getComponentType(t)),s):4===n?`${this.getType(s)}( ${this.format(e,t,"vec3")}, 1.0 )`:2===r?`${this.getType(s)}( ${this.format(e,t,"vec2")}, 0.0 )`:`${this.getType(s)}( ${e} )`}getSignature(){return`// Three.js r${C} - NodeMaterial System\n`}}class dl{constructor(){this.time=0,this.deltaTime=0,this.frameId=0,this.renderId=0,this.startTime=null,this.frameMap=new WeakMap,this.frameBeforeMap=new WeakMap,this.renderMap=new WeakMap,this.renderBeforeMap=new WeakMap,this.renderer=null,this.material=null,this.camera=null,this.object=null,this.scene=null}updateBeforeNode(e){const t=e.getUpdateBeforeType();t===Ns?this.frameBeforeMap.get(e)!==this.frameId&&(this.frameBeforeMap.set(e,this.frameId),e.updateBefore(this)):t===ys?this.renderBeforeMap.get(e)===this.renderId&&this.frameBeforeMap.get(e)===this.frameId||(this.renderBeforeMap.set(e,this.renderId),this.frameBeforeMap.set(e,this.frameId),e.updateBefore(this)):t===vs&&e.updateBefore(this)}updateNode(e){const t=e.getUpdateType();t===Ns?this.frameMap.get(e)!==this.frameId&&(this.frameMap.set(e,this.frameId),e.update(this)):t===ys?this.renderMap.get(e)===this.renderId&&this.frameMap.get(e)===this.frameId||(this.renderMap.set(e,this.renderId),this.frameMap.set(e,this.frameId),e.update(this)):t===vs&&e.update(this)}update(){this.frameId++,void 0===this.lastTime&&(this.lastTime=performance.now()),this.deltaTime=(performance.now()-this.lastTime)/1e3,this.lastTime=performance.now(),this.time+=this.deltaTime}}class hl{constructor(e,t,s=null,r="",n=!1){this.type=e,this.name=t,this.count=s,this.qualifier=r,this.isConst=n}}let pl;hl.isNodeFunctionInput=!0;class ml extends La{constructor(e){pl=pl||ro("discard"),super(e,pl)}}qs("discard",mr(ml)),Is(ml);class gl extends Gs{constructor(){super("vec2")}construct(){const e=Ar(aa.z,0,aa.x.negate()).normalize(),t=aa.cross(e);return _r(e.dot(Po),t.dot(Po)).mul(.495).add(.5)}}gr(gl),Is(gl);class fl extends $r{constructor(e=fl.LOCAL,t=1,s=0){super(s),this.scope=e,this.scale=t,this.updateType=Ns}update(e){const t=this.scope,s=this.scale;t===fl.LOCAL?this.value+=e.deltaTime*s:t===fl.DELTA?this.value=e.deltaTime*s:t===fl.FRAME?this.value=e.frameId:this.value=e.time*s}serialize(e){super.serialize(e),e.scope=this.scope,e.scale=this.scale}deserialize(e){super.deserialize(e),this.scope=e.scope,this.scale=e.scale}}fl.LOCAL="local",fl.GLOBAL="global",fl.DELTA="delta",fl.FRAME="frame";gr(fl,fl.FRAME),Is(fl);class xl extends Os{constructor(e=xl.SINE,t=((e,t=0)=>dr(new fl(fl.LOCAL,e,t)))()){super(),this.method=e,this.timeNode=t}getNodeType(e){return this.timeNode.getNodeType(e)}construct(){const e=this.method,t=dr(this.timeNode);let s=null;return e===xl.SINE?s=t.add(.75).mul(2*Math.PI).sin().mul(.5).add(.5):e===xl.SQUARE?s=t.fract().round():e===xl.TRIANGLE?s=t.add(.5).fract().mul(2).sub(1).abs():e===xl.SAWTOOTH&&(s=t.fract()),s}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}xl.SINE="sine",xl.SQUARE="square",xl.TRIANGLE="triangle",xl.SAWTOOTH="sawtooth",mr(xl,xl.SINE),mr(xl,xl.SQUARE),mr(xl,xl.TRIANGLE),mr(xl,xl.SAWTOOTH),Is(xl);class bl extends Gs{constructor(e,t){super(),this.scope=e,this.node=t}getNodeType(e){return this.node.getNodeType(e)}construct(){const{scope:e,node:t}=this;let s=null;return e===bl.DIRECTION_TO_COLOR?s=t.mul(.5).add(.5):e===bl.COLOR_TO_DIRECTION&&(s=t.mul(2).sub(1)),s}}bl.DIRECTION_TO_COLOR="directionToColor",bl.COLOR_TO_DIRECTION="colorToDirection";const Nl=mr(bl,bl.DIRECTION_TO_COLOR),yl=mr(bl,bl.COLOR_TO_DIRECTION);qs("directionToColor",Nl),qs("colorToDirection",yl),Is(bl);class vl extends Os{constructor(e,t,s,r,n){super(),this.node=e,this.inLowNode=t,this.inHighNode=s,this.outLowNode=r,this.outHighNode=n,this.doClamp=!0}construct(){const{node:e,inLowNode:t,inHighNode:s,outLowNode:r,outHighNode:n,doClamp:i}=this;let o=e.sub(t).div(s.sub(t));return!0===i&&(o=o.clamp()),o.mul(n.sub(r)).add(r)}}const Tl=mr(vl,null,null,{doClamp:!1}),_l=mr(vl);qs("remap",Tl),qs("remapClamp",_l),Is(vl);class Sl extends Gs{constructor(e,t,s=_r(.5)){super("vec2"),this.uvNode=e,this.rotationNode=t,this.centerNode=s}construct(){const{uvNode:e,rotationNode:t,centerNode:s}=this,r=t.cos(),n=t.sin(),i=e.sub(s);return _r(_r(r,n).dot(i),_r(n.negate(),r).dot(i)).add(s)}}qs("rotateUV",mr(Sl)),Is(Sl);class wl extends Os{constructor(e,t=An(),s=Nr(0)){super("vec2"),this.countNode=e,this.uvNode=t,this.frameNode=s}construct(){const{frameNode:e,uvNode:t,countNode:s}=this,{width:r,height:n}=s,i=e.mod(r.mul(n)).floor(),o=i.mod(r),a=n.sub(i.add(1).div(r).ceil()),l=s.reciprocal(),u=_r(o,a);return t.add(u).mul(l)}}mr(wl),Is(wl);class Cl extends Os{constructor(e,t=null,s=null,r=Nr(1),n=na,i=zo){super("vec4"),this.textureXNode=e,this.textureYNode=t,this.textureZNode=s,this.scaleNode=r,this.positionNode=n,this.normalNode=i}construct(){const{textureXNode:e,textureYNode:t,textureZNode:s,scaleNode:r,positionNode:n,normalNode:i}=this;let o=i.abs().normalize();o=o.div(o.dot(Ar(1)));const a=n.yz.mul(r),l=n.zx.mul(r),u=n.xy.mul(r),c=e.value,d=null!==t?t.value:c,h=null!==s?s.value:c,p=io(c,a).mul(o.x),m=io(d,l).mul(o.y),g=io(h,u).mul(o.z);return Bn(p,m,g)}}const Al=mr(Cl);qs("triplanarTexture",((...e)=>Al(...e))),Is(Cl);const Rl=1/6,Ml=e=>On(Rl,On(e,On(e,e.negate().add(3)).sub(3)).add(1)),El=e=>On(Rl,On(e,On(e,On(3,e).sub(6))).add(4)),Bl=e=>On(Rl,On(e,On(e,On(-3,e).add(3)).add(3)).add(1)),Ul=e=>On(Rl,Di(e,3)),Ol=e=>Ml(e).add(El(e)),Il=e=>Bl(e).add(Ul(e)),Fl=e=>Bn(-1,El(e).div(Ml(e).add(El(e)))),Ll=e=>Bn(1,Ul(e).div(Bl(e).add(Ul(e)))),Dl=(e,t,s)=>{const r=e.uvNode,n=On(r,t.zw).add(.5),i=oi(n),o=ui(n),a=Ol(o.x),l=Il(o.x),u=Fl(o.x),c=Ll(o.x),d=Fl(o.y),h=Ll(o.y),p=_r(i.x.add(u),i.y.add(d)).sub(.5).mul(t.xy),m=_r(i.x.add(c),i.y.add(d)).sub(.5).mul(t.xy),g=_r(i.x.add(u),i.y.add(h)).sub(.5).mul(t.xy),f=_r(i.x.add(c),i.y.add(h)).sub(.5).mul(t.xy),x=Ol(o.y).mul(Bn(a.mul(e.uv(p).level(s)),l.mul(e.uv(m).level(s)))),b=Il(o.y).mul(Bn(a.mul(e.uv(g).level(s)),l.mul(e.uv(f).level(s))));return x.add(b)};class Gl extends Gs{constructor(e,t=Nr(3)){super("vec4"),this.textureNode=e,this.blurNode=t}construct(){return((e,t)=>{const s=_r(e.size(yr(t))),r=_r(e.size(yr(t.add(1)))),n=In(1,s),i=In(1,r),o=Dl(e,Br(n,s),oi(t)),a=Dl(e,Br(i,r),ai(t));return ui(t).mix(o,a)})(this.textureNode,this.blurNode)}}qs("bicubic",mr(Gl)),Is(Gl);class kl extends Os{constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}gr(kl),Is(kl);class zl extends Os{constructor(e=zl.BACKGROUND_BLURRINESS,t=null){super(),this.scope=e,this.scene=t}construct(e){const t=this.scope,s=null!==this.scene?this.scene:e.scene;let r;return t===zl.BACKGROUND_BLURRINESS&&(r=ao("backgroundBlurriness","float",s)),r}}zl.BACKGROUND_BLURRINESS="backgroundBlurriness";const Pl=gr(zl,zl.BACKGROUND_BLURRINESS);Is(zl);Is(class StorageBufferNode extends wa{constructor(e,t,s=0){super(e,t,s),this.isStorageBufferNode=!0}getInputType(){return"storageBuffer"}});Is(class UserDataNode extends oo{constructor(e,t,s=null){super(e,t,s),this.userData=s}update(e){this.object=null!==this.userData?this.userData:e.object.userData,super.update(e)}});const Vl=xr((({base:e,blend:t})=>{const s=s=>t[s].lessThan(Kn).cond(t[s],e[s].oneMinus().div(t[s]).oneMinus().max(0));return Ar(s("x"),s("y"),s("z"))})),$l=xr((({base:e,blend:t})=>{const s=s=>t[s].equal(1).cond(t[s],e[s].div(t[s].oneMinus()).max(0));return Ar(s("x"),s("y"),s("z"))})),ql=xr((({base:e,blend:t})=>{const s=s=>e[s].oneMinus().mul(t[s].oneMinus()).oneMinus();return Ar(s("x"),s("y"),s("z"))})),jl=xr((({base:e,blend:t})=>{const s=s=>e[s].lessThan(.5).cond(e[s].mul(t[s],2),e[s].oneMinus().mul(t[s].oneMinus()).oneMinus());return Ar(s("x"),s("y"),s("z"))}));class Wl extends Gs{constructor(e,t,s){super(),this.blendMode=e,this.baseNode=t,this.blendNode=s}construct(){const{blendMode:e,baseNode:t,blendNode:s}=this,r={base:t,blend:s};let n=null;return e===Wl.BURN?n=Vl(r):e===Wl.DODGE?n=$l(r):e===Wl.SCREEN?n=ql(r):e===Wl.OVERLAY&&(n=jl(r)),n}}Wl.BURN="burn",Wl.DODGE="dodge",Wl.SCREEN="screen",Wl.OVERLAY="overlay";const Hl=mr(Wl,Wl.BURN),Xl=mr(Wl,Wl.DODGE),Yl=mr(Wl,Wl.OVERLAY),Zl=mr(Wl,Wl.SCREEN);qs("burn",Hl),qs("dodge",Xl),qs("overlay",Yl),qs("screen",Zl),Is(Wl);const Kl=xr((({color:e,adjustment:t})=>t.mix(iu(e),e))),Jl=xr((({color:e,adjustment:t})=>{const s=Bn(e.r,e.g,e.b).div(3),r=e.r.max(e.g.max(e.b)),n=r.sub(s).mul(t).mul(-3);return Vi(e,r,n)})),Ql=xr((({color:e,adjustment:t})=>{const s=Fr(.299,.587,.114,.595716,-.274453,-.321263,.211456,-.522591,.311135),r=Fr(1,.9563,.621,1,-.2721,-.6474,1,-1.107,1.7046),n=s.mul(e),i=n.z.atan2(n.y).add(t),o=n.yz.length();return r.mul(Ar(n.x,o.mul(i.cos()),o.mul(i.sin())))}));class eu extends Gs{constructor(e,t,s=Nr(1)){super("vec3"),this.method=e,this.colorNode=t,this.adjustmentNode=s}construct(){const{method:e,colorNode:t,adjustmentNode:s}=this,r={color:t,adjustment:s};let n=null;return e===eu.SATURATION?n=Kl(r):e===eu.VIBRANCE?n=Jl(r):e===eu.HUE&&(n=Ql(r)),n}}eu.SATURATION="saturation",eu.VIBRANCE="vibrance",eu.HUE="hue";const tu=mr(eu,eu.SATURATION),su=mr(eu,eu.VIBRANCE),ru=mr(eu,eu.HUE),nu=Ar(.2125,.7154,.0721),iu=(e,t=nu)=>Fi(e,t);qs("saturation",tu),qs("vibrance",su),qs("hue",ru),Is(eu);class ou extends Gs{constructor(e,t){super(),this.sourceNode=e,this.stepsNode=t}construct(){const{sourceNode:e,stepsNode:t}=this;return e.mul(t).floor().div(t)}}qs("posterize",mr(ou)),Is(ou);const au=xr((({color:e,exposure:t})=>e.mul(t).clamp())),lu=xr((({color:e,exposure:t})=>(e=e.mul(t)).div(e.add(1)).clamp())),uu=xr((({color:e,exposure:t})=>{const s=(e=(e=e.mul(t)).sub(.004).max(0)).mul(e.mul(6.2).add(.5)),r=e.mul(e.mul(6.2).add(1.7)).add(.06);return s.div(r).pow(2.2)})),cu=xr((({color:e})=>{const t=e.mul(e.add(.0245786)).sub(90537e-9),s=e.mul(e.add(.432951).mul(.983729)).add(.238081);return t.div(s)})),du=xr((({color:e,exposure:t})=>{const s=Fr(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),r=Fr(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return e=e.mul(t).div(.6),e=s.mul(e),e=cu({color:e}),(e=r.mul(e)).clamp()})),hu={[R]:au,[M]:lu,[E]:uu,[B]:du};class ToneMappingNode extends Gs{constructor(e=A,t=Nr(1),s=null){super("vec3"),this.toneMapping=e,this.exposureNode=t,this.colorNode=s}getCacheKey(){let e=super.getCacheKey();return e="{toneMapping:"+this.toneMapping+",nodes:"+e+"}",e}construct(e){const t=this.colorNode||e.context.color,s=this.toneMapping;if(s===A)return t;const r={exposure:this.exposureNode,color:t},n=hu[s];let i=null;return i=n?n(r):t,i}}let pu;Is(ToneMappingNode);class mu extends Os{constructor(e){super(),this.scope=e,this.isViewportNode=!0}getNodeType(){return this.scope===mu.COORDINATE?"vec4":"vec2"}getUpdateType(){let e=bs;return this.scope===mu.RESOLUTION&&(e=Ns),this.updateType=e,e}update({renderer:e}){e.getDrawingBufferSize(pu)}construct(e){const t=this.scope;if(t===mu.COORDINATE)return;let s=null;if(t===mu.RESOLUTION)s=qr(pu||(pu=new n));else{const r=_r(new mu(mu.COORDINATE)),n=new mu(mu.RESOLUTION);s=r.div(n);let i=s.x,o=s.y;(/top/i.test(t)&&e.isFlipY()||/bottom/i.test(t)&&!1===e.isFlipY())&&(o=o.oneMinus()),/right/i.test(t)&&(i=i.oneMinus()),s=_r(i,o)}return s}generate(e){return this.scope===mu.COORDINATE?e.getFragCoord():super.generate(e)}}mu.COORDINATE="coordinate",mu.RESOLUTION="resolution",mu.TOP_LEFT="topLeft",mu.BOTTOM_LEFT="bottomLeft",mu.TOP_RIGHT="topRight",mu.BOTTOM_RIGHT="bottomRight",gr(mu,mu.COORDINATE),gr(mu,mu.RESOLUTION);const gu=gr(mu,mu.TOP_LEFT),fu=gr(mu,mu.BOTTOM_LEFT);gr(mu,mu.TOP_RIGHT),gr(mu,mu.BOTTOM_RIGHT),Is(mu);const xu=new n;class bu extends no{constructor(e=gu,t=null,s=null){null===s&&((s=new U).minFilter=O),super(s,e,t),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=Ns}updateBefore(e){const t=e.renderer;t.getDrawingBufferSize(xu);const s=this.value;s.image.width===xu.width&&s.image.height===xu.height||(s.image.width=xu.width,s.image.height=xu.height,s.needsUpdate=!0);const r=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,t.copyFramebufferToTexture(s),s.generateMipmaps=r}clone(){return new this.constructor(this.uvNode,this.levelNode,this.value)}}const Nu=mr(bu),yu=mr(bu,null,null,{generateMipmaps:!0});qs("viewportTexture",Nu),qs("viewportMipTexture",yu),Is(bu);let vu=null;class Tu extends bu{constructor(e=gu,t=null){null===vu&&(vu=new U),super(e,t,vu)}}qs("viewportSharedTexture",mr(Tu)),Is(Tu);let _u=null;class Su extends bu{constructor(e=gu,t=null){null===_u&&(_u=new b,_u.minFilter=O,_u.type=I,_u.format=F),super(e,t,_u)}}const wu=mr(Su);qs("viewportDepthTexture",wu),Is(Su);class Cu extends Os{constructor(e,t=null){super("float"),this.scope=e,this.textureNode=t,this.isViewportDepthNode=!0}construct(){const{scope:e}=this;let t=null;if(e===Cu.DEPTH)t=Au(oa.z,Mo,Eo);else if(e===Cu.DEPTH_TEXTURE){const e=this.textureNode||wu(),s=Ru(e,Mo,Eo);t=Au(s,Mo,Eo)}return t}}const Au=(e,t,s)=>e.add(t).div(t.sub(s)),Ru=(e,t,s)=>t.mul(s).div(s.sub(t).mul(e).sub(s));Cu.DEPTH="depth",Cu.DEPTH_TEXTURE="depthTexture",gr(Cu,Cu.DEPTH),mr(Cu,Cu.DEPTH_TEXTURE),Is(Cu);class Mu extends Os{constructor(e="",t=[],s=""){super("code"),this.isCodeNode=!0,this.code=e,this.language=s,this._includes=t}setIncludes(e){return this._includes=e,this}getIncludes(){return this._includes}generate(e){const t=this.getIncludes(e);for(const s of t)s.build(e);const s=e.getCodeFromNode(this,this.getNodeType(e));return s.code=this.code,s.code}serialize(e){super.serialize(e),e.code=this.code,e.language=this.language}deserialize(e){super.deserialize(e),this.code=e.code,this.language=e.language}}const Eu=mr(Mu),Bu=(e,t)=>Eu(e,t,"glsl");Is(Mu);class Uu extends Gs{constructor(e=null,t={}){super(),this.functionNode=e,this.parameters=t}setParameters(e){return this.parameters=e,this}getParameters(){return this.parameters}getNodeType(e){return this.functionNode.getNodeType(e)}generate(e){const t=[],s=this.functionNode,r=s.getInputs(e),n=this.parameters;if(Array.isArray(n))for(let s=0;s<n.length;s++){const i=r[s],o=n[s];t.push(o.build(e,i.type))}else for(const s of r){const r=n[s.name];if(void 0===r)throw new Error(`FunctionCallNode: Input '${s.name}' not found in FunctionNode.`);t.push(r.build(e,s.type))}return`${s.build(e,"property")}( ${t.join(", ")} )`}}qs("call",((e,...t)=>(t=t.length>1||t[0]&&!0===t[0].isNode?pr(t):hr(t[0]),dr(new Uu(dr(e),t))))),Is(Uu);Is(class FunctionNode extends Mu{constructor(e="",t=[],s=""){super(e,t,s),this.keywords={}}getNodeType(e){return this.getNodeFunction(e).type}getInputs(e){return this.getNodeFunction(e).inputs}getNodeFunction(e){const t=e.getDataFromNode(this);let s=t.nodeFunction;return void 0===s&&(s=e.parser.parseFunction(this.code),t.nodeFunction=s),s}generate(e,t){super.generate(e);const s=this.getNodeFunction(e),r=s.name,n=s.type,i=e.getCodeFromNode(this,n);""!==r&&(i.name=r);const o=e.getPropertyName(i);let a=this.getNodeFunction(e).getCode(o);const l=this.keywords,u=Object.keys(l);if(u.length>0)for(const t of u){const s=new RegExp(`\\b${t}\\b`,"g"),r=l[t].build(e,"property");a=a.replace(s,r)}return i.code=a,"property"===t?o:e.format(`${o}()`,n,t)}});class Ou extends Os{constructor(e=null){super(),this._value=e,this._cache=null,this.inputType=null,this.outpuType=null,this.events=new L,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return null!==this.outputType}set value(e){this._value!==e&&(this._cache&&"URL"===this.inputType&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=e,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const e=this.value;if(e&&null===this._cache&&"URL"===this.inputType&&e.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([e.value]));else if(e&&null!==e.value&&void 0!==e.value&&(("URL"===this.inputType||"String"===this.inputType)&&"string"==typeof e.value||"Number"===this.inputType&&"number"==typeof e.value||"Vector2"===this.inputType&&e.value.isVector2||"Vector3"===this.inputType&&e.value.isVector3||"Vector4"===this.inputType&&e.value.isVector4||"Color"===this.inputType&&e.value.isColor||"Matrix3"===this.inputType&&e.value.isMatrix3||"Matrix4"===this.inputType&&e.value.isMatrix4))return e.value;return this._cache||e}getNodeType(e){return this.value&&this.value.isNode?this.value.getNodeType(e):"float"}construct(){return this.value&&this.value.isNode?this.value:Nr()}serialize(e){super.serialize(e),null!==this.value?"ArrayBuffer"===this.inputType?e.value=Ms(this.value):e.value=this.value?this.value.toJSON(e.meta).uuid:null:e.value=null,e.inputType=this.inputType,e.outputType=this.outputType}deserialize(e){super.deserialize(e);let t=null;null!==e.value&&(t="ArrayBuffer"===e.inputType?Es(e.value):"Texture"===e.inputType?e.meta.textures[e.value]:e.meta.nodes[e.value]||null),this.value=t,this.inputType=e.inputType,this.outputType=e.outputType}}const Iu=mr(Ou);qs("scriptableValue",Iu),Is(Ou);class Fu extends Map{get(e,t=null,...s){if(this.has(e))return super.get(e);if(null!==t){const r=t(...s);return this.set(e,r),r}}}class Lu{constructor(e){this.scriptableNode=e}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(e){return this.scriptableNode.getInputLayout(e)}get(e){const t=this.parameters[e];return t?t.getValue():null}}const Du=new Fu;class Gu extends Os{constructor(e=null,t={}){super(),this.codeNode=e,this.parameters=t,this._local=new Fu,this._output=Iu(),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(e,t){return this._local.set(e,t)}getLocal(e){return this._local.get(e)}onRefresh(){this._refresh()}getInputLayout(e){for(const t of this.getLayout())if(t.inputType&&(t.id===e||t.name===e))return t}getOutputLayout(e){for(const t of this.getLayout())if(t.outputType&&(t.id===e||t.name===e))return t}setOutput(e,t){const s=this._outputs;return void 0===s[e]?s[e]=Iu(t):s[e].value=t,this}getOutput(e){return this._outputs[e]}getParameter(e){return this.parameters[e]}setParameter(e,t){const s=this.parameters;return t&&t.isScriptableNode?(this.deleteParameter(e),s[e]=t,s[e].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):t&&t.isScriptableValueNode?(this.deleteParameter(e),s[e]=t,s[e].events.addEventListener("refresh",this.onRefresh)):void 0===s[e]?(s[e]=Iu(t),s[e].events.addEventListener("refresh",this.onRefresh)):s[e].value=t,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(e){let t=this.parameters[e];return t&&(t.isScriptableNode&&(t=t.getDefaultOutput()),t.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const e of Object.keys(this.parameters))this.deleteParameter(e);return this.needsUpdate=!0,this}call(e,...t){const s=this.getObject()[e];if("function"==typeof s)return s(...t)}async callAsync(e,...t){const s=this.getObject()[e];if("function"==typeof s)return"AsyncFunction"===s.constructor.name?await s(...t):s(...t)}getNodeType(e){return this.getDefaultOutputNode().getNodeType(e)}refresh(e=null){null!==e?this.getOutput(e).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),null!==this._object)return this._object;const e=new Lu(this),t=Du.get("THREE"),s=Du.get("TSL"),r=this.getMethod(this.codeNode),n=[e,this._local,Du,()=>this.refresh(),(e,t)=>this.setOutput(e,t),t,s];this._object=r(...n);const i=this._object.layout;if(i&&(!1===i.cache&&this._local.clear(),this._output.outputType=i.outputType||null,Array.isArray(i.elements)))for(const e of i.elements){const t=e.id||e.name;e.inputType&&(void 0===this.getParameter(t)&&this.setParameter(t,null),this.getParameter(t).inputType=e.inputType),e.outputType&&(void 0===this.getOutput(t)&&this.setOutput(t,null),this.getOutput(t).outputType=e.outputType)}return this._object}deserialize(e){super.deserialize(e);for(const e in this.parameters){let t=this.parameters[e];t.isScriptableNode&&(t=t.getDefaultOutput()),t.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const e=this.getDefaultOutput().value;return e&&e.isNode?e:Nr()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),null!==this._method)return this._method;const e=["layout","init","main","dispose"].join(", "),t="\nreturn { ...output, "+e+" };",s="var "+e+"; var output = {};\n"+this.codeNode.code+t;return this._method=new Function(...["parameters","local","global","refresh","setOutput","THREE","TSL"],s),this._method}dispose(){null!==this._method&&(this._object&&"function"==typeof this._object.dispose&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}construct(){return this.getDefaultOutputNode()}set needsUpdate(e){!0===e&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return null===this.codeNode||(!0===this._needsOutputUpdate&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value),this}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}qs("scriptable",mr(Gu)),Is(Gu);class ku extends Os{constructor(e,t){super("float"),this.isFogNode=!0,this.colorNode=e,this.factorNode=t}mixAssign(e){return this.mix(e,this.colorNode)}construct(){return this.factorNode}}qs("fog",mr(ku)),Is(ku);class zu extends ku{constructor(e,t,s){super(e),this.isFogRangeNode=!0,this.nearNode=t,this.farNode=s}construct(){return ji(this.nearNode,this.farNode,oa.z.negate())}}const Pu=mr(zu);qs("rangeFog",Pu),Is(zu);class Vu extends ku{constructor(e,t){super(e),this.isFogExp2Node=!0,this.densityNode=t}construct(){const e=oa.z.negate(),t=this.densityNode;return t.mul(t,e,e).negate().exp().oneMinus()}}const $u=mr(Vu);qs("densityFog",$u),Is(Vu);let qu=null,ju=null;class Wu extends Os{constructor(e=Nr(),t=Nr()){super(),this.minNode=e,this.maxNode=t}getVectorLength(e){const t=e.getTypeLength(As(this.minNode.value)),s=e.getTypeLength(As(this.maxNode.value));return t>s?t:s}getNodeType(e){return!0===e.object.isInstancedMesh?e.getTypeFromLength(this.getVectorLength(e)):"float"}construct(e){const t=e.object;let s=null;if(!0===t.isInstancedMesh){let r=this.minNode.value,n=this.maxNode.value;const i=e.getTypeLength(As(r)),a=e.getTypeLength(As(n));qu=qu||new o,ju=ju||new o,qu.setScalar(0),ju.setScalar(0),1===i?qu.setScalar(r):r.isColor?qu.set(r.r,r.g,r.b):qu.set(r.x,r.y,r.z||0,r.w||0),1===a?ju.setScalar(n):n.isColor?ju.set(n.r,n.g,n.b):ju.set(n.x,n.y,n.z||0,n.w||0);const l=4,c=l*t.count,d=new Float32Array(c);for(let e=0;e<c;e++){const t=e%l,s=qu.getComponent(t),r=ju.getComponent(t);d[e]=u.lerp(s,r,Math.random())}const h=this.getNodeType(e);s=Ca(d,"vec4",t.count).element(on).convert(h)}else s=Nr(0);return s}}mr(Wu),Is(Wu);class Hu extends Os{constructor(e,t,s=[64]){super("void"),this.isComputeNode=!0,this.computeNode=e,this.count=t,this.workgroupSize=s,this.dispatchCount=0,this.updateType=vs,this.updateDispatchCount()}updateDispatchCount(){const{count:e,workgroupSize:t}=this;let s=t[0];for(let e=1;e<t.length;e++)s*=t[e];this.dispatchCount=Math.ceil(e/s)}onInit(){}update({renderer:e}){e.compute(this)}generate(e){const{shaderStage:t}=e;if("compute"===t){const t=this.computeNode.build(e,"void");""!==t&&e.addLineFlowCode(t)}}}qs("compute",((e,t,s)=>dr(new Hu(dr(e),t,s)))),Is(Hu);class Xu extends Os{constructor(e=Xu.TARGET_DIRECTION,t=null){super(),this.scope=e,this.light=t}construct(){const{scope:e,light:t}=this;let s=null;return e===Xu.TARGET_DIRECTION&&(s=Bo.transformDirection(wo(t).sub(wo(t.target)))),s}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}Xu.TARGET_DIRECTION="targetDirection";const Yu=mr(Xu,Xu.TARGET_DIRECTION);Is(Xu);const Zu=xr((e=>{const{lightDistance:t,cutoffDistance:s,decayExponent:r}=e,n=t.pow(r).max(.01).reciprocal();return s.greaterThan(0).cond(n.mul(t.div(s).pow4().oneMinus().clamp().pow2()),n)}));class Ku extends ka{constructor(e=null){super(e),this.cutoffDistanceNode=qr(0),this.decayExponentNode=qr(0)}update(e){const{light:t}=this;super.update(e),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}construct(e){const{colorNode:t,cutoffDistanceNode:s,decayExponentNode:r,light:n}=this,i=Co(n).sub(oa),o=i.normalize(),a=i.length(),l=Zu({lightDistance:a,cutoffDistance:s,decayExponent:r}),u=t.mul(l),c=e.context.lightingModelNode,d=e.context.reflectedLight;c&&c.direct&&c.direct({lightDirection:o,lightColor:u,reflectedLight:d})}}Va(D,Ku),Is(Ku);class Ju extends ka{constructor(e=null){super(e)}construct(e){super.construct(e);const t=this.colorNode,s=Yu(this.light),r=e.context.lightingModelNode,n=e.context.reflectedLight;r&&r.direct&&r.direct({lightDirection:s,lightColor:t,reflectedLight:n})}}Va(G,Ju),Is(Ju);class Qu extends ka{constructor(e=null){super(e),this.coneCosNode=qr(0),this.penumbraCosNode=qr(0),this.cutoffDistanceNode=qr(0),this.decayExponentNode=qr(0)}update(e){super.update(e);const{light:t}=this;this.coneCosNode.value=Math.cos(t.angle),this.penumbraCosNode.value=Math.cos(t.angle*(1-t.penumbra)),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}getSpotAttenuation(e){const{coneCosNode:t,penumbraCosNode:s}=this;return ji(t,s,e)}construct(e){super.construct(e);const{colorNode:t,cutoffDistanceNode:s,decayExponentNode:r,light:n}=this,i=Co(n).sub(oa),o=i.normalize(),a=o.dot(Yu(n)),l=this.getSpotAttenuation(a),u=i.length(),c=Zu({lightDistance:u,cutoffDistance:s,decayExponent:r}),d=t.mul(l).mul(c),h=e.context.lightingModelNode,p=e.context.reflectedLight;h&&h.direct&&h.direct({lightDirection:o,lightColor:d,reflectedLight:p})}}Va(k,Qu),Is(Qu);class IESSpotLightNode extends Qu{getSpotAttenuation(e){const t=this.light.iesMap;let s=null;if(t&&!0===t.isTexture){const r=e.acos().mul(1/Math.PI);s=io(t,_r(r,0),0).r}else s=super.getSpotAttenuation(e);return s}}Va(class IESSpotLight extends k{constructor(e,t,s,r,n,i){super(e,t,s,r,n,i),this.iesMap=null}copy(e,t){return super.copy(e,t),this.iesMap=e.iesMap,this}},IESSpotLightNode),Is(IESSpotLightNode);class ec extends ka{constructor(e=null){super(e)}construct({context:e}){e.irradiance.addAssign(this.colorNode)}}Va(z,ec),Is(ec);class tc extends tn{constructor(e,t=null,s=null,r=null){super(e),this.lightingModelNode=t,this.backdropNode=s,this.backdropAlphaNode=r}getNodeType(){return"vec3"}construct(e){const{lightingModelNode:t,backdropNode:s,backdropAlphaNode:r}=this,n=this.context={},i=e.getNodeProperties(this),o=Ar().temp(),a=Ar().temp(),l=Ar().temp(),u=Ar().temp();let c=Bn(o,l);null!==s&&(c=Ar(null!==r?Vi(c,s,r):s));const d=Bn(a,u),h={directDiffuse:o,directSpecular:a,indirectDiffuse:l,indirectSpecular:u,total:Bn(c,d).temp()},p={radiance:Ar().temp(),irradiance:Ar().temp(),iblIrradiance:Ar().temp(),ambientOcclusion:Nr(1).temp()};return n.reflectedLight=h,n.lightingModelNode=t||n.lightingModelNode,Object.assign(i,h,p),Object.assign(n,p),t&&t.init&&t.init(n,e.stack,e),t&&t.indirectDiffuse&&t.indirectDiffuse(n,e.stack,e),t&&t.indirectSpecular&&t.indirectSpecular(n,e.stack,e),t&&t.ambientOcclusion&&t.ambientOcclusion(n,e.stack,e),super.construct(e)}generate(e){const{context:t}=this,s=this.getNodeType(e);return super.generate(e,s),t.reflectedLight.total.build(e,s)}}qs("lightingContext",mr(tc)),Is(tc);class sc extends ka{constructor(e=null){super(e),this.lightPositionNode=wo(e),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=qr(new r)}update(e){const{light:t}=this;super.update(e),this.lightPositionNode.object3d=t,this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity)}generate(e){const{colorNode:t,groundColorNode:s,lightDirectionNode:r}=this,n=ko.dot(r).mul(.5).add(.5),i=Vi(s,t,n);e.context.irradiance.addAssign(i)}}Va(P,sc),Is(sc);const rc=xr((e=>{const t=e.uv.mul(2),s=t.x.floor(),r=t.y.floor();return s.add(r).mod(2).sign()}));class nc extends Gs{constructor(e=An()){super("float"),this.uvNode=e}generate(e){return rc({uv:this.uvNode}).build(e)}}qs("checker",mr(nc)),Is(nc);const ic=new V;el(class LineBasicNodeMaterial extends NodeMaterial{constructor(e){super(),this.isLineBasicNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(ic),this.setValues(e)}});const oc=new $;el(class MeshNormalNodeMaterial extends NodeMaterial{constructor(e){super(),this.isMeshNormalNodeMaterial=!0,this.setDefaultValues(oc),this.setValues(e)}constructDiffuseColor({stack:e}){const t=this.opacityNode?Nr(this.opacityNode):mo;e.assign(xn,Br(Nl(Po),t))}});const ac=new q;class MeshBasicNodeMaterial extends NodeMaterial{constructor(e){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!1,this.setDefaultValues(ac),this.setValues(e)}}el(MeshBasicNodeMaterial);const lc=xr((e=>e.diffuseColor.mul(1/Math.PI))),uc=xr((({f0:e,f90:t,dotVH:s})=>{const r=s.mul(-5.55473).sub(6.98316).mul(s).exp2();return e.mul(r.oneMinus()).add(t.mul(r))})),cc=xr((({dotNH:e})=>wn.mul(.5/Math.PI).add(1).mul(e.pow(wn)))),dc=xr((({lightDirection:e})=>{const t=e.add(aa).normalize(),s=Po.dot(t).clamp(),r=aa.dot(t).clamp(),n=uc({f0:Sn,f90:1,dotVH:r}),i=Nr(.25),o=cc({dotNH:s});return n.mul(i).mul(o)})),hc=ln(null,xr((({lightDirection:e,lightColor:t,reflectedLight:s})=>{const r=Po.dot(e).clamp().mul(t);s.directDiffuse.addAssign(r.mul(lc({diffuseColor:xn.rgb}))),s.directSpecular.addAssign(r.mul(dc({lightDirection:e})).mul(fo))})),xr((({irradiance:e,reflectedLight:t})=>{t.indirectDiffuse.addAssign(e.mul(lc({diffuseColor:xn})))}))),pc=new j;el(class MeshPhongNodeMaterial extends NodeMaterial{constructor(e){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(pc),this.setValues(e)}constructLightingModel(){return hc}constructVariants({stack:e}){const t=(this.shininessNode?Nr(this.shininessNode):ho).max(1e-4);e.assign(wn,t);const s=this.specularNode||go;e.assign(Sn,s)}copy(e){return this.shininessNode=e.shininessNode,this.specularNode=e.specularNode,super.copy(e)}});const mc=xr((()=>{const e=Do.dFdx().abs().max(Do.dFdy().abs());return e.x.max(e.y).max(e.z)})),gc=xr((e=>{const{roughness:t}=e,s=mc();let r=t.max(.0525);return r=r.add(s),r=r.min(1),r})),fc=xr((e=>{const{alpha:t,dotNL:s,dotNV:r}=e,n=t.pow2(),i=s.mul(n.add(n.oneMinus().mul(r.pow2())).sqrt()),o=r.mul(n.add(n.oneMinus().mul(s.pow2())).sqrt());return In(.5,i.add(o).max(Kn))})),xc=xr((e=>{const{alpha:t,dotNH:s}=e,r=t.pow2(),n=s.pow2().mul(r.oneMinus()).oneMinus();return r.div(n.pow2()).mul(1/Math.PI)})),bc=xr((e=>{const{lightDirection:t,f0:s,f90:r,roughness:n}=e,i=e.normalView||Po,o=n.pow2(),a=t.add(aa).normalize(),l=i.dot(t).clamp(),u=i.dot(aa).clamp(),c=i.dot(a).clamp(),d=aa.dot(a).clamp(),h=uc({f0:s,f90:r,dotVH:d}),p=fc({alpha:o,dotNL:l,dotNV:u}),m=xc({alpha:o,dotNH:c});return h.mul(p).mul(m)})),Nc=xr((e=>{const{roughness:t}=e,s=e.dotNV||Po.dot(aa).clamp(),r=Br(-1,-.0275,-.572,.022),n=Br(1,.0425,1.04,-.04),i=t.mul(r).add(n),o=i.x.mul(i.x).min(s.mul(-9.28).exp2()).mul(i.x).add(i.y);return _r(-1.04,1.04).mul(o).add(i.zw)})),yc=xr((e=>{const{dotNV:t,specularColor:s,specularF90:r,roughness:n}=e,i=Nc({dotNV:t,roughness:n});return s.mul(i.x).add(r.mul(i.y))})),vc=xr((({lightDirection:e})=>{const t=e.add(aa).normalize(),s=Po.dot(e).clamp(),r=Po.dot(aa).clamp(),n=Po.dot(t).clamp(),i=((e,t)=>{const s=e.pow2(),r=Nr(1).div(s),n=t.pow2().oneMinus().max(.0078125);return Nr(2).add(r).mul(n.pow(r.mul(.5))).div(2*Math.PI)})(_n,n),o=((e,t)=>Nr(1).div(Nr(4).mul(t.add(e).sub(t.mul(e)))))(r,s);return Tn.mul(i).mul(o)})),Tc=Ar(.04),_c=Ar(1),Sc=xr(((e,t,s)=>{if(s.includes(yn)){e.clearcoatRadiance=Ar().temp(),e.reflectedLight.clearcoatSpecular=Ar().temp();const t=$o.dot(aa).clamp(),s=uc({dotVH:t,f0:Tc,f90:_c}),r=e.reflectedLight.total,n=r.mul(yn.mul(s).oneMinus()).add(e.reflectedLight.clearcoatSpecular.mul(yn));r.assign(n)}if(s.includes(Tn)){e.reflectedLight.sheenSpecular=Ar().temp();const t=e.reflectedLight.total,s=Tn.r.max(Tn.g).max(Tn.b).mul(.157).oneMinus(),r=t.mul(s).add(e.reflectedLight.sheenSpecular);t.assign(r)}})),wc=xr((e=>{const{radiance:t,iblIrradiance:s,reflectedLight:r}=e;if(r.sheenSpecular&&r.sheenSpecular.addAssign(s.mul(Tn,((e,t,s)=>{const r=e.dot(t).saturate(),n=s.pow2(),i=Da(s.lessThan(.25),Nr(-339.2).mul(n).add(Nr(161.4).mul(s)).sub(25.9),Nr(-8.48).mul(n).add(Nr(14.3).mul(s)).sub(9.95)),o=Da(s.lessThan(.25),Nr(44).mul(n).sub(Nr(23.7).mul(s)).add(3.26),Nr(1.97).mul(n).sub(Nr(3.27).mul(s)).add(.72));return Da(s.lessThan(.25),0,Nr(.1).mul(s).sub(.025)).add(i.mul(r).add(o).exp()).mul(1/Math.PI).saturate()})(Po,aa,_n))),r.clearcoatSpecular){const t=$o.dot(aa).clamp(),s=yc({dotNV:t,specularColor:Tc,specularF90:_c,roughness:vn});r.clearcoatSpecular.addAssign(e.clearcoatRadiance.mul(s))}const n=Ar().temp(),i=Ar().temp(),o=s.mul(1/Math.PI);((e,t,s=Nr(1))=>{const r=Nc({roughness:bn}),n=Sn.mul(r.x).add(s.mul(r.y)),i=r.x.add(r.y).oneMinus(),o=Sn.add(Sn.oneMinus().mul(.047619)),a=n.mul(o).div(i.mul(o).oneMinus());e.addAssign(n),t.addAssign(a.mul(i))})(n,i);const a=n.add(i),l=xn.mul(a.r.max(a.g).max(a.b).oneMinus());r.indirectSpecular.addAssign(t.mul(n)),r.indirectSpecular.addAssign(i.mul(o)),r.indirectDiffuse.addAssign(l.mul(o))})),Cc=xr((e=>{const{irradiance:t,reflectedLight:s}=e;s.indirectDiffuse.addAssign(t.mul(lc({diffuseColor:xn})))})),Ac=xr((e=>{const{lightDirection:t,lightColor:s,reflectedLight:r}=e,n=Po.dot(t).clamp().mul(s);if(r.sheenSpecular&&r.sheenSpecular.addAssign(n.mul(vc({lightDirection:t}))),r.clearcoatSpecular){const e=$o.dot(t).clamp().mul(s);r.clearcoatSpecular.addAssign(e.mul(bc({lightDirection:t,f0:Tc,f90:_c,roughness:vn,normalView:$o})))}r.directDiffuse.addAssign(n.mul(lc({diffuseColor:xn.rgb}))),r.directSpecular.addAssign(n.mul(bc({lightDirection:t,f0:Sn,f90:1,roughness:bn})))})),Rc=xr((e=>{const{ambientOcclusion:t,reflectedLight:s}=e,r=Po.dot(aa).clamp().add(t),n=bn.mul(-16).oneMinus().negate().exp2(),i=t.sub(r.pow(n).oneMinus()).clamp();s.indirectDiffuse.mulAssign(t),s.indirectSpecular.mulAssign(i)})),Mc=ln(Sc,Ac,Cc,wc,Rc),Ec=new W;class MeshStandardNodeMaterial extends NodeMaterial{constructor(e){super(),this.isMeshStandardNodeMaterial=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(Ec),this.setValues(e)}constructLightingModel(){return Mc}constructVariants({stack:e}){const t=this.metalnessNode?Nr(this.metalnessNode):bo;e.assign(Nn,t);let s=this.roughnessNode?Nr(this.roughnessNode):xo;s=gc({roughness:s}),e.assign(bn,s);const r=Vi(Ar(.04),xn.rgb,t);e.assign(Sn,r),e.assign(xn,Br(xn.rgb.mul(t.oneMinus()),xn.a))}copy(e){return this.emissiveNode=e.emissiveNode,this.metalnessNode=e.metalnessNode,this.roughnessNode=e.roughnessNode,super.copy(e)}}el(MeshStandardNodeMaterial);const Bc=new H;el(class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial{constructor(e){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.setDefaultValues(Bc),this.setValues(e)}constructVariants(e){super.constructVariants(e);const{stack:t}=e,s=this.clearcoatNode?Nr(this.clearcoatNode):No,r=this.clearcoatRoughnessNode?Nr(this.clearcoatRoughnessNode):yo;t.assign(yn,s),t.assign(vn,r);const n=this.sheenNode?Ar(this.sheenNode):To,i=this.sheenRoughnessNode?Nr(this.sheenRoughnessNode):_o;t.assign(Tn,n),t.assign(_n,i)}constructNormal(e){super.constructNormal(e);const t=this.clearcoatNormalNode?Ar(this.clearcoatNormalNode):fa;e.stack.assign($o,t)}copy(e){return this.clearcoatNode=e.clearcoatNode,this.clearcoatRoughnessNode=e.clearcoatRoughnessNode,this.clearcoatNormalNode=e.clearcoatNormalNode,this.sheenNode=e.sheenNode,this.sheenRoughnessNode=e.sheenRoughnessNode,this.iridescenceNode=e.iridescenceNode,this.iridescenceIORNode=e.iridescenceIORNode,this.iridescenceThicknessNode=e.iridescenceThicknessNode,this.specularIntensityNode=e.specularIntensityNode,this.specularColorNode=e.specularColorNode,this.transmissionNode=e.transmissionNode,this.thicknessNode=e.thicknessNode,this.attenuationDistanceNode=e.attenuationDistanceNode,this.attenuationColorNode=e.attenuationColorNode,super.copy(e)}});const Uc=new X;el(class PointsNodeMaterial extends NodeMaterial{constructor(e){super(),this.isPointsNodeMaterial=!0,this.lights=!1,this.normals=!1,this.transparent=!0,this.colorNode=null,this.opacityNode=null,this.alphaTestNode=null,this.lightNode=null,this.sizeNode=null,this.positionNode=null,this.setDefaultValues(Uc),this.setValues(e)}copy(e){return this.sizeNode=e.sizeNode,super.copy(e)}});const Oc=new Y;el(class SpriteNodeMaterial extends NodeMaterial{constructor(e){super(),this.isSpriteNodeMaterial=!0,this.lights=!1,this.normals=!1,this.colorNode=null,this.opacityNode=null,this.alphaTestNode=null,this.lightNode=null,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.setDefaultValues(Oc),this.setValues(e)}constructPosition({object:e,context:t}){const{positionNode:s,rotationNode:r,scaleNode:n}=this,i=ra;let o=Oo.mul(Ar(s||0)),a=_r(Fo[0].xyz.length(),Fo[1].xyz.length());null!==n&&(a=a.mul(n));let l=i.xy;e.center&&!0===e.center.isVector2&&(l=l.sub(qr(e.center).sub(.5))),l=l.mul(a);const u=r||vo,c=u.cos(),d=u.sin(),h=_r(_r(c,d.negate()).dot(l),_r(d,c).dot(l));o=Br(o.xy.add(h),o.zw);const p=Ro.mul(o);return t.vertex=i,p}copy(e){return this.positionNode=e.positionNode,this.rotationNode=e.rotationNode,this.scaleNode=e.scaleNode,super.copy(e)}});const Ic=Z.createMaterialFromType;Z.createMaterialFromType=function(e){const t=tl(e);return void 0!==t?t:Ic.call(this,e)};class Fc{parseFunction(){}}class Lc{constructor(e,t,s="",r=""){this.type=e,this.inputs=t,this.name=s,this.presicion=r}getCode(){}}function Dc(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function Gc(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}Lc.isNodeFunction=!0,Bu('float mx_select(bool b, float t, float f)\n{\n    return b ? t : f;\n}\n\nfloat mx_negate_if(float val, bool b)\n{\n    return b ? -val : val;\n}\n\nint mx_floor(float x)\n{\n    return int(floor(x));\n}\n\n// return mx_floor as well as the fractional remainder\nfloat mx_floorfrac(float x, out int i)\n{\n    i = mx_floor(x);\n    return x - float(i);\n}\n\nfloat mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)\n{\n    float s1 = 1.0 - s;\n    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);\n}\nvec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)\n{\n    float s1 = 1.0 - s;\n    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);\n}\nfloat mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)\n{\n    float s1 = 1.0 - s;\n    float t1 = 1.0 - t;\n    float r1 = 1.0 - r;\n    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +\n            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));\n}\nvec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)\n{\n    float s1 = 1.0 - s;\n    float t1 = 1.0 - t;\n    float r1 = 1.0 - r;\n    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +\n            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));\n}\n\n// 2 and 3 dimensional gradient functions - perform a dot product against a\n// randomly chosen vector. Note that the gradient vector is not normalized, but\n// this only affects the overal "scale" of the result, so we simply account for\n// the scale by multiplying in the corresponding "perlin" function.\nfloat mx_gradient_float(uint hash, float x, float y)\n{\n    // 8 possible directions (+-1,+-2) and (+-2,+-1)\n    uint h = hash & 7u;\n    float u = mx_select(h<4u, x, y);\n    float v = 2.0 * mx_select(h<4u, y, x);\n    // compute the dot product with (x,y).\n    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));\n}\nfloat mx_gradient_float(uint hash, float x, float y, float z)\n{\n    // use vectors pointing to the edges of the cube\n    uint h = hash & 15u;\n    float u = mx_select(h<8u, x, y);\n    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));\n    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));\n}\nvec3 mx_gradient_vec3(uvec3 hash, float x, float y)\n{\n    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));\n}\nvec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)\n{\n    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));\n}\n// Scaling factors to normalize the result of gradients above.\n// These factors were experimentally calculated to be:\n//    2D:   0.6616\n//    3D:   0.9820\nfloat mx_gradient_scale2d(float v) { return 0.6616 * v; }\nfloat mx_gradient_scale3d(float v) { return 0.9820 * v; }\nvec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }\nvec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }\n\n/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)\nuint mx_rotl32(uint x, int k)\n{\n    return (x<<k) | (x>>(32-k));\n}\n\nvoid mx_bjmix(inout uint a, inout uint b, inout uint c)\n{\n    a -= c; a ^= mx_rotl32(c, 4); c += b;\n    b -= a; b ^= mx_rotl32(a, 6); a += c;\n    c -= b; c ^= mx_rotl32(b, 8); b += a;\n    a -= c; a ^= mx_rotl32(c,16); c += b;\n    b -= a; b ^= mx_rotl32(a,19); a += c;\n    c -= b; c ^= mx_rotl32(b, 4); b += a;\n}\n\n// Mix up and combine the bits of a, b, and c (doesn\'t change them, but\n// returns a hash of those three original values).\nuint mx_bjfinal(uint a, uint b, uint c)\n{\n    c ^= b; c -= mx_rotl32(b,14);\n    a ^= c; a -= mx_rotl32(c,11);\n    b ^= a; b -= mx_rotl32(a,25);\n    c ^= b; c -= mx_rotl32(b,16);\n    a ^= c; a -= mx_rotl32(c,4);\n    b ^= a; b -= mx_rotl32(a,14);\n    c ^= b; c -= mx_rotl32(b,24);\n    return c;\n}\n\n// Convert a 32 bit integer into a floating point number in [0,1]\nfloat mx_bits_to_01(uint bits)\n{\n    return float(bits) / float(uint(0xffffffff));\n}\n\nfloat mx_fade(float t)\n{\n   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nuint mx_hash_int(int x)\n{\n    uint len = 1u;\n    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;\n    return mx_bjfinal(seed+uint(x), seed, seed);\n}\n\nuint mx_hash_int(int x, int y)\n{\n    uint len = 2u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z)\n{\n    uint len = 3u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z, int xx)\n{\n    uint len = 4u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    mx_bjmix(a, b, c);\n    a += uint(xx);\n    return mx_bjfinal(a, b, c);\n}\n\nuint mx_hash_int(int x, int y, int z, int xx, int yy)\n{\n    uint len = 5u;\n    uint a, b, c;\n    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;\n    a += uint(x);\n    b += uint(y);\n    c += uint(z);\n    mx_bjmix(a, b, c);\n    a += uint(xx);\n    b += uint(yy);\n    return mx_bjfinal(a, b, c);\n}\n\nuvec3 mx_hash_vec3(int x, int y)\n{\n    uint h = mx_hash_int(x, y);\n    // we only need the low-order bits to be random, so split out\n    // the 32 bit result into 3 parts for each channel\n    uvec3 result;\n    result.x = (h      ) & 0xFFu;\n    result.y = (h >> 8 ) & 0xFFu;\n    result.z = (h >> 16) & 0xFFu;\n    return result;\n}\n\nuvec3 mx_hash_vec3(int x, int y, int z)\n{\n    uint h = mx_hash_int(x, y, z);\n    // we only need the low-order bits to be random, so split out\n    // the 32 bit result into 3 parts for each channel\n    uvec3 result;\n    result.x = (h      ) & 0xFFu;\n    result.y = (h >> 8 ) & 0xFFu;\n    result.z = (h >> 16) & 0xFFu;\n    return result;\n}\n\nfloat mx_perlin_noise_float(vec2 p)\n{\n    int X, Y;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float result = mx_bilerp(\n        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),\n        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),\n        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),\n        u, v);\n    return mx_gradient_scale2d(result);\n}\n\nfloat mx_perlin_noise_float(vec3 p)\n{\n    int X, Y, Z;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float fz = mx_floorfrac(p.z, Z);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float w = mx_fade(fz);\n    float result = mx_trilerp(\n        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),\n        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),\n        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),\n        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),\n        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),\n        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),\n        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),\n        u, v, w);\n    return mx_gradient_scale3d(result);\n}\n\nvec3 mx_perlin_noise_vec3(vec2 p)\n{\n    int X, Y;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    vec3 result = mx_bilerp(\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),\n        u, v);\n    return mx_gradient_scale2d(result);\n}\n\nvec3 mx_perlin_noise_vec3(vec3 p)\n{\n    int X, Y, Z;\n    float fx = mx_floorfrac(p.x, X);\n    float fy = mx_floorfrac(p.y, Y);\n    float fz = mx_floorfrac(p.z, Z);\n    float u = mx_fade(fx);\n    float v = mx_fade(fy);\n    float w = mx_fade(fz);\n    vec3 result = mx_trilerp(\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),\n        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),\n        u, v, w);\n    return mx_gradient_scale3d(result);\n}\n\nfloat mx_cell_noise_float(float p)\n{\n    int ix = mx_floor(p);\n    return mx_bits_to_01(mx_hash_int(ix));\n}\n\nfloat mx_cell_noise_float(vec2 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    return mx_bits_to_01(mx_hash_int(ix, iy));\n}\n\nfloat mx_cell_noise_float(vec3 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    return mx_bits_to_01(mx_hash_int(ix, iy, iz));\n}\n\nfloat mx_cell_noise_float(vec4 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    int iw = mx_floor(p.w);\n    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));\n}\n\nvec3 mx_cell_noise_vec3(float p)\n{\n    int ix = mx_floor(p);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, 0)),\n            mx_bits_to_01(mx_hash_int(ix, 1)),\n            mx_bits_to_01(mx_hash_int(ix, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec2 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec3 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))\n    );\n}\n\nvec3 mx_cell_noise_vec3(vec4 p)\n{\n    int ix = mx_floor(p.x);\n    int iy = mx_floor(p.y);\n    int iz = mx_floor(p.z);\n    int iw = mx_floor(p.w);\n    return vec3(\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),\n            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))\n    );\n}\n\nfloat mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    float result = 0.0;\n    float amplitude = 1.0;\n    for (int i = 0;  i < octaves; ++i)\n    {\n        result += amplitude * mx_perlin_noise_float(p);\n        amplitude *= diminish;\n        p *= lacunarity;\n    }\n    return result;\n}\n\nvec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    vec3 result = vec3(0.0);\n    float amplitude = 1.0;\n    for (int i = 0;  i < octaves; ++i)\n    {\n        result += amplitude * mx_perlin_noise_vec3(p);\n        amplitude *= diminish;\n        p *= lacunarity;\n    }\n    return result;\n}\n\nvec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),\n                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));\n}\n\nvec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)\n{\n    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);\n    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);\n    return vec4(c, f);\n}\n\nfloat mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)\n{\n    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));\n    vec2  off = vec2(tmp.x, tmp.y);\n\n    off -= 0.5f;\n    off *= jitter;\n    off += 0.5f;\n\n    vec2 cellpos = vec2(float(x), float(y)) + off;\n    vec2 diff = cellpos - p;\n    if (metric == 2)\n        return abs(diff.x) + abs(diff.y);       // Manhattan distance\n    if (metric == 3)\n        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance\n    // Either Euclidian or Distance^2\n    return dot(diff, diff);\n}\n\nfloat mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)\n{\n    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));\n\n    off -= 0.5f;\n    off *= jitter;\n    off += 0.5f;\n\n    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;\n    vec3 diff = cellpos - p;\n    if (metric == 2)\n        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance\n    if (metric == 3)\n        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance\n    // Either Euclidian or Distance^2\n    return dot(diff, diff);\n}\n\nfloat mx_worley_noise_float(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            sqdist = min(sqdist, dist);\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    vec2 sqdist = vec2(1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            if (dist < sqdist.x)\n            {\n                sqdist.y = sqdist.x;\n                sqdist.x = dist;\n            }\n            else if (dist < sqdist.y)\n            {\n                sqdist.y = dist;\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)\n{\n    int X, Y;\n    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));\n    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);\n            if (dist < sqdist.x)\n            {\n                sqdist.z = sqdist.y;\n                sqdist.y = sqdist.x;\n                sqdist.x = dist;\n            }\n            else if (dist < sqdist.y)\n            {\n                sqdist.z = sqdist.y;\n                sqdist.y = dist;\n            }\n            else if (dist < sqdist.z)\n            {\n                sqdist.z = dist;\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nfloat mx_worley_noise_float(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    float sqdist = 1e6f;\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                sqdist = min(sqdist, dist);\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    vec2 sqdist = vec2(1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                if (dist < sqdist.x)\n                {\n                    sqdist.y = sqdist.x;\n                    sqdist.x = dist;\n                }\n                else if (dist < sqdist.y)\n                {\n                    sqdist.y = dist;\n                }\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}\n\nvec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)\n{\n    int X, Y, Z;\n    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));\n    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            for (int z = -1; z <= 1; ++z)\n            {\n                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);\n                if (dist < sqdist.x)\n                {\n                    sqdist.z = sqdist.y;\n                    sqdist.y = sqdist.x;\n                    sqdist.x = dist;\n                }\n                else if (dist < sqdist.y)\n                {\n                    sqdist.z = sqdist.y;\n                    sqdist.y = dist;\n                }\n                else if (dist < sqdist.z)\n                {\n                    sqdist.z = dist;\n                }\n            }\n        }\n    }\n    if (metric == 0)\n        sqdist = sqrt(sqdist);\n    return sqdist;\n}'),Bu("#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)\n\nvec3 mx_srgb_texture_to_lin_rec709(vec3 color)\n{\n    bvec3 isAbove = greaterThan(color, vec3(0.04045));\n    vec3 linSeg = color / 12.92;\n    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));\n    return mix(linSeg, powSeg, isAbove);\n}");class kc{constructor(){this.renderItems=[],this.renderItemsIndex=0,this.opaque=[],this.transparent=[],this.lightsNode=(e=>dr((new LightsNode).fromLights(e)))([]),this.lightsArray=[]}init(){return this.renderItemsIndex=0,this.opaque.length=0,this.transparent.length=0,this.lightsArray.length=0,this}getNextRenderItem(e,t,s,r,n,i){let o=this.renderItems[this.renderItemsIndex];return void 0===o?(o={id:e.id,object:e,geometry:t,material:s,groupOrder:r,renderOrder:e.renderOrder,z:n,group:i},this.renderItems[this.renderItemsIndex]=o):(o.id=e.id,o.object=e,o.geometry=t,o.material=s,o.groupOrder=r,o.renderOrder=e.renderOrder,o.z=n,o.group=i),this.renderItemsIndex++,o}push(e,t,s,r,n,i){const o=this.getNextRenderItem(e,t,s,r,n,i);(!0===s.transparent?this.transparent:this.opaque).push(o)}unshift(e,t,s,r,n,i){const o=this.getNextRenderItem(e,t,s,r,n,i);(!0===s.transparent?this.transparent:this.opaque).unshift(o)}pushLight(e){this.lightsArray.push(e)}getLightsNode(){return this.lightsNode.fromLights(this.lightsArray)}sort(e,t){this.opaque.length>1&&this.opaque.sort(e||Dc),this.transparent.length>1&&this.transparent.sort(t||Gc)}finish(){this.lightsNode.fromLights(this.lightsArray);for(let e=this.renderItemsIndex,t=this.renderItems.length;e<t;e++){const t=this.renderItems[e];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.program=null,t.group=null}}}class zc{constructor(){this.lists=new Kt}get(e,t){const s=this.lists,r=[e,t];let n=s.get(r);return void 0===n&&(n=new kc,s.set(r,n)),n}dispose(){this.lists=new Kt}}let Pc=0;class Vc{constructor(){this.id=Pc++,this.color=!0,this.clearColor=!0,this.clearColorValue={r:0,g:0,b:0,a:1},this.depth=!0,this.clearDepth=!0,this.clearDepthValue=1,this.stencil=!0,this.clearStencil=!0,this.clearStencilValue=1,this.viewport=!1,this.viewportValue=new o,this.scissor=!1,this.scissorValue=new o,this.texture=null,this.depthTexture=null,this.activeCubeFace=0}}class $c{constructor(){this.renderStates=new Kt}get(e,t){const s=[e,t];let r=this.renderStates.get(s);return void 0===r&&(r=new Vc,this.renderStates.set(s,r)),r}dispose(){this.renderStates=new Kt}}const qc=new n;class jc extends Zt{constructor(e,t){super(),this.backend=e,this.info=t}updateRenderTarget(e){const t=this.get(e),s=e.texture,r=this.getSize(s);let n=e.depthTexture||t.depthTexture;if(void 0===n&&(n=new b,n.format=K,n.type=J,n.image.width=r.width,n.image.height=r.height),t.width===r.width&&r.height===t.height||(s.needsUpdate=!0,n.needsUpdate=!0,n.image.width=r.width,n.image.height=r.height),t.width=r.width,t.height=r.height,t.texture=s,t.depthTexture=n,this.updateTexture(s),this.updateTexture(n),!0!==t.initialized){t.initialized=!0;const r=()=>{e.removeEventListener("dispose",r),this._destroyTexture(s),this._destroyTexture(n)};e.addEventListener("dispose",r)}}updateTexture(e){const t=this.get(e);if(!0===t.initialized&&t.version===e.version)return;const s=e.isRenderTargetTexture||e.isDepthTexture||e.isFramebufferTexture,r=this.backend;if(s&&!0===t.initialized&&(r.destroySampler(e),r.destroyTexture(e)),s)r.createSampler(e),r.createTexture(e);else{if(!0!==t.initialized&&r.createSampler(e),e.version>0){const s=e.image;void 0===s||!1===s.complete||(void 0!==t.isDefaultTexture&&!0!==t.isDefaultTexture||(r.createTexture(e),t.isDefaultTexture=!1),r.updateTexture(e))}else r.createDefaultTexture(e),t.isDefaultTexture=!0}if(!0!==t.initialized){t.initialized=!0,this.info.memory.textures++;const s=()=>{e.removeEventListener("dispose",s),this._destroyTexture(e),this.info.memory.textures--};e.addEventListener("dispose",s)}t.version=e.version}getSize(e,t=qc){return e.isCubeTexture?(t.width=e.image[0].width,t.height=e.image[0].height):(t.width=e.image.width,t.height=e.image.height),t}_destroyTexture(e){this.backend.destroySampler(e),this.backend.destroyTexture(e),this.delete(e)}}let Wc;const Hc=new r;class Xc extends Zt{constructor(e,t){super(),this.renderer=e,this.nodes=t,this.boxMesh=null,this.boxMeshNode=null}update(e,t,s){const r=this.renderer,n=!0===e.isScene?this.nodes.getBackgroundNode(e)||e.background:null;let i=!1;if(null===n)Hc.copyLinearToSRGB(r._clearColor),Wc=r._clearAlpha;else if(!0===n.isColor)Hc.copyLinearToSRGB(n),Wc=1,i=!0;else if(!0===n.isNode){const s=this.get(e),i=n;Hc.copy(r._clearColor),Wc=r._clearAlpha;let o=this.boxMesh;if(null===o){this.boxMeshNode=sn(i,{getUVNode:()=>ia,getSamplerLevelNode:()=>Pl});const e=new MeshBasicNodeMaterial;e.colorNode=this.boxMeshNode,e.side=Q,e.depthTest=!1,e.depthWrite=!1,e.fog=!1,this.boxMesh=o=new ee(new te(1,32,32),e),o.frustumCulled=!1,o.onBeforeRender=function(e,t,s){const r=s.far;this.matrixWorld.makeScale(r,r,r).copyPosition(s.matrixWorld)}}const a=i.getCacheKey();s.backgroundCacheKey!==a&&(this.boxMeshNode.node=i,o.material.needsUpdate=!0,s.backgroundCacheKey=a),t.unshift(o,o.geometry,o.material,0,0,null)}if(!0===r.autoClear||!0===i){Hc.multiplyScalar(Wc);const e=s.clearColorValue;e.r=Hc.r,e.g=Hc.g,e.b=Hc.b,e.a=Wc,s.depthClearValue=r._clearDepth,s.stencilClearValue=r._clearStencil,s.clearColor=!0===r.autoClearColor,s.clearDepth=!0===r.autoClearDepth,s.clearStencil=!0===r.autoClearStencil}else s.clearColor=!1,s.clearDepth=!1,s.clearStencil=!1}}class Yc extends Zt{constructor(e,t){super(),this.renderer=e,this.backend=t,this.nodeFrame=new dl}getForRender(e){const t=this.get(e);let s=t.nodeBuilder;return void 0===s&&(s=this.backend.createNodeBuilder(e.object,this.renderer,e.scene),s.material=e.material,s.lightsNode=e.lightsNode,s.environmentNode=this.getEnvironmentNode(e.scene),s.fogNode=this.getFogNode(e.scene),s.toneMappingNode=this.getToneMappingNode(),s.build(),t.nodeBuilder=s),s}getForCompute(e){const t=this.get(e);let s=t.nodeBuilder;return void 0===s&&(s=this.backend.createNodeBuilder(e,this.renderer),s.build(),t.nodeBuilder=s),s}getEnvironmentNode(e){return e.environmentNode||this.get(e).environmentNode||null}getBackgroundNode(e){return e.backgroundNode||this.get(e).backgroundNode||null}getFogNode(e){return e.fogNode||this.get(e).fogNode||null}getToneMappingNode(){return this.renderer.toneMappingNode||this.get(this.renderer).toneMappingNode||null}getCacheKey(e,t){const s=this.getEnvironmentNode(e),r=this.getFogNode(e),n=this.getToneMappingNode(),i=[];return t&&i.push("lightsNode:"+t.getCacheKey()),s&&i.push("environmentNode:"+s.getCacheKey()),r&&i.push("fogNode:"+r.getCacheKey()),n&&i.push("toneMappingNode:"+n.getCacheKey()),"{"+i.join(",")+"}"}updateScene(e){this.updateEnvironment(e),this.updateFog(e),this.updateBackground(e),this.updateToneMapping()}updateToneMapping(){const e=this.renderer,t=this.get(e),s=e.toneMapping;if(s!==A){if(t.toneMapping!==s){const r=t.rendererToneMappingNode||((e,t,s)=>dr(new ToneMappingNode(e,dr(t),dr(s))))(s,ao("toneMappingExposure","float",e));r.toneMapping=s,t.rendererToneMappingNode=r,t.toneMappingNode=r,t.toneMapping=s}}else delete t.toneMappingNode,delete t.toneMapping}updateBackground(e){const t=this.get(e),s=e.background;if(s){if(t.background!==s){let e=null;if(!0===s.isCubeTexture)e=Ia(s,Pi(na,Fo));else if(!0===s.isTexture){let t=null;t=s.mapping===se||s.mapping===re?ja():fu,e=io(s,t)}else s.isColor;t.backgroundNode=e,t.background=s}}else t.backgroundNode&&(delete t.backgroundNode,delete t.background)}updateFog(e){const t=this.get(e),s=e.fog;if(s){if(t.fog!==s){let e=null;s.isFogExp2?e=$u(ao("color","color",s),ao("density","float",s)):s.isFog&&(e=Pu(ao("color","color",s),ao("near","float",s),ao("far","float",s))),t.fogNode=e,t.fog=s}}else delete t.fogNode,delete t.fog}updateEnvironment(e){const t=this.get(e),s=e.environment;if(s){if(t.environment!==s){let e=null;!0===s.isCubeTexture?e=Ia(s):!0===s.isTexture&&(e=io(s)),t.environmentNode=e,t.environment=s}}else t.environmentNode&&(delete t.environmentNode,delete t.environment)}getNodeFrame(e){const t=this.nodeFrame;return t.scene=e.scene,t.object=e.object,t.camera=e.camera,t.renderer=e.renderer,t.material=e.material,t}updateBefore(e){const t=this.getNodeFrame(e),s=this.getForRender(e);for(const e of s.updateBeforeNodes)t.updateBeforeNode(e)}updateForCompute(){}updateForRender(e){const t=this.getNodeFrame(e),s=this.getForRender(e);for(const e of s.updateNodes)t.updateNode(e)}dispose(){super.dispose(),this.nodeFrame=new dl}}const Zc=new n,Kc=new o,Jc=new ne,Qc=new l,ed=new i;class td{constructor(e){this.isRenderer=!0,this.domElement=e.getDomElement(),this.backend=e,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.outputColorSpace=d,this.toneMapping=A,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=!0,this.stencil=!0,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new o(0,0,this._width,this._height),this._scissor=new o(0,0,this._width,this._height),this._scissorTest=!1,this._info=null,this._properties=null,this._attributes=null,this._geometries=null,this._nodes=null,this._bindings=null,this._objects=null,this._pipelines=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._animation=new Yt,this._currentRenderContext=null,this._lastRenderContext=null,this._opaqueSort=null,this._transparentSort=null,this._clearAlpha=1,this._clearColor=new r(0),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._currentActiveCubeFace=0,this._initialized=!1,this._initPromise=null,this.shadowMap={enabled:!1,type:null},this.xr={enabled:!1}}async init(){if(this._initialized)throw new Error("Renderer: Backend has already been initialized.");return null!==this._initPromise||(this._initPromise=new Promise((async(e,t)=>{const s=this.backend;try{await s.init(this)}catch(e){return void t(e)}this._info=new us,this._nodes=new Yc(this,s),this._attributes=new is(s),this._background=new Xc(this,this._nodes),this._geometries=new ls(this._attributes,this._info),this._textures=new jc(s,this._info),this._pipelines=new gs(s,this._nodes),this._bindings=new fs(s,this._nodes,this._textures,this._attributes,this._pipelines,this._info),this._objects=new es(this,this._nodes,this._geometries,this._pipelines,this._info),this._renderLists=new zc,this._renderContexts=new $c,this._animation.setNodes(this._nodes),this._animation.start(),this._initialized=!0,e()}))),this._initPromise}get coordinateSystem(){return this.backend.coordinateSystem}async compile(){}async render(e,t){!1===this._initialized&&await this.init();const s=this._nodes.nodeFrame,r=s.renderId,n=this._currentRenderContext,i=this._renderContexts.get(e,t),o=this._renderTarget,a=this._activeCubeFace;this._currentRenderContext=i,s.renderId++;const l=this.coordinateSystem;t.coordinateSystem!==l&&(t.coordinateSystem=l,t.updateProjectionMatrix()),!1===this._animation.isAnimating&&s.update(),!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),null===t.parent&&!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),!0===this._info.autoReset&&this._info.reset(),this._info.render.frame++;let u=this._viewport,c=this._scissor,d=this._pixelRatio;null!==o&&(u=o.viewport,c=o.scissor,d=1),this.getDrawingBufferSize(Zc),Kc.set(0,0,Zc.width,Zc.height);const h=void 0===u.minDepth?0:u.minDepth,p=void 0===u.maxDepth?1:u.maxDepth;i.viewportValue.copy(u).multiplyScalar(d).floor(),i.viewportValue.minDepth=h,i.viewportValue.maxDepth=p,i.viewport=!1===i.viewportValue.equals(Kc),i.scissorValue.copy(c).multiplyScalar(d).floor(),i.scissor=this._scissorTest&&!1===i.scissorValue.equals(Kc),i.depth=this.depth,i.stencil=this.stencil,Qc.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),Jc.setFromProjectionMatrix(Qc,l);const m=this._renderLists.get(e,t);if(m.init(),this._projectObject(e,t,0,m),m.finish(),!0===this.sortObjects&&m.sort(this._opaqueSort,this._transparentSort),null!==o){this._textures.updateRenderTarget(o);const e=this._textures.get(o);i.texture=e.texture,i.depthTexture=e.depthTexture}else i.texture=null,i.depthTexture=null;i.activeCubeFace=a,this._nodes.updateScene(e),this._background.update(e,m,i),this.backend.beginRender(i);const g=m.opaque,f=m.transparent,x=m.lightsNode;g.length>0&&this._renderObjects(g,t,e,x),f.length>0&&this._renderObjects(f,t,e,x),this.backend.finishRender(i),s.renderId=r,this._currentRenderContext=n,this._lastRenderContext=i}setAnimationLoop(e){!1===this._initialized&&this.init();const t=this._animation;t.setAnimationLoop(e),null===e?t.stop():t.start()}async getArrayBuffer(e){return await this.backend.getArrayBuffer(e)}getContext(){return this._context}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(e){return e.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(e){return e.set(this._width,this._height)}setPixelRatio(e=1){this._pixelRatio=e,this.setSize(this._width,this._height,!1)}setDrawingBufferSize(e,t,s){this._width=e,this._height=t,this._pixelRatio=s,this.domElement.width=Math.floor(e*s),this.domElement.height=Math.floor(t*s),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize()}setSize(e,t,s=!0){this._width=e,this._height=t,this.domElement.width=Math.floor(e*this._pixelRatio),this.domElement.height=Math.floor(t*this._pixelRatio),!0===s&&(this.domElement.style.width=e+"px",this.domElement.style.height=t+"px"),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize()}setOpaqueSort(e){this._opaqueSort=e}setTransparentSort(e){this._transparentSort=e}getScissor(e){const t=this._scissor;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e}setScissor(e,t,s,r){const n=this._scissor;e.isVector4?n.copy(e):n.set(e,t,s,r)}getScissorTest(){return this._scissorTest}setScissorTest(e){this._scissorTest=e}getViewport(e){return e.copy(this._viewport)}setViewport(e,t,s,r,n=0,i=1){const o=this._viewport;e.isVector4?o.copy(e):o.set(e,t,s,r),o.minDepth=n,o.maxDepth=i}getClearColor(e){return e.copy(this._clearColor)}setClearColor(e,t=1){this._clearColor.set(e),this._clearAlpha=t}getClearAlpha(){return this._clearAlpha}setClearAlpha(e){this._clearAlpha=e}getClearDepth(){return this._clearDepth}setClearDepth(e){this._clearDepth=e}getClearStencil(){return this._clearStencil}setClearStencil(e){this._clearStencil=e}clear(e=!0,t=!0,s=!0){const r=this._currentRenderContext||this._lastRenderContext;r&&this.backend.clear(r,e,t,s)}clearColor(){this.clear(!0,!1,!1)}clearDepth(){this.clear(!1,!0,!1)}clearStencil(){this.clear(!1,!1,!0)}dispose(){this._objects.dispose(),this._properties.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._info.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(e,t=0){this._renderTarget=e,this._activeCubeFace=t}async compute(e){!1===this._initialized&&await this.init();const t=this.backend,s=this._pipelines,r=Array.isArray(e)?e:[e];t.beginCompute(r);for(const e of r){!1===s.has(e)&&e.onInit({renderer:this}),this._nodes.updateForCompute(e),this._bindings.updateForCompute(e);const n=s.getForCompute(e),i=this._bindings.getForCompute(e);t.compute(r,e,i,n)}t.finishCompute(r)}getRenderTarget(){return this._renderTarget}hasFeature(e){return this.backend.hasFeature(e)}copyFramebufferToTexture(e){const t=this._currentRenderContext||this._lastRenderContext;this._textures.updateTexture(e),this.backend.copyFramebufferToTexture(e,t)}readRenderTargetPixelsAsync(e,t,s,r,n){return this.backend.copyTextureToBuffer(e.texture,t,s,r,n)}_projectObject(e,t,s,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)s=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)r.pushLight(e);else if(e.isSprite){if(!e.frustumCulled||Jc.intersectsSprite(e)){!0===this.sortObjects&&ed.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Qc);const t=e.geometry,n=e.material;n.visible&&r.push(e,t,n,s,ed.z,null)}}else if(e.isLineLoop);else if((e.isMesh||e.isLine||e.isPoints)&&(!e.frustumCulled||Jc.intersectsObject(e))){const t=e.geometry,n=e.material;if(!0===this.sortObjects&&(null===t.boundingSphere&&t.computeBoundingSphere(),ed.copy(t.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(Qc)),Array.isArray(n)){const i=t.groups;for(let o=0,a=i.length;o<a;o++){const a=i[o],l=n[a.materialIndex];l&&l.visible&&r.push(e,t,l,s,ed.z,a)}}else n.visible&&r.push(e,t,n,s,ed.z,null)}const n=e.children;for(let e=0,i=n.length;e<i;e++)this._projectObject(n[e],t,s,r)}_renderObjects(e,t,s,r){for(let n=0,i=e.length;n<i;n++){const i=e[n],{object:o,geometry:a,material:l,group:u}=i;if(t.isArrayCamera){const e=t.cameras;for(let t=0,n=e.length;t<n;t++){const n=e[t];if(o.layers.test(n.layers)){const e=n.viewport,t=void 0===e.minDepth?0:e.minDepth,i=void 0===e.maxDepth?1:e.maxDepth,c=this._currentRenderContext.viewportValue;c.copy(e).multiplyScalar(this._pixelRatio).floor(),c.minDepth=t,c.maxDepth=i,this.backend.updateViewport(this._currentRenderContext),this._renderObject(o,s,n,a,l,u,r)}}}else this._renderObject(o,s,t,a,l,u,r)}}_renderObject(e,t,s,r,n,i,o){n=null!==t.overrideMaterial?t.overrideMaterial:n,e.onBeforeRender(this,t,s,r,n,i),e.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),n.onBeforeRender(this,t,s,r,n,i),!0===n.transparent&&n.side===ie&&!1===n.forceSinglePass?(n.side=Q,this._renderObjectDirect(e,t,s,r,n,i,o,"backSide"),n.side=oe,this._renderObjectDirect(e,t,s,r,n,i,o),n.side=ie):this._renderObjectDirect(e,t,s,r,n,i,o),e.onAfterRender(this,t,s,r,n,i)}_renderObjectDirect(e,t,s,r,n,i,o,a){const l=this._objects.get(e,n,t,s,o,a);l.context=this._currentRenderContext,this._nodes.updateBefore(l),this._nodes.updateForRender(l),this._geometries.update(l),this._bindings.updateForRender(l),this.backend.draw(l,this._info)}}const sd="point-list",rd="line-list",nd="line-strip",id="triangle-list",od="triangle-strip",ad="never",ld="less",ud="equal",cd="less-equal",dd="greater",hd="not-equal",pd="greater-equal",md="always",gd="store",fd="load",xd="clear",bd="cw",Nd="none",yd="front",vd="back",Td="uint16",_d="uint32",Sd={R8Unorm:"r8unorm",R8Snorm:"r8snorm",R8Uint:"r8uint",R8Sint:"r8sint",R16Uint:"r16uint",R16Sint:"r16sint",R16Float:"r16float",RG8Unorm:"rg8unorm",RG8Snorm:"rg8snorm",RG8Uint:"rg8uint",RG8Sint:"rg8sint",R32Uint:"r32uint",R32Sint:"r32sint",R32Float:"r32float",RG16Uint:"rg16uint",RG16Sint:"rg16sint",RG16Float:"rg16float",RGBA8Unorm:"rgba8unorm",RGBA8UnormSRGB:"rgba8unorm-srgb",RGBA8Snorm:"rgba8snorm",RGBA8Uint:"rgba8uint",RGBA8Sint:"rgba8sint",BGRA8Unorm:"bgra8unorm",BGRA8UnormSRGB:"bgra8unorm-srgb",RGB9E5UFloat:"rgb9e5ufloat",RGB10A2Unorm:"rgb10a2unorm",RG11B10uFloat:"rgb10a2unorm",RG32Uint:"rg32uint",RG32Sint:"rg32sint",RG32Float:"rg32float",RGBA16Uint:"rgba16uint",RGBA16Sint:"rgba16sint",RGBA16Float:"rgba16float",RGBA32Uint:"rgba32uint",RGBA32Sint:"rgba32sint",RGBA32Float:"rgba32float",Stencil8:"stencil8",Depth16Unorm:"depth16unorm",Depth24Plus:"depth24plus",Depth24PlusStencil8:"depth24plus-stencil8",Depth32Float:"depth32float",Depth32FloatStencil8:"depth32float-stencil8",BC1RGBAUnorm:"bc1-rgba-unorm",BC1RGBAUnormSRGB:"bc1-rgba-unorm-srgb",BC2RGBAUnorm:"bc2-rgba-unorm",BC2RGBAUnormSRGB:"bc2-rgba-unorm-srgb",BC3RGBAUnorm:"bc3-rgba-unorm",BC3RGBAUnormSRGB:"bc3-rgba-unorm-srgb",BC4RUnorm:"bc4-r-unorm",BC4RSnorm:"bc4-r-snorm",BC5RGUnorm:"bc5-rg-unorm",BC5RGSnorm:"bc5-rg-snorm",BC6HRGBUFloat:"bc6h-rgb-ufloat",BC6HRGBFloat:"bc6h-rgb-float",BC7RGBAUnorm:"bc7-rgba-unorm",BC7RGBAUnormSRGB:"bc7-rgba-srgb",ETC2RGB8Unorm:"etc2-rgb8unorm",ETC2RGB8UnormSRGB:"etc2-rgb8unorm-srgb",ETC2RGB8A1Unorm:"etc2-rgb8a1unorm",ETC2RGB8A1UnormSRGB:"etc2-rgb8a1unorm-srgb",ETC2RGBA8Unorm:"etc2-rgba8unorm",ETC2RGBA8UnormSRGB:"etc2-rgba8unorm-srgb",EACR11Unorm:"eac-r11unorm",EACR11Snorm:"eac-r11snorm",EACRG11Unorm:"eac-rg11unorm",EACRG11Snorm:"eac-rg11snorm",ASTC4x4Unorm:"astc-4x4-unorm",ASTC4x4UnormSRGB:"astc-4x4-unorm-srgb",ASTC5x4Unorm:"astc-5x4-unorm",ASTC5x4UnormSRGB:"astc-5x4-unorm-srgb",ASTC5x5Unorm:"astc-5x5-unorm",ASTC5x5UnormSRGB:"astc-5x5-unorm-srgb",ASTC6x5Unorm:"astc-6x5-unorm",ASTC6x5UnormSRGB:"astc-6x5-unorm-srgb",ASTC6x6Unorm:"astc-6x6-unorm",ASTC6x6UnormSRGB:"astc-6x6-unorm-srgb",ASTC8x5Unorm:"astc-8x5-unorm",ASTC8x5UnormSRGB:"astc-8x5-unorm-srgb",ASTC8x6Unorm:"astc-8x6-unorm",ASTC8x6UnormSRGB:"astc-8x6-unorm-srgb",ASTC8x8Unorm:"astc-8x8-unorm",ASTC8x8UnormSRGB:"astc-8x8-unorm-srgb",ASTC10x5Unorm:"astc-10x5-unorm",ASTC10x5UnormSRGB:"astc-10x5-unorm-srgb",ASTC10x6Unorm:"astc-10x6-unorm",ASTC10x6UnormSRGB:"astc-10x6-unorm-srgb",ASTC10x8Unorm:"astc-10x8-unorm",ASTC10x8UnormSRGB:"astc-10x8-unorm-srgb",ASTC10x10Unorm:"astc-10x10-unorm",ASTC10x10UnormSRGB:"astc-10x10-unorm-srgb",ASTC12x10Unorm:"astc-12x10-unorm",ASTC12x10UnormSRGB:"astc-12x10-unorm-srgb",ASTC12x12Unorm:"astc-12x12-unorm",ASTC12x12UnormSRGB:"astc-12x12-unorm-srgb"},wd="clamp-to-edge",Cd="repeat",Ad="mirror-repeat",Rd="linear",Md="nearest",Ed="zero",Bd="one",Ud="src-color",Od="one-minus-src-color",Id="src-alpha",Fd="one-minus-src-alpha",Ld="dst-color",Dd="one-minus-dst-color",Gd="dst-alpha",kd="one-minus-dst-alpha",zd="src-alpha-saturated",Pd="blend-color",Vd="one-minus-blend-color",$d="add",qd="subtract",jd="reverse-subtract",Wd="min",Hd="max",Xd=0,Yd=15,Zd="keep",Kd="zero",Jd="replace",Qd="invert",eh="increment-clamp",th="decrement-clamp",sh="increment-wrap",rh="decrement-wrap",nh="2d",ih="3d",oh="2d",ah="cube",lh="all",uh="vertex",ch="instance",dh={DepthClipControl:"depth-clip-control",Depth32FloatStencil8:"depth32float-stencil8",TextureCompressionBC:"texture-compression-bc",TextureCompressionETC2:"texture-compression-etc2",TextureCompressionASTC:"texture-compression-astc",TimestampQuery:"timestamp-query",IndirectFirstInstance:"indirect-first-instance",ShaderF16:"shader-f16",RG11B10UFloat:"rg11b10ufloat-renderable",BGRA8UNormStorage:"bgra8unorm-storage",Float32Filterable:"float32-filterable"};class hh{constructor(e=""){this.name=e}}function ph(e){return e+(ns-e%ns)%ns}function mh(e,t=4){return ph(gh(t)*e)}function gh(e){return e+(4-e%4)%4}class fh extends hh{constructor(e,t=null){super(e),this.isBuffer=!0,this.bytesPerElement=Float32Array.BYTES_PER_ELEMENT,this._buffer=t}get byteLength(){return ph(this._buffer.byteLength)}get buffer(){return this._buffer}update(){return!0}}class xh extends fh{constructor(e,t=null){super(e,t),this.isUniformBuffer=!0}}class bh extends xh{constructor(e){super(e),this.isUniformsGroup=!0,this.uniforms=[]}addUniform(e){return this.uniforms.push(e),this}removeUniform(e){const t=this.uniforms.indexOf(e);return-1!==t&&this.uniforms.splice(t,1),this}get buffer(){let e=this._buffer;if(null===e){const t=this.byteLength;e=new Float32Array(new ArrayBuffer(t)),this._buffer=e}return e}get byteLength(){let e=0;for(let t=0,s=this.uniforms.length;t<s;t++){const s=this.uniforms[t],r=e%ns;0!==r&&ns-r-s.boundary<0?e+=ns-r:r%s.boundary!=0&&(e+=r%s.boundary),s.offset=e/this.bytesPerElement,e+=s.itemSize*this.bytesPerElement}return Math.ceil(e/ns)*ns}update(){let e=!1;for(const t of this.uniforms)!0===this.updateByType(t)&&(e=!0);return e}updateByType(e){return e.isFloatUniform?this.updateNumber(e):e.isVector2Uniform?this.updateVector2(e):e.isVector3Uniform?this.updateVector3(e):e.isVector4Uniform?this.updateVector4(e):e.isColorUniform?this.updateColor(e):e.isMatrix3Uniform?this.updateMatrix3(e):e.isMatrix4Uniform?this.updateMatrix4(e):void 0}updateNumber(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return s[n]!==r&&(s[n]=r,t=!0),t}updateVector2(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return s[n+0]===r.x&&s[n+1]===r.y||(s[n+0]=r.x,s[n+1]=r.y,t=!0),t}updateVector3(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return s[n+0]===r.x&&s[n+1]===r.y&&s[n+2]===r.z||(s[n+0]=r.x,s[n+1]=r.y,s[n+2]=r.z,t=!0),t}updateVector4(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return s[n+0]===r.x&&s[n+1]===r.y&&s[n+2]===r.z&&s[n+4]===r.w||(s[n+0]=r.x,s[n+1]=r.y,s[n+2]=r.z,s[n+3]=r.w,t=!0),t}updateColor(e){let t=!1;const s=this.buffer,r=e.getValue(),n=e.offset;return s[n+0]===r.r&&s[n+1]===r.g&&s[n+2]===r.b||(s[n+0]=r.r,s[n+1]=r.g,s[n+2]=r.b,t=!0),t}updateMatrix3(e){let t=!1;const s=this.buffer,r=e.getValue().elements,n=e.offset;return s[n+0]===r[0]&&s[n+1]===r[1]&&s[n+2]===r[2]&&s[n+4]===r[3]&&s[n+5]===r[4]&&s[n+6]===r[5]&&s[n+8]===r[6]&&s[n+9]===r[7]&&s[n+10]===r[8]||(s[n+0]=r[0],s[n+1]=r[1],s[n+2]=r[2],s[n+4]=r[3],s[n+5]=r[4],s[n+6]=r[5],s[n+8]=r[6],s[n+9]=r[7],s[n+10]=r[8],t=!0),t}updateMatrix4(e){let t=!1;const s=this.buffer,r=e.getValue().elements,n=e.offset;return!1===function(e,t,s){for(let r=0,n=t.length;r<n;r++)if(e[s+r]!==t[r])return!1;return!0}(s,r,n)&&(s.set(r,n),t=!0),t}}class Nh{constructor(e,t=null){this.name=e,this.value=t,this.boundary=0,this.itemSize=0,this.offset=0}setValue(e){this.value=e}getValue(){return this.value}}class yh extends Nh{constructor(e,t=0){super(e,t),this.isFloatUniform=!0,this.boundary=4,this.itemSize=1}}class vh extends Nh{constructor(e,t=new n){super(e,t),this.isVector2Uniform=!0,this.boundary=8,this.itemSize=2}}class Th extends Nh{constructor(e,t=new i){super(e,t),this.isVector3Uniform=!0,this.boundary=16,this.itemSize=3}}class _h extends Nh{constructor(e,t=new o){super(e,t),this.isVector4Uniform=!0,this.boundary=16,this.itemSize=4}}class Sh extends Nh{constructor(e,t=new r){super(e,t),this.isColorUniform=!0,this.boundary=16,this.itemSize=3}}class wh extends Nh{constructor(e,t=new a){super(e,t),this.isMatrix3Uniform=!0,this.boundary=48,this.itemSize=12}}class Ch extends Nh{constructor(e,t=new l){super(e,t),this.isMatrix4Uniform=!0,this.boundary=64,this.itemSize=16}}class Ah extends yh{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Rh extends vh{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Mh extends Th{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Eh extends _h{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Bh extends Sh{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Uh extends wh{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Oh extends Ch{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Ih extends hh{constructor(e,t){super(e),this.texture=t,this.version=t.version,this.isSampler=!0}}class Fh extends Ih{constructor(e,t){super(e,t.value),this.textureNode=t}getTexture(){return this.textureNode.value}}let Lh=0;class Dh extends hh{constructor(e,t){super(e),this.id=Lh++,this.texture=t,this.version=t.version,this.isSampledTexture=!0}get needsBindingsUpdate(){const{texture:e,version:t}=this;return!!e.isVideoTexture||t!==e.version}update(){return this.version!==this.texture.version&&(this.version=this.texture.version,!0)}}class Gh extends Dh{constructor(e,t){super(e,t),this.isSampledCubeTexture=!0}}class kh extends Dh{constructor(e,t){super(e,t.value),this.textureNode=t}getTexture(){return this.textureNode.value}}class zh extends Gh{constructor(e,t){super(e,t.value),this.textureNode=t}getTexture(){return this.textureNode.value}}class Ph extends fh{constructor(e,t){super(e,t.array),this.attribute=t,this.isStorageBuffer=!0}}class Vh extends ae{constructor(e,t,s={}){super(e,t,s)}}class $h extends le{constructor(e=1,t={}){super(e,t),this.isCubeRenderTarget=!0}fromEquirectangularTexture(e,t){const s=t.minFilter,r=t.generateMipmaps;t.generateMipmaps=!0,this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n=new ue(5,5,5),i=ja(ia),o=tl("MeshBasicNodeMaterial");o.colorNode=io(t,i,0),o.side=Q,o.blending=ce;const a=new ee(n,o),l=new de;l.add(a),t.minFilter===O&&(t.minFilter=he);return new pe(1,10,this).update(e,l),t.minFilter=s,t.currentGenerateMipmaps=r,a.geometry.dispose(),a.material.dispose(),this}}const qh=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+)?/i,jh=/[a-z_0-9]+/gi,Wh={f32:"float"};class Hh extends Lc{constructor(e){const{type:t,inputs:s,name:r,inputsCode:n,blockCode:i}=(e=>{const t=(e=e.trim()).match(qh);if(null!==t&&4===t.length){const s=t[2],r=[];let n=null;for(;null!==(n=jh.exec(s));)r.push(n);const i=[];let o=0;for(;o<r.length;){const e=r[o++][0];let t=r[o++][0];t=Wh[t]||t,o<r.length&&!0===/^[fui]\d{2}$/.test(r[o][0])&&o++,i.push(new hl(t,e))}const a=e.substring(t[0].length),l=void 0!==t[1]?t[1]:"";return{type:t[3]||"void",inputs:i,name:l,inputsCode:s,blockCode:a}}throw new Error("FunctionNode: Function is not a WGSL code.")})(e);super(t,s,r),this.inputsCode=n,this.blockCode=i}getCode(e=this.name){const t="void"!==this.type?"-> "+this.type:"";return`fn ${e} ( ${this.inputsCode.trim()} ) ${t}`+this.blockCode}}class Xh extends Fc{parseFunction(e){return new Hh(e)}}const Yh={instance:!0},Zh={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat3:"mat3x3<f32>",imat3:"mat3x3<i32>",umat3:"mat3x3<u32>",bmat3:"mat3x3<bool>",mat4:"mat4x4<f32>",imat4:"mat4x4<i32>",umat4:"mat4x4<u32>",bmat4:"mat4x4<bool>"},Kh={dFdx:"dpdx",dFdy:"dpdy",mod:"threejs_mod",lessThanEqual:"threejs_lessThanEqual",inversesqrt:"inverseSqrt"},Jh={lessThanEqual:new Mu("\nfn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );\n\n}\n"),mod:new Mu("\nfn threejs_mod( x : f32, y : f32 ) -> f32 {\n\n\treturn x - y * floor( x / y );\n\n}\n"),repeatWrapping:new Mu("\nfn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n")};class Qh extends cl{constructor(e,t,s=null){super(e,t,new Xh,s),this.uniformsGroup={},this.builtins={vertex:new Map,fragment:new Map,compute:new Map,attribute:new Map}}build(){const{object:e,material:t}=this;return null!==t?NodeMaterial.fromMaterial(t).build(this):this.addFlow("compute",e),super.build()}needsColorSpaceToLinear(e){return!0===e.isVideoTexture&&e.colorSpace!==v}getSampler(e,t,s=this.shaderStage){if("fragment"===s)return`textureSample( ${e}, ${e}_sampler, ${t} )`;this._include("repeatWrapping");return`textureLoad( ${e}, threejs_repeatWrapping( ${t}, ${`textureDimensions( ${e}, 0 )`} ), 0 )`}getVideoSampler(e,t,s=this.shaderStage){if("fragment"===s)return`textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`}getSamplerLevel(e,t,s,r=this.shaderStage){if("fragment"===r)return`textureSampleLevel( ${e}, ${e}_sampler, ${t}, ${s} )`;this._include("repeatWrapping");return`textureLoad( ${e}, threejs_repeatWrapping( ${t}, ${`textureDimensions( ${e}, 0 )`} ), i32( ${s} ) )`}getTexture(e,t,s,r=this.shaderStage){let n=null;return n=!0===e.isVideoTexture?this.getVideoSampler(t,s,r):this.getSampler(t,s,r),n}getTextureLevel(e,t,s,r,n=this.shaderStage){let i=null;return i=!0===e.isVideoTexture?this.getVideoSampler(t,s,n):this.getSamplerLevel(t,s,r,n),i}getPropertyName(e,t=this.shaderStage){if(!0===e.isNodeVarying&&!0===e.needsInterpolation){if("vertex"===t)return`NodeVaryings.${e.name}`}else if(!0===e.isNodeUniform){const t=e.name,s=e.type;return"texture"===s||"cubeTexture"===s?t:"buffer"===s||"storageBuffer"===s?`NodeBuffer_${e.node.id}.${t}`:`NodeUniforms.${t}`}return super.getPropertyName(e)}getUniformFromNode(e,t,s,r=null){const n=super.getUniformFromNode(e,t,s,r),i=this.getDataFromNode(e,s);if(void 0===i.uniformGPU){let r;const o=this.bindings[s];if("texture"===t||"cubeTexture"===t){const e=new Fh(`${n.name}_sampler`,n.node);let i=null;"texture"===t?i=new kh(n.name,n.node):"cubeTexture"===t&&(i=new zh(n.name,n.node));const a=o[o.length-1],l=a&&a.isUniformsGroup?o.length-1:o.length;"fragment"===s?(o.splice(l,0,e,i),r=[e,i]):(o.splice(l,0,i),r=[i])}else if("buffer"===t||"storageBuffer"===t){const s=new("storageBuffer"===t?Ph:xh)("NodeBuffer_"+e.id,e.value),n=o[o.length-1],i=n&&n.isUniformsGroup?o.length-1:o.length;o.splice(i,0,s),r=s}else{let i=this.uniformsGroup[s];if(void 0===i&&(i=new bh("nodeUniforms"),this.uniformsGroup[s]=i,o.push(i)),!0===e.isArrayUniformNode){r=[];for(const s of e.nodes){const e=this._getNodeUniform(s,t);e.boundary=mh(e.itemSize),e.itemSize=gh(e.itemSize),i.addUniform(e),r.push(e)}}else r=this._getNodeUniform(n,t),i.addUniform(r)}i.uniformGPU=r,"vertex"===s&&(this.bindingsOffset.fragment=o.length)}return n}isReference(e){return super.isReference(e)||"texture_2d"===e||"texture_cube"===e}getBuiltin(e,t,s,r=this.shaderStage){const n=this.builtins[r];return!1===n.has(e)&&n.set(e,{name:e,property:t,type:s}),t}getVertexIndex(){return"vertex"===this.shaderStage?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}getInstanceIndex(){return"vertex"===this.shaderStage?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>","fragment")}isFlipY(){return!1}getAttributes(e){const t=[];if("compute"===e&&this.getBuiltin("global_invocation_id","id","vec3<u32>","attribute"),"vertex"===e||"compute"===e){for(const{name:e,property:s,type:r}of this.builtins.attribute.values())t.push(`@builtin( ${e} ) ${s} : ${r}`);const e=this.getAttributesArray();for(let s=0,r=e.length;s<r;s++){const r=e[s],n=r.name,i=this.getType(r.type);t.push(`@location( ${s} ) ${n} : ${i}`)}}return t.join(",\n\t")}getVar(e,t){return`var ${t} : ${this.getType(e)}`}getVars(e){const t=[],s=this.vars[e];for(const e of s)t.push(`\t${this.getVar(e.type,e.name)};`);return`\n${t.join("\n")}\n`}getVaryings(e){const t=[];if("vertex"===e&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),"vertex"===e||"fragment"===e){const s=this.varyings,r=this.vars[e];for(let n=0;n<s.length;n++){const i=s[n];if(i.needsInterpolation){let e=`@location( ${n} )`;"int"!==i.type&&"uint"!==i.type||(e+=" @interpolate( flat )"),t.push(`${e} ${i.name} : ${this.getType(i.type)}`)}else"vertex"===e&&!1===r.includes(i)&&r.push(i)}}for(const{name:s,property:r,type:n}of this.builtins[e].values())t.push(`@builtin( ${s} ) ${r} : ${n}`);const s=t.join(",\n\t");return"vertex"===e?this._getWGSLStruct("NodeVaryingsStruct","\t"+s):s}getUniforms(e){const t=this.uniforms[e],s=[],r=[],n=[];let i=this.bindingsOffset[e];for(const o of t)if("texture"===o.type||"cubeTexture"===o.type){"fragment"===e&&s.push(`@binding( ${i++} ) @group( 0 ) var ${o.name}_sampler : sampler;`);const t=o.node.value;let r;r=!0===t.isCubeTexture?"texture_cube<f32>":!0===t.isDepthTexture?"texture_depth_2d":!0===t.isVideoTexture?"texture_external":"texture_2d<f32>",s.push(`@binding( ${i++} ) @group( 0 ) var ${o.name} : ${r};`)}else if("buffer"===o.type||"storageBuffer"===o.type){const e=o.node,t=this.getType(e.bufferType),s=e.bufferCount,n=s>0?", "+s:"",a=`\t${o.name} : array< ${t}${n} >\n`,l=e.isStorageBufferNode?"storage,read_write":"uniform";r.push(this._getWGSLStructBinding("NodeBuffer_"+e.id,a,l,i++))}else{const e=this.getType(this.getVectorType(o.type));if(!0===Array.isArray(o.value)){const t=o.value.length;n.push(`uniform ${e}[ ${t} ] ${o.name}`)}else n.push(`\t${o.name} : ${e}`)}let o=s.join("\n");return o+=r.join("\n"),n.length>0&&(o+=this._getWGSLStructBinding("NodeUniforms",n.join(",\n"),"uniform",i++)),o}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};for(const t in e){let s="// code\n\n";s+=this.flowCode[t];const r=this.flowNodes[t],n=r[r.length-1];for(const e of r){const r=this.getFlowData(e),i=e.name;i&&(s.length>0&&(s+="\n"),s+=`\t// flow -> ${i}\n\t`),s+=`${r.code}\n\t`,e===n&&"compute"!==t&&(s+="// result\n\t","vertex"===t?s+="NodeVaryings.Vertex = ":"fragment"===t&&(s+="return "),s+=`${r.result};`)}const i=e[t];i.uniforms=this.getUniforms(t),i.attributes=this.getAttributes(t),i.varyings=this.getVaryings(t),i.vars=this.getVars(t),i.codes=this.getCodes(t),i.flow=s}null!==this.material?(this.vertexShader=this._getWGSLVertexCode(e.vertex),this.fragmentShader=this._getWGSLFragmentCode(e.fragment)):this.computeShader=this._getWGSLComputeCode(e.compute,(this.object.workgroupSize||[64]).join(", "))}getRenderTarget(e,t,s){return new Vh(e,t,s)}getCubeRenderTarget(e,t){return new $h(e,t)}getMethod(e){return void 0!==Jh[e]&&this._include(e),Kh[e]||e}getType(e){return Zh[e]||e}isAvailable(e){return!0===Yh[e]}_include(e){Jh[e].build(this)}_getNodeUniform(e,t){if("float"===t)return new Ah(e);if("vec2"===t)return new Rh(e);if("vec3"===t)return new Mh(e);if("vec4"===t)return new Eh(e);if("color"===t)return new Bh(e);if("mat3"===t)return new Uh(e);if("mat4"===t)return new Oh(e);throw new Error(`Uniform "${t}" not declared.`)}_getWGSLVertexCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// codes\n${e.codes}\n\n@vertex\nfn main( ${e.attributes} ) -> NodeVaryingsStruct {\n\n\t// system\n\tvar NodeVaryings: NodeVaryingsStruct;\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n\treturn NodeVaryings;\n\n}\n`}_getWGSLFragmentCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@fragment\nfn main( ${e.varyings} ) -> @location( 0 ) vec4<f32> {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLComputeCode(e,t){return`${this.getSignature()}\n// system\nvar<private> instanceIndex : u32;\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@compute @workgroup_size( ${t} )\nfn main( ${e.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x;\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLStruct(e,t){return`\nstruct ${e} {\n${t}\n};`}_getWGSLStructBinding(e,t,s,r=0,n=0){const i=e+"Struct";return`${this._getWGSLStruct(i,t)}\n@binding( ${r} ) @group( ${n} )\nvar<${s}> ${e} : ${i};`}}let ep=null,tp=null;class sp{constructor(e={}){this.parameters=Object.assign({},e),this.data=new WeakMap,this.renderer=null,this.domElement=null}async init(e){this.renderer=e}begin(e){}finish(e){}draw(e,t){}createProgram(e){}destroyProgram(e){}createBindings(e){}updateBindings(e){}createRenderPipeline(e){}createComputePipeline(e,t){}destroyPipeline(e){}needsUpdate(e){}getCacheKey(e){}createNodeBuilder(e){}createSampler(e){}createDefaultTexture(e){}createTexture(e){}copyTextureToBuffer(e,t,s,r,n){}createAttribute(e){}createIndexAttribute(e){}updateAttribute(e){}destroyAttribute(e){}updateSize(){}hasFeature(e){}getInstanceCount(e){const{object:t,geometry:s}=e;return s.isInstancedBufferGeometry?s.instanceCount:t.isInstancedMesh?t.count:1}getDrawingBufferSize(){return ep=ep||new n,this.renderer.getDrawingBufferSize(ep)}getScissor(){return tp=tp||new o,this.renderer.getScissor(tp)}getDomElement(){let e=this.domElement;return null===e&&(this.domElement=e=void 0!==this.parameters.canvas?this.parameters.canvas:this.createCanvasElement()),e}createCanvasElement(){const e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return e.style.display="block",e}get(e){let t=this.data.get(e);return void 0===t&&(t={},this.data.set(e,t)),t}delete(e){this.data.delete(e)}}class rp{constructor(e){this.backend=e}getCurrentDepthStencilFormat(e){let t;return null!==e.depthTexture?t=this.getTextureFormatGPU(e.depthTexture):e.depth&&e.stencil?t=Sd.Depth24PlusStencil8:e.depth&&(t=Sd.Depth24Plus),t}getTextureFormatGPU(e){return this.backend.get(e).texture.format}getCurrentColorFormat(e){let t;return t=null!==e.texture?this.getTextureFormatGPU(e.texture):Sd.BGRA8Unorm,t}getCurrentColorSpace(e){return null!==e.texture?e.texture.colorSpace:this.backend.renderer.outputColorSpace}getPrimitiveTopology(e,t){return e.isPoints?sd:e.isLineSegments||e.isMesh&&!0===t.wireframe?rd:e.isLine?nd:e.isMesh?id:void 0}getSampleCount(e){return null!==e.texture?1:this.backend.parameters.sampleCount}}const np=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]),ip=new Map([[w,["float16"]]]),op=new Map([[Int32Array,"sint32"],[Uint32Array,"uint32"],[Float32Array,"float32"]]);class ap{constructor(e){this.backend=e}createAttribute(e,t){const s=this._getBufferAttribute(e),r=this.backend,n=r.get(s);let i=n.buffer;if(void 0===i){const e=r.device,o=s.array,a=o.byteLength+(4-o.byteLength%4)%4;i=e.createBuffer({label:s.name,size:a,usage:t,mappedAtCreation:!0}),new o.constructor(i.getMappedRange()).set(o),i.unmap(),n.buffer=i}}updateAttribute(e){const t=this._getBufferAttribute(e),s=this.backend,r=s.device,n=s.get(t).buffer,i=t.array,o=t.updateRange;-1===o.count?r.queue.writeBuffer(n,0,i,0):(r.queue.writeBuffer(n,0,i,o.offset*i.BYTES_PER_ELEMENT,o.count*i.BYTES_PER_ELEMENT),o.count=-1)}createShaderVertexBuffers(e){const t=e.getAttributes(),s=new Map;for(let e=0;e<t.length;e++){const r=t[e],n=r.array.BYTES_PER_ELEMENT,i=this._getBufferAttribute(r);let o=s.get(i);if(void 0===o){let e,t;!0===r.isInterleavedBufferAttribute?(e=r.data.stride*n,t=r.data.isInstancedInterleavedBuffer?ch:uh):(e=r.itemSize*n,t=r.isInstancedBufferAttribute?ch:uh),o={arrayStride:e,attributes:[],stepMode:t},s.set(i,o)}const a=this._getVertexFormat(r),l=!0===r.isInterleavedBufferAttribute?r.offset*n:0;o.attributes.push({shaderLocation:e,offset:l,format:a})}return Array.from(s.values())}destroyAttribute(e){const t=this.backend;t.get(this._getBufferAttribute(e)).buffer.destroy(),t.delete(e)}async getArrayBuffer(e){const t=this.backend,s=t.device,r=t.get(this._getBufferAttribute(e)),n=r.buffer,i=n.size;let o=r.readBuffer,a=!0;void 0===o&&(o=s.createBuffer({label:e.name,size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),a=!1,r.readBuffer=o);const l=s.createCommandEncoder({});l.copyBufferToBuffer(n,0,o,0,i),a&&o.unmap();const u=l.finish();s.queue.submit([u]),await o.mapAsync(GPUMapMode.READ);return o.getMappedRange()}_getVertexFormat(e){const{itemSize:t,normalized:s}=e,r=e.array.constructor,n=e.constructor;let i;if(1==t)i=op.get(r);else{const e=(ip.get(n)||np.get(r))[s?1:0];if(e){const s=r.BYTES_PER_ELEMENT*t,n=4*Math.floor((s+3)/4)/r.BYTES_PER_ELEMENT;if(n%1)throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");i=`${e}x${n}`}}return i}_getBufferAttribute(e){return e.isInterleavedBufferAttribute&&(e=e.data),e}}class lp{constructor(e){this.backend=e}createBindings(e,t){const s=this.backend,r=s.get(e),n=s.get(t).pipeline.getBindGroupLayout(0),i=this.createBindGroup(e,n);r.layout=n,r.group=i,r.bindings=e}updateBinding(e){const t=this.backend,s=t.device,r=e.buffer,n=t.get(e).buffer;s.queue.writeBuffer(n,0,r,0)}createBindGroup(e,t){const s=this.backend,r=s.device;let n=0;const i=[];for(const t of e){if(t.isUniformBuffer){const e=s.get(t);if(void 0===e.buffer){const s=t.byteLength,n=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,i=r.createBuffer({label:"bindingBuffer",size:s,usage:n});e.buffer=i}i.push({binding:n,resource:{buffer:e.buffer}})}else if(t.isStorageBuffer){const e=s.get(t);if(void 0===e.buffer){const r=t.attribute;e.buffer=s.get(r).buffer}i.push({binding:n,resource:{buffer:e.buffer}})}else if(t.isSampler){const e=s.get(t.texture);i.push({binding:n,resource:e.sampler})}else if(t.isSampledTexture){const e=s.get(t.texture);let o,a;if(o=t.isSampledCubeTexture?ah:oh,void 0!==e.externalTexture)a=r.importExternalTexture({source:e.externalTexture});else{const t=lh;a=e.texture.createView({aspect:t,dimension:o})}i.push({binding:n,resource:a})}n++}return r.createBindGroup({layout:t,entries:i})}}class up{constructor(e){this.backend=e}createRenderPipeline(e){const{object:t,material:s,geometry:r,pipeline:n}=e,{vertexProgram:i,fragmentProgram:o}=n,a=this.backend,l=a.device,u=a.utils,c=a.get(n),d=a.attributeUtils.createShaderVertexBuffers(e);let h;!0===s.transparent&&s.blending!==ce&&(h={alpha:this._getAlphaBlend(s),color:this._getColorBlend(s)});let p={};!0===s.stencilWrite&&(p={compare:this._getStencilCompare(s),failOp:this._getStencilOperation(s.stencilFail),depthFailOp:this._getStencilOperation(s.stencilZFail),passOp:this._getStencilOperation(s.stencilZPass)});const m=a.get(i).module,g=a.get(o).module,f=this._getPrimitiveState(t,r,s),x=this._getColorWriteMask(s),b=this._getDepthCompare(s),N=u.getCurrentColorFormat(e.context),y=u.getCurrentDepthStencilFormat(e.context),v=u.getSampleCount(e.context);c.pipeline=l.createRenderPipeline({vertex:Object.assign({},m,{buffers:d}),fragment:Object.assign({},g,{targets:[{format:N,blend:h,writeMask:x}]}),primitive:f,depthStencil:{format:y,depthWriteEnabled:s.depthWrite,depthCompare:b,stencilFront:p,stencilBack:{},stencilReadMask:s.stencilFuncMask,stencilWriteMask:s.stencilWriteMask},multisample:{count:v},layout:"auto"})}createComputePipeline(e){const t=this.backend,s=t.device,r=t.get(e.computeProgram).module;t.get(e).pipeline=s.createComputePipeline({compute:r,layout:"auto"})}_getAlphaBlend(e){const t=e.blending,s=e.premultipliedAlpha;let r;switch(t){case be:!1===s&&(r={srcFactor:Bd,dstFactor:Fd,operation:$d});break;case xe:r={srcFactor:Ed,dstFactor:Bd,operation:$d};break;case fe:!0===s&&(r={srcFactor:Od,dstFactor:Fd,operation:$d});break;case ge:!0===s&&(r={srcFactor:Ed,dstFactor:Id,operation:$d});break;case me:const t=e.blendSrcAlpha,n=e.blendDstAlpha,i=e.blendEquationAlpha;null!==t&&null!==n&&null!==i&&(r={srcFactor:this._getBlendFactor(t),dstFactor:this._getBlendFactor(n),operation:this._getBlendOperation(i)})}return r}_getBlendFactor(e){let t;switch(e){case Me:t=Ed;break;case Re:t=Bd;break;case Ae:t=Ud;break;case Ce:t=Od;break;case we:t=Id;break;case Se:t=Fd;break;case _e:t=Ld;break;case Te:t=Dd;break;case ve:t=Gd;break;case ye:t=kd;break;case Ne:t=zd;break;case 211:t=Pd;break;case 212:t=Vd}return t}_getColorBlend(e){const t=e.blending,s=e.premultipliedAlpha,r={srcFactor:null,dstFactor:null,operation:null};switch(t){case be:r.srcFactor=!0===s?Bd:Id,r.dstFactor=Fd,r.operation=$d;break;case xe:r.srcFactor=!0===s?Bd:Id,r.dstFactor=Bd,r.operation=$d;break;case fe:r.srcFactor=Ed,r.dstFactor=!0===s?Ed:Od,r.operation=$d;break;case ge:r.srcFactor=Ed,r.dstFactor=Ud,r.operation=$d;break;case me:r.srcFactor=this._getBlendFactor(e.blendSrc),r.dstFactor=this._getBlendFactor(e.blendDst),r.operation=this._getBlendOperation(e.blendEquation)}return r}_getStencilCompare(e){let t;switch(e.stencilFunc){case De:t=ad;break;case Le:t=md;break;case Fe:t=ld;break;case Ie:t=cd;break;case Oe:t=ud;break;case Ue:t=pd;break;case Be:t=dd;break;case Ee:t=hd}return t}_getStencilOperation(e){let t;switch(e){case je:t=Zd;break;case qe:t=Kd;break;case $e:t=Jd;break;case Ve:t=Qd;break;case Pe:t=eh;break;case ze:t=th;break;case ke:t=sh;break;case Ge:t=rh}return t}_getBlendOperation(e){let t;switch(e){case Ze:t=$d;break;case Ye:t=qd;break;case Xe:t=jd;break;case He:t=Wd;break;case We:t=Hd}return t}_getPrimitiveState(e,t,s){const r={},n=this.backend.utils;if(r.topology=n.getPrimitiveTopology(e,s),!0===e.isLine&&!0!==e.isLineSegments){const e=t.index?t.index.count:t.attributes.position.count;r.stripIndexFormat=e>65535?_d:Td}switch(s.side){case oe:r.frontFace=bd,r.cullMode=yd;break;case Q:r.frontFace=bd,r.cullMode=vd;break;case ie:r.frontFace=bd,r.cullMode=Nd}return r}_getColorWriteMask(e){return!0===e.colorWrite?Yd:Xd}_getDepthCompare(e){let t;if(!1===e.depthTest)t=md;else{switch(e.depthFunc){case nt:t=ad;break;case rt:t=md;break;case st:t=ld;break;case tt:t=cd;break;case et:t=ud;break;case Qe:t=pd;break;case Je:t=dd;break;case Ke:t=hd}}return t}}class cp{constructor(e){this.device=e;this.sampler=e.createSampler({minFilter:Rd}),this.pipelines={},this.mipmapVertexShaderModule=e.createShaderModule({label:"mipmapVertex",code:"\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n"}),this.mipmapFragmentShaderModule=e.createShaderModule({label:"mipmapFragment",code:"\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n"})}getMipmapPipeline(e){let t=this.pipelines[e];return void 0===t&&(t=this.device.createRenderPipeline({vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.mipmapFragmentShaderModule,entryPoint:"main",targets:[{format:e}]},primitive:{topology:od,stripIndexFormat:_d},layout:"auto"}),this.pipelines[e]=t),t}generateMipmaps(e,t,s=0){const r=this.getMipmapPipeline(t.format),n=this.device.createCommandEncoder({}),i=r.getBindGroupLayout(0);let o=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:oh,baseArrayLayer:s});for(let a=1;a<t.mipLevelCount;a++){const t=e.createView({baseMipLevel:a,mipLevelCount:1,dimension:oh,baseArrayLayer:s}),l=n.beginRenderPass({colorAttachments:[{view:t,loadOp:xd,storeOp:gd,clearValue:[0,0,0,0]}]}),u=this.device.createBindGroup({layout:i,entries:[{binding:0,resource:this.sampler},{binding:1,resource:o}]});l.setPipeline(r),l.setBindGroup(0,u),l.draw(4,1,0,0),l.end(),o=t}this.device.queue.submit([n.finish()])}}const dp={[pt]:"never",[mt]:"less",[gt]:"equal",[ft]:"less-equal",[xt]:"greater",[bt]:"not-equal",[Nt]:"greater-equal",[yt]:"always"};class hp{constructor(e){this.backend=e,this.mipmapUtils=null,this.defaultTexture=null,this.defaultCubeTexture=null}createSampler(e){const t=this.backend,s=t.device,r=t.get(e),n={addressModeU:this._convertAddressMode(e.wrapS),addressModeV:this._convertAddressMode(e.wrapT),addressModeW:this._convertAddressMode(e.wrapR),magFilter:this._convertFilterMode(e.magFilter),minFilter:this._convertFilterMode(e.minFilter),mipmapFilter:this._convertFilterMode(e.minFilter),maxAnisotropy:e.anisotropy};e.isDepthTexture&&null!==e.compareFunction&&(n.compare=dp[e.compareFunction]),r.sampler=s.createSampler(n)}createDefaultTexture(e){let t;t=e.isCubeTexture?this._getDefaultCubeTextureGPU():this._getDefaultTextureGPU(),this.backend.get(e).texture=t}createTexture(e,t={}){const s=this.backend,r=s.get(e);if(r.initialized)throw new Error("WebGPUTextureUtils: Texture already initialized.");const{width:n,height:i,depth:o}=this._getSize(e),a=this._needsMipmaps(e),l=this._getDimension(e),u=this._getMipLevelCount(e,n,i,a),c=e.internalFormat||this._getFormat(e),d=void 0!==t.sampleCount?t.sampleCount:1;let h=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC;!0!==e.isCompressedTexture&&(h|=GPUTextureUsage.RENDER_ATTACHMENT);const p={label:e.name,size:{width:n,height:i,depthOrArrayLayers:o},mipLevelCount:u,sampleCount:d,dimension:l,format:c,usage:h};if(e.isVideoTexture){const t=e.source.data,s=new VideoFrame(t);p.size.width=s.displayWidth,p.size.height=s.displayHeight,s.close(),r.externalTexture=t}else r.texture=s.device.createTexture(p);r.initialized=!0,r.needsMipmaps=a,r.textureDescriptorGPU=p}destroyTexture(e){const t=this.backend;t.get(e).texture.destroy(),t.delete(e)}destroySampler(e){delete this.backend.get(e).sampler}generateMipmaps(e){const t=this.backend.get(e);if(e.isCubeTexture)for(let e=0;e<6;e++)this._generateMipmaps(t.texture,t.textureDescriptorGPU,e);else this._generateMipmaps(t.texture,t.textureDescriptorGPU)}updateTexture(e){const t=this.backend.get(e),{needsMipmaps:s,textureDescriptorGPU:r}=t;if(e.isDataTexture||e.isDataArrayTexture||e.isData3DTexture)this._copyBufferToTexture(e.image,t.texture,r,s);else if(e.isCompressedTexture)this._copyCompressedBufferToTexture(e.mipmaps,t.texture,r);else if(e.isCubeTexture)6===e.image.length&&this._copyCubeMapToTexture(e.image,e,t.texture,r,s);else if(e.isRenderTargetTexture)!0===s&&this._generateMipmaps(t.texture,r);else if(e.isVideoTexture){const s=e.source.data;t.externalTexture=s}else null!==e.image&&this._copyImageToTexture(e.image,e,t.texture,r,s);t.version=e.version,e.onUpdate&&e.onUpdate(e)}async copyTextureToBuffer(e,t,s,r,n){const i=this.backend.device,o=this.backend.get(e),a=o.texture,l=o.textureDescriptorGPU.format,u=this._getBytesPerTexel(l),c=i.createBuffer({size:r*n*u,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),d=i.createCommandEncoder();d.copyTextureToBuffer({texture:a,origin:{x:t,y:s}},{buffer:c,bytesPerRow:r*u},{width:r,height:n});const h=this._getTypedArrayType(l);i.queue.submit([d.finish()]),await c.mapAsync(GPUMapMode.READ);return new h(c.getMappedRange())}_isEnvironmentTexture(e){const t=e.mapping;return t===se||t===re||t===it||t===ot}_getDefaultTextureGPU(){let e=this.defaultTexture;if(null===e){const t=new at;t.minFilter=N,t.magFilter=N,this.createTexture(t),this.defaultTexture=e=t}return this.backend.get(e).texture}_getDefaultCubeTextureGPU(){let e=this.defaultTexture;if(null===e){const t=new lt;t.minFilter=N,t.magFilter=N,this.createTexture(t),this.defaultCubeTexture=e=t}return this.backend.get(e).texture}_copyImageToTexture(e,t,s,r,n,i){this._isHTMLImage(e)?this._getImageBitmapFromHTML(e,t).then((e=>{this._copyExternalImageToTexture(e,s,r,n,i)})):this._copyExternalImageToTexture(e,s,r,n,i)}_isHTMLImage(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement}_copyCubeMapToTexture(e,t,s,r,n){for(let i=0;i<6;i++){const o=e[i];o.isDataTexture?this._copyBufferToTexture(o.image,s,r,n,i):this._copyImageToTexture(o,t,s,r,n,i)}}_copyExternalImageToTexture(e,t,s,r,n=0){this.backend.device.queue.copyExternalImageToTexture({source:e},{texture:t,mipLevel:0,origin:{x:0,y:0,z:n}},{width:e.width,height:e.height,depthOrArrayLayers:1}),r&&this._generateMipmaps(t,s,n)}_generateMipmaps(e,t,s=0){null===this.mipmapUtils&&(this.mipmapUtils=new cp(this.backend.device)),this.mipmapUtils.generateMipmaps(e,t,s)}_getImageBitmapFromHTML(e,t){const s=e.width,r=e.height,n={};return n.imageOrientation=!0===t.flipY?"flipY":"none",n.premultiplyAlpha=!0===t.premultiplyAlpha?"premultiply":"default",createImageBitmap(e,0,0,s,r,n)}_copyBufferToTexture(e,t,s,r,n=0){const i=this.backend.device,o=e.data,a=this._getBytesPerTexel(s.format),l=e.width*a;i.queue.writeTexture({texture:t,mipLevel:0,origin:{x:0,y:0,z:n}},o,{offset:0,bytesPerRow:l},{width:e.width,height:e.height,depthOrArrayLayers:void 0!==e.depth?e.depth:1}),!0===r&&this._generateMipmaps(t,s,n)}_copyCompressedBufferToTexture(e,t,s){const r=this.backend.device,n=this._getBlockData(s.format);for(let s=0;s<e.length;s++){const i=e[s],o=i.width,a=i.height,l=Math.ceil(o/n.width)*n.byteLength;r.queue.writeTexture({texture:t,mipLevel:s},i.data,{offset:0,bytesPerRow:l},{width:Math.ceil(o/n.width)*n.width,height:Math.ceil(a/n.width)*n.width,depthOrArrayLayers:1})}}_getBlockData(e){return e===Sd.BC1RGBAUnorm||e===Sd.BC1RGBAUnormSRGB?{byteLength:8,width:4,height:4}:e===Sd.BC2RGBAUnorm||e===Sd.BC2RGBAUnormSRGB||e===Sd.BC3RGBAUnorm||e===Sd.BC3RGBAUnormSRGB?{byteLength:16,width:4,height:4}:e===Sd.BC4RUnorm||e===Sd.BC4RSNorm?{byteLength:8,width:4,height:4}:e===Sd.BC5RGUnorm||e===Sd.BC5RGSnorm||e===Sd.BC6HRGBUFloat||e===Sd.BC6HRGBFloat||e===Sd.BC7RGBAUnorm||e===Sd.BC7RGBAUnormSRGB?{byteLength:16,width:4,height:4}:e===Sd.ETC2RGB8Unorm||e===Sd.ETC2RGB8UnormSRGB||e===Sd.ETC2RGB8A1Unorm||e===Sd.ETC2RGB8A1UnormSRGB?{byteLength:8,width:4,height:4}:e===Sd.ETC2RGBA8Unorm||e===Sd.ETC2RGBA8UnormSRGB?{byteLength:16,width:4,height:4}:e===Sd.EACR11Unorm||e===Sd.EACR11Snorm?{byteLength:8,width:4,height:4}:e===Sd.EACRG11Unorm||e===Sd.EACRG11Snorm||e===Sd.ASTC4x4Unorm||e===Sd.ASTC4x4UnormSRGB?{byteLength:16,width:4,height:4}:e===Sd.ASTC5x4Unorm||e===Sd.ASTC5x4UnormSRGB?{byteLength:16,width:5,height:4}:e===Sd.ASTC5x5Unorm||e===Sd.ASTC5x5UnormSRGB?{byteLength:16,width:5,height:5}:e===Sd.ASTC6x5Unorm||e===Sd.ASTC6x5UnormSRGB?{byteLength:16,width:6,height:5}:e===Sd.ASTC6x6Unorm||e===Sd.ASTC6x6UnormSRGB?{byteLength:16,width:6,height:6}:e===Sd.ASTC8x5Unorm||e===Sd.ASTC8x5UnormSRGB?{byteLength:16,width:8,height:5}:e===Sd.ASTC8x6Unorm||e===Sd.ASTC8x6UnormSRGB?{byteLength:16,width:8,height:6}:e===Sd.ASTC8x8Unorm||e===Sd.ASTC8x8UnormSRGB?{byteLength:16,width:8,height:8}:e===Sd.ASTC10x5Unorm||e===Sd.ASTC10x5UnormSRGB?{byteLength:16,width:10,height:5}:e===Sd.ASTC10x6Unorm||e===Sd.ASTC10x6UnormSRGB?{byteLength:16,width:10,height:6}:e===Sd.ASTC10x8Unorm||e===Sd.ASTC10x8UnormSRGB?{byteLength:16,width:10,height:8}:e===Sd.ASTC10x10Unorm||e===Sd.ASTC10x10UnormSRGB?{byteLength:16,width:10,height:10}:e===Sd.ASTC12x10Unorm||e===Sd.ASTC12x10UnormSRGB?{byteLength:16,width:12,height:10}:e===Sd.ASTC12x12Unorm||e===Sd.ASTC12x12UnormSRGB?{byteLength:16,width:12,height:12}:void 0}_convertAddressMode(e){let t=wd;return e===vt?t=Cd:e===Tt&&(t=Ad),t}_convertFilterMode(e){let t=Rd;return e!==N&&e!==_t&&e!==St||(t=Md),t}_getSize(e){const t=e.image;let s,r,n;if(e.isCubeTexture){const e=t.length>0?t[0].image||t[0]:null;s=e?e.width:1,r=e?e.height:1,n=6}else null!==t?(s=t.width,r=t.height,n=void 0!==t.depth?t.depth:1):s=r=n=1;return{width:s,height:r,depth:n}}_needsMipmaps(e){return!!this._isEnvironmentTexture(e)||!0!==e.isCompressedTexture&&e.minFilter!==N&&e.minFilter!==he}_getBytesPerTexel(e){return e===Sd.R8Unorm?1:e===Sd.R16Float||e===Sd.RG8Unorm?2:e===Sd.RG16Float||e===Sd.R32Float||e===Sd.RGBA8Unorm||e===Sd.RGBA8UnormSRGB?4:e===Sd.RG32Float||e===Sd.RGBA16Float?8:e===Sd.RGBA32Float?16:void 0}_getTypedArrayType(e){return e===Sd.R8Uint?Uint8Array:e===Sd.R8Sint?Int8Array:e===Sd.R8Unorm?Uint8Array:e===Sd.R8Snorm?Int8Array:e===Sd.RG8Uint?Uint8Array:e===Sd.RG8Sint?Int8Array:e===Sd.RG8Unorm?Uint8Array:e===Sd.RG8Snorm?Int8Array:e===Sd.RGBA8Uint?Uint8Array:e===Sd.RGBA8Sint?Int8Array:e===Sd.RGBA8Unorm?Uint8Array:e===Sd.RGBA8Snorm?Int8Array:e===Sd.R16Uint?Uint16Array:e===Sd.R16Sint?Int16Array:e===Sd.RG16Uint?Uint16Array:e===Sd.RG16Sint?Int16Array:e===Sd.RGBA16Uint?Uint16Array:e===Sd.RGBA16Sint?Int16Array:e===Sd.R32Uint?Uint32Array:e===Sd.R32Sint?Int32Array:e===Sd.R32Float?Float32Array:e===Sd.RG32Uint?Uint32Array:e===Sd.RG32Sint?Int32Array:e===Sd.RG32Float?Float32Array:e===Sd.RGBA32Uint?Uint32Array:e===Sd.RGBA32Sint?Int32Array:e===Sd.RGBA32Float?Float32Array:void 0}_getDimension(e){let t;return t=e.isData3DTexture?ih:nh,t}_getMipLevelCount(e,t,s,r){let n;return n=e.isCompressedTexture?e.mipmaps.length:r?Math.floor(Math.log2(Math.max(t,s)))+1:1,n}_getFormat(e){const t=e.format,s=e.type,r=e.colorSpace;let n;if(!0===e.isFramebufferTexture)n=Sd.BGRA8Unorm;else if(!0===e.isCompressedTexture)switch(t){case $t:n=r===d?Sd.BC1RGBAUnormSRGB:Sd.BC1RGBAUnorm;break;case Vt:n=r===d?Sd.BC2RGBAUnormSRGB:Sd.BC2RGBAUnorm;break;case Pt:n=r===d?Sd.BC3RGBAUnormSRGB:Sd.BC3RGBAUnorm;break;case zt:n=r===d?Sd.ETC2RGB8UnormSRGB:Sd.ETC2RGB8Unorm;break;case kt:n=r===d?Sd.ETC2RGBA8UnormSRGB:Sd.ETC2RGBA8Unorm;break;case Gt:n=r===d?Sd.ASTC4x4UnormSRGB:Sd.ASTC4x4Unorm;break;case Dt:n=r===d?Sd.ASTC5x4UnormSRGB:Sd.ASTC5x4Unorm;break;case Lt:n=r===d?Sd.ASTC5x5UnormSRGB:Sd.ASTC5x5Unorm;break;case Ft:n=r===d?Sd.ASTC6x5UnormSRGB:Sd.ASTC6x5Unorm;break;case It:n=r===d?Sd.ASTC6x6UnormSRGB:Sd.ASTC6x6Unorm;break;case Ot:n=r===d?Sd.ASTC8x5UnormSRGB:Sd.ASTC8x5Unorm;break;case Ut:n=r===d?Sd.ASTC8x6UnormSRGB:Sd.ASTC8x6Unorm;break;case Bt:n=r===d?Sd.ASTC8x8UnormSRGB:Sd.ASTC8x8Unorm;break;case Et:n=r===d?Sd.ASTC10x5UnormSRGB:Sd.ASTC10x5Unorm;break;case Mt:n=r===d?Sd.ASTC10x6UnormSRGB:Sd.ASTC10x6Unorm;break;case Rt:n=r===d?Sd.ASTC10x8UnormSRGB:Sd.ASTC10x8Unorm;break;case At:n=r===d?Sd.ASTC10x10UnormSRGB:Sd.ASTC10x10Unorm;break;case Ct:n=r===d?Sd.ASTC12x10UnormSRGB:Sd.ASTC12x10Unorm;break;case wt:n=r===d?Sd.ASTC12x12UnormSRGB:Sd.ASTC12x12Unorm}else switch(t){case ht:switch(s){case Wt:n=r===d?Sd.RGBA8UnormSRGB:Sd.RGBA8Unorm;break;case jt:n=Sd.RGBA16Float;break;case ut:n=Sd.RGBA32Float}break;case dt:switch(s){case Wt:n=Sd.R8Unorm;break;case jt:n=Sd.R16Float;break;case ut:n=Sd.R32Float}break;case ct:switch(s){case Wt:n=Sd.RG8Unorm;break;case jt:n=Sd.RG16Float;break;case ut:n=Sd.RG32Float}break;case F:switch(s){case qt:n=Sd.Depth16Unorm;break;case I:n=Sd.Depth24Plus;break;case ut:n=Sd.Depth32Float}break;case K:switch(s){case J:n=Sd.Depth24PlusStencil8;break;case ut:this.device.features.has(dh.Depth32FloatStencil8),n=Sd.Depth32FloatStencil8}}return n}}let pp=[];class mp extends sp{constructor(e={}){super(e),this.parameters.antialias=!0===e.antialias,!0===this.parameters.antialias?this.parameters.sampleCount=void 0===e.sampleCount?4:e.sampleCount:this.parameters.sampleCount=1,this.parameters.requiredLimits=void 0===e.requiredLimits?{}:e.requiredLimits,this.adapter=null,this.device=null,this.context=null,this.colorBuffer=null,this.depthBuffers=new WeakMap,this.utils=new rp(this),this.attributeUtils=new ap(this),this.bindingUtils=new lp(this),this.pipelineUtils=new up(this),this.textureUtils=new hp(this)}async init(e){await super.init(e);const t=this.parameters,s={powerPreference:t.powerPreference},r=await navigator.gpu.requestAdapter(s);if(null===r)throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");const n=Object.values(dh),i=[];for(const e of n)r.features.has(e)&&i.push(e);const o={requiredFeatures:i,requiredLimits:t.requiredLimits},a=await r.requestDevice(o),l=void 0!==t.context?t.context:e.domElement.getContext("webgpu");this.adapter=r,this.device=a,this.context=l,pp.length&&(pp.forEach((e=>e())),pp=[]),this.updateSize()}get coordinateSystem(){return Ht}async getArrayBuffer(e){return await this.attributeUtils.getArrayBuffer(e)}beginRender(e){const t=this.get(e),s=this.device,r={colorAttachments:[{view:null}],depthStencilAttachment:{view:null}},n=r.colorAttachments[0],i=r.depthStencilAttachment,o=this.parameters.antialias;if(null!==e.texture){const t=this.get(e.texture),s=this.get(e.depthTexture);n.view=t.texture.createView({baseMipLevel:0,mipLevelCount:1,baseArrayLayer:e.activeCubeFace,dimension:oh}),i.view=s.texture.createView(),e.stencil&&e.depthTexture.format===F&&(e.stencil=!1)}else!0===o?(n.view=this.colorBuffer.createView(),n.resolveTarget=this.context.getCurrentTexture().createView()):(n.view=this.context.getCurrentTexture().createView(),n.resolveTarget=void 0),i.view=this._getDepthBufferGPU(e).createView();e.clearColor?(n.clearValue=e.clearColorValue,n.loadOp=xd,n.storeOp=gd):(n.loadOp=fd,n.storeOp=gd),e.depth&&(e.clearDepth?(i.depthClearValue=e.clearDepthValue,i.depthLoadOp=xd,i.depthStoreOp=gd):(i.depthLoadOp=fd,i.depthStoreOp=gd)),e.stencil&&(e.clearStencil?(i.stencilClearValue=e.clearStencilValue,i.stencilLoadOp=xd,i.stencilStoreOp=gd):(i.stencilLoadOp=fd,i.stencilStoreOp=gd));const a=s.createCommandEncoder({label:"renderContext_"+e.id}),l=a.beginRenderPass(r);if(t.descriptor=r,t.encoder=a,t.currentPass=l,t.currentAttributesSet={},e.viewport&&this.updateViewport(e),e.scissor){const{x:t,y:s,width:r,height:n}=e.scissorValue;l.setScissorRect(t,s,r,n)}}finishRender(e){const t=this.get(e);t.currentPass.end(),this.device.queue.submit([t.encoder.finish()]),null!==e.texture&&!0===e.texture.generateMipmaps&&this.textureUtils.generateMipmaps(e.texture)}updateViewport(e){const{currentPass:t}=this.get(e),{x:s,y:r,width:n,height:i,minDepth:o,maxDepth:a}=e.viewportValue;t.setViewport(s,r,n,i,o,a)}clear(e,t,s,r){const n=this.device,i=this.get(e),{descriptor:o}=i;s=s&&e.depth,r=r&&e.stencil;const a=o.colorAttachments[0];!0===this.parameters.antialias?(a.view=this.colorBuffer.createView(),a.resolveTarget=this.context.getCurrentTexture().createView()):(a.view=this.context.getCurrentTexture().createView(),a.resolveTarget=void 0),o.depthStencilAttachment.view=this._getDepthBufferGPU(e).createView(),t&&(a.loadOp=xd,a.clearValue=e.clearColorValue),s&&(o.depthStencilAttachment.depthLoadOp=xd,o.depthStencilAttachment.depthClearValue=e.clearDepthValue),r&&(o.depthStencilAttachment.stencilLoadOp=xd,o.depthStencilAttachment.stencilClearValue=e.clearStencilValue),i.encoder=n.createCommandEncoder({}),i.currentPass=i.encoder.beginRenderPass(o),i.currentPass.end(),n.queue.submit([i.encoder.finish()])}beginCompute(e){const t=this.get(e);t.cmdEncoderGPU=this.device.createCommandEncoder({}),t.passEncoderGPU=t.cmdEncoderGPU.beginComputePass()}compute(e,t,s,r){const{passEncoderGPU:n}=this.get(e),i=this.get(r).pipeline;n.setPipeline(i);const o=this.get(s).group;n.setBindGroup(0,o),n.dispatchWorkgroups(t.dispatchCount)}finishCompute(e){const t=this.get(e);t.passEncoderGPU.end(),this.device.queue.submit([t.cmdEncoderGPU.finish()])}draw(e,t){const{object:s,geometry:r,context:n,pipeline:i}=e,o=this.get(e.getBindings()),a=this.get(n),l=this.get(i).pipeline,u=a.currentAttributesSet,c=a.currentPass;c.setPipeline(l);const d=o.group;c.setBindGroup(0,d);const h=e.getIndex(),p=null!==h;if(!0===p&&u.index!==h){const e=this.get(h).buffer,t=h.array instanceof Uint16Array?Td:_d;c.setIndexBuffer(e,t),u.index=h}const m=e.getAttributes();for(let e=0,t=m.length;e<t;e++){const t=m[e];if(u[e]!==t){const s=this.get(t).buffer;c.setVertexBuffer(e,s),u[e]=t}}const g=r.drawRange,f=g.start,x=this.getInstanceCount(e);if(!0===p){const e=g.count!==1/0?g.count:h.count;c.drawIndexed(e,x,f,0,0),t.update(s,e,x)}else{const e=r.attributes.position,n=g.count!==1/0?g.count:e.count;c.draw(n,x,f,0),t.update(s,n,x)}}needsUpdate(e){const t=this.get(e),{object:s,material:r}=e,n=this.utils,i=n.getSampleCount(e.context),o=n.getCurrentColorSpace(e.context),a=n.getCurrentColorFormat(e.context),l=n.getCurrentDepthStencilFormat(e.context),u=n.getPrimitiveTopology(s,r);let c=!1;return t.sampleCount===i&&t.colorSpace===o&&t.colorFormat===a&&t.depthStencilFormat===l&&t.primitiveTopology===u||(t.sampleCount=i,t.colorSpace=o,t.colorFormat=a,t.depthStencilFormat=l,t.primitiveTopology=u,c=!0),c}getCacheKey(e){const{object:t,material:s}=e,r=this.utils,n=e.context;return[r.getSampleCount(n),r.getCurrentColorSpace(n),r.getCurrentColorFormat(n),r.getCurrentDepthStencilFormat(n),r.getPrimitiveTopology(t,s)].join()}createSampler(e){this.textureUtils.createSampler(e)}destroySampler(e){this.textureUtils.destroySampler(e)}createDefaultTexture(e){this.textureUtils.createDefaultTexture(e)}createTexture(e){this.textureUtils.createTexture(e)}updateTexture(e){this.textureUtils.updateTexture(e)}destroyTexture(e){this.textureUtils.destroyTexture(e)}copyTextureToBuffer(e,t,s,r,n){return this.textureUtils.copyTextureToBuffer(e,t,s,r,n)}createNodeBuilder(e,t){return new Qh(e,t)}createProgram(e){this.get(e).module={module:this.device.createShaderModule({code:e.code,label:e.stage}),entryPoint:"main"}}destroyProgram(e){this.delete(e)}createRenderPipeline(e){this.pipelineUtils.createRenderPipeline(e)}createComputePipeline(e){this.pipelineUtils.createComputePipeline(e)}createBindings(e,t){this.bindingUtils.createBindings(e,t)}updateBindings(e,t){this.bindingUtils.createBindings(e,t)}updateBinding(e){this.bindingUtils.updateBinding(e)}createIndexAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createStorageAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}updateAttribute(e){this.attributeUtils.updateAttribute(e)}destroyAttribute(e){this.attributeUtils.destroyAttribute(e)}updateSize(){this._configureContext(),this._setupColorBuffer()}hasFeature(e){return new Promise(((t,s)=>{this.adapter?t(this.adapter.features.has(e)):pp.push((()=>t(this.hasFeature(e))))}))}copyFramebufferToTexture(e,t){const s=this.get(t),{encoder:r,descriptor:n}=s;let i=null;e.isFramebufferTexture?i=this.context.getCurrentTexture():e.isDepthTexture&&(i=this._getDepthBufferGPU(t));const o=this.get(e).texture;s.currentPass.end(),r.copyTextureToTexture({texture:i,origin:{x:0,y:0,z:0}},{texture:o},[e.image.width,e.image.height]),e.generateMipmaps&&this.textureUtils.generateMipmaps(e),n.colorAttachments[0].loadOp=fd,t.depth&&(n.depthStencilAttachment.depthLoadOp=fd),t.stencil&&(n.depthStencilAttachment.stencilLoadOp=fd),s.currentPass=r.beginRenderPass(n),s.currentAttributesSet={}}_getDepthBufferGPU(e){const{depthBuffers:t}=this,{width:s,height:r}=this.getDrawingBufferSize();let n=t.get(e);return void 0!==n&&n.image.width===s&&n.image.height===r||(this._destroyDepthBufferGPU(e),n=new b,n.name="depthBuffer",e.stencil?(n=new b,n.format=K,n.type=J):e.depth&&(n=new b,n.format=F,n.type=I),n.image.width=s,n.image.height=r,this.textureUtils.createTexture(n,{sampleCount:this.parameters.sampleCount}),t.set(e,n)),this.get(n).texture}_destroyDepthBufferGPU(e){const{depthBuffers:t}=this,s=t.get(e);void 0!==s&&(this.textureUtils.destroyTexture(s),t.delete(e))}_configureContext(){this.context.configure({device:this.device,format:Sd.BGRA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:"premultiplied"})}_setupColorBuffer(){this.colorBuffer&&this.colorBuffer.destroy();const{width:e,height:t}=this.getDrawingBufferSize();this.colorBuffer=this.device.createTexture({label:"colorBuffer",size:{width:e,height:t,depthOrArrayLayers:1},sampleCount:this.parameters.sampleCount,format:Sd.BGRA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC})}}class gp extends td{constructor(e={}){super(new mp(e)),this.isWebGPURenderer=!0}}const fp="requestVideoFrameCallback"in HTMLVideoElement.prototype,xp=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,bp=window.cancelAnimationFrame||window.mozCancelAnimationFrame;let Np;class yp{constructor(e,t){this._callback=e,this.video=t,this.animationID=null,this.running=!1}set callback(e){this._callback=e}async animateLegacy(){const e=this.video.currentTime;e>Np&&((1/(e-Np)).toFixed(),await this._callback(e,{width:this.video.videoWidth,height:this.video.videoHeight})),Np=e,this.animationID=xp((async()=>await this.animateLegacy()))}async animate(e,t){await this._callback(e,t),this.video.requestVideoFrameCallback(this.animateRef)}initAnimate(){this.animateRef=async(e,t)=>await this.animate(e,t),this.video.requestVideoFrameCallback(this.animateRef)}initLegacyAnimate(){this.animateLegacy()}start(){this.stop(),fp?this.initAnimate():(Np=new Date,this.initLegacyAnimate()),this.running=!0}stop(){this.running=!1,fp?this.animateRef=()=>{}:bp(this.animationID&&this.animationID.data&&this.animationID.data.handleId||this.animationID)}}const vp="requestVideoFrameCallback"in HTMLVideoElement.prototype,Tp=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,_p=window.cancelAnimationFrame||window.mozCancelAnimationFrame;let Sp;class wp{constructor(e,t){this._callback=e,this.video=t,this.animationID=null,this.running=!1,this.updateNodesRef=()=>{}}set nodes(e){this._nodes=e,e&&(this.updateNodesRef=()=>{this._nodes.nodeFrame.update()})}set callback(e){this._callback=e}async animateLegacy(){const e=this.video.currentTime;e>Sp&&((1/(e-Sp)).toFixed(),this.updateNodesRef(),await this._callback(e,{width:this.video.videoWidth,height:this.video.videoHeight})),Sp=e,this.animationID=Tp((async()=>await this.animateLegacy()))}async animate(e,t){this.updateNodesRef(),await this._callback(e,t),this.video.requestVideoFrameCallback(this.animateRef)}initAnimate(){this.animateRef=async(e,t)=>await this.animate(e,t),this.video.requestVideoFrameCallback(this.animateRef)}initLegacyAnimate(){this.animateLegacy()}start(){this.stop(),vp?this.initAnimate():(Sp=new Date,this.initLegacyAnimate()),this.running=!0}stop(){this.running=!1,vp?this.animateRef=()=>{}:_p(this.animationID&&this.animationID.data&&this.animationID.data.handleId||this.animationID)}}export{yp as VideoAnimation,Xt as WebGPU,gp as WebGPURenderer,wp as WebGPUVideoAnimation,ja as equirectUV,io as texture};
