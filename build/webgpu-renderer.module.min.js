/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
import{Plane as e,Matrix3 as t,Vector4 as s,DynamicDrawUsage as r,Uint32BufferAttribute as i,Uint16BufferAttribute as n,Color as o,Vector2 as a,Vector3 as u,Matrix4 as l,EventDispatcher as c,MathUtils as d,LinearSRGBColorSpace as h,SRGBColorSpace as p,StaticDrawUsage as g,InterleavedBuffer as m,InterleavedBufferAttribute as f,InstancedInterleavedBuffer as T,DataArrayTexture as x,FloatType as y,WebGPUCoordinateSystem as b,DepthTexture as N,NearestFilter as _,LessCompare as v,FramebufferTexture as S,LinearMipmapLinearFilter as A,ShaderMaterial as R,NoColorSpace as C,Material as E,WebGLCubeRenderTarget as w,BoxGeometry as M,BackSide as F,NoBlending as B,Mesh as O,Scene as U,LinearFilter as L,CubeCamera as I,RenderTarget as P,Float16BufferAttribute as D,REVISION as V,Object3D as G,HalfFloatType as k,LinearMipMapLinearFilter as z,TangentSpaceNormalMap as $,ObjectSpaceNormalMap as H,NoToneMapping as W,LinearToneMapping as j,ReinhardToneMapping as q,CineonToneMapping as X,ACESFilmicToneMapping as Y,AgXToneMapping as K,OrthographicCamera as Q,BufferGeometry as Z,Float32BufferAttribute as J,PointLight as ee,DirectionalLight as te,SpotLight as se,AmbientLight as re,HemisphereLight as ie,Loader as ne,FileLoader as oe,PointsMaterial as ae,LineBasicMaterial as ue,LineDashedMaterial as le,MeshNormalMaterial as ce,MeshBasicMaterial as de,MeshLambertMaterial as he,MeshPhongMaterial as pe,MeshStandardMaterial as ge,MeshPhysicalMaterial as me,SpriteMaterial as fe,MaterialLoader as Te,ObjectLoader as xe,DepthStencilFormat as ye,DepthFormat as be,UnsignedInt248Type as Ne,UnsignedIntType as _e,UnsignedByteType as ve,EquirectangularReflectionMapping as Se,EquirectangularRefractionMapping as Ae,CubeReflectionMapping as Re,CubeRefractionMapping as Ce,SphereGeometry as Ee,Frustum as we,DoubleSide as Me,FrontSide as Fe,DataTexture as Be,IntType as Oe,RedFormat as Ue,RGFormat as Le,RGBAFormat as Ie,createCanvasElement as Pe,AddEquation as De,SubtractEquation as Ve,ReverseSubtractEquation as Ge,ZeroFactor as ke,OneFactor as ze,SrcColorFactor as $e,SrcAlphaFactor as He,SrcAlphaSaturateFactor as We,DstColorFactor as je,DstAlphaFactor as qe,OneMinusSrcColorFactor as Xe,OneMinusSrcAlphaFactor as Ye,OneMinusDstColorFactor as Ke,OneMinusDstAlphaFactor as Qe,CullFaceNone as Ze,CullFaceBack as Je,CullFaceFront as et,CustomBlending as tt,MultiplyBlending as st,SubtractiveBlending as rt,AdditiveBlending as it,NormalBlending as nt,NotEqualDepth as ot,GreaterDepth as at,GreaterEqualDepth as ut,EqualDepth as lt,LessEqualDepth as ct,LessDepth as dt,AlwaysDepth as ht,NeverDepth as pt,UnsignedShort4444Type as gt,UnsignedShort5551Type as mt,ByteType as ft,ShortType as Tt,UnsignedShortType as xt,AlphaFormat as yt,LuminanceFormat as bt,LuminanceAlphaFormat as Nt,RedIntegerFormat as _t,RGIntegerFormat as vt,RGBAIntegerFormat as St,RGB_S3TC_DXT1_Format as At,RGBA_S3TC_DXT1_Format as Rt,RGBA_S3TC_DXT3_Format as Ct,RGBA_S3TC_DXT5_Format as Et,RGB_PVRTC_4BPPV1_Format as wt,RGB_PVRTC_2BPPV1_Format as Mt,RGBA_PVRTC_4BPPV1_Format as Ft,RGBA_PVRTC_2BPPV1_Format as Bt,RGB_ETC1_Format as Ot,RGB_ETC2_Format as Ut,RGBA_ETC2_EAC_Format as Lt,RGBA_ASTC_4x4_Format as It,RGBA_ASTC_5x4_Format as Pt,RGBA_ASTC_5x5_Format as Dt,RGBA_ASTC_6x5_Format as Vt,RGBA_ASTC_6x6_Format as Gt,RGBA_ASTC_8x5_Format as kt,RGBA_ASTC_8x6_Format as zt,RGBA_ASTC_8x8_Format as $t,RGBA_ASTC_10x5_Format as Ht,RGBA_ASTC_10x6_Format as Wt,RGBA_ASTC_10x8_Format as jt,RGBA_ASTC_10x10_Format as qt,RGBA_ASTC_12x10_Format as Xt,RGBA_ASTC_12x12_Format as Yt,RGBA_BPTC_Format as Kt,RED_RGTC1_Format as Qt,SIGNED_RED_RGTC1_Format as Zt,RED_GREEN_RGTC2_Format as Jt,SIGNED_RED_GREEN_RGTC2_Format as es,RepeatWrapping as ts,ClampToEdgeWrapping as ss,MirroredRepeatWrapping as rs,NearestMipmapNearestFilter as is,NearestMipmapLinearFilter as ns,LinearMipmapNearestFilter as os,NeverCompare as as,AlwaysCompare as us,LessEqualCompare as ls,EqualCompare as cs,GreaterEqualCompare as ds,GreaterCompare as hs,NotEqualCompare as ps,WebGLCoordinateSystem as gs,Texture as ms,CubeTexture as fs,NotEqualStencilFunc as Ts,GreaterStencilFunc as xs,GreaterEqualStencilFunc as ys,EqualStencilFunc as bs,LessEqualStencilFunc as Ns,LessStencilFunc as _s,AlwaysStencilFunc as vs,NeverStencilFunc as Ss,DecrementWrapStencilOp as As,IncrementWrapStencilOp as Rs,DecrementStencilOp as Cs,IncrementStencilOp as Es,InvertStencilOp as ws,ReplaceStencilOp as Ms,ZeroStencilOp as Fs,KeepStencilOp as Bs,MaxEquation as Os,MinEquation as Us}from"three";void 0===self.GPUShaderStage&&(self.GPUShaderStage={VERTEX:1,FRAGMENT:2,COMPUTE:4});let Ls=void 0!==navigator.gpu;"undefined"!=typeof window&&Ls&&(Ls=await navigator.gpu.requestAdapter());class Is{static isAvailable(){return Boolean(Ls)}static getStaticAdapter(){return Ls}static getErrorMessage(){const e=document.createElement("div");return e.id="webgpumessage",e.style.fontFamily="monospace",e.style.fontSize="13px",e.style.fontWeight="normal",e.style.textAlign="center",e.style.background="#fff",e.style.color="#000",e.style.padding="1.5em",e.style.maxWidth="400px",e.style.margin="5em auto 0",e.innerHTML='Your browser does not support <a href="https://gpuweb.github.io/gpuweb/" style="color:blue">WebGPU</a> yet',e}}class Ps{constructor(e,t){this.nodes=e,this.info=t,this.animationLoop=null,this.requestId=null,this._init()}_init(){const e=(t,s)=>{this.requestId=self.requestAnimationFrame(e),this.nodes.nodeFrame.update(),this.info.frame=this.nodes.nodeFrame.frameId,null!==this.animationLoop&&this.animationLoop(t,s)};e()}dispose(){self.cancelAnimationFrame(this.requestId)}setAnimationLoop(e){this.animationLoop=e}}class Ds{constructor(){this.weakMap=new WeakMap}get(e){if(Array.isArray(e)){let t=this.weakMap;for(let s=0;s<e.length;s++)if(t=t.get(e[s]),void 0===t)return;return t.get(e[e.length-1])}return super.get(e)}set(e,t){if(Array.isArray(e)){let s=this.weakMap;for(let t=0;t<e.length;t++){const r=e[t];!1===s.has(r)&&s.set(r,new WeakMap),s=s.get(r)}return s.set(e[e.length-1],t)}return super.set(e,t)}delete(e){if(Array.isArray(e)){let t=this.weakMap;for(let s=0;s<e.length;s++)if(t=t.get(e[s]),void 0===t)return!1;return t.delete(e[e.length-1])}return super.delete(e)}dispose(){this.weakMap.clear()}}const Vs=new e,Gs=new t;let ks=0;class zs{constructor(){this.version=++ks,this.globalClippingCount=0,this.localClippingCount=0,this.localClippingEnabled=!1,this.localClipIntersection=!1,this.planes=[],this.parentVersion=0}projectPlanes(e,t){const s=e.length,r=this.planes;for(let i=0;i<s;i++){Vs.copy(e[i]).applyMatrix4(this.viewMatrix,Gs);const s=r[t+i],n=Vs.normal;s.x=-n.x,s.y=-n.y,s.z=-n.z,s.w=Vs.constant}}updateGlobal(e,t){const r=e.clippingPlanes;this.viewMatrix=t.matrixWorldInverse,Gs.getNormalMatrix(this.viewMatrix);let i=!1;if(Array.isArray(r)&&0!==r.length){const e=r.length;if(e!==this.globalClippingCount){const t=[];for(let r=0;r<e;r++)t.push(new s);this.globalClippingCount=e,this.planes=t,i=!0}this.projectPlanes(r,0)}else 0!==this.globalClippingCount&&(this.globalClippingCount=0,this.planes=[],i=!0);e.localClippingEnabled!==this.localClippingEnabled&&(this.localClippingEnabled=e.localClippingEnabled,i=!0),i&&(this.version=ks++)}update(e,t){let r=!1;if(this!==e&&e.version!==this.parentVersion&&(this.globalClippingCount=t.isShadowNodeMaterial?0:e.globalClippingCount,this.localClippingEnabled=e.localClippingEnabled,this.planes=Array.from(e.planes),this.parentVersion=e.version,this.viewMatrix=e.viewMatrix,r=!0),this.localClippingEnabled){const e=t.clippingPlanes;if(Array.isArray(e)&&0!==e.length){const t=e.length,i=this.planes,n=this.globalClippingCount;if(r||t!==this.localClippingCount){i.length=n+t;for(let e=0;e<t;e++)i[n+e]=new s;this.localClippingCount=t,r=!0}this.projectPlanes(e,n)}else 0!==this.localClippingCount&&(this.localClippingCount=0,r=!0);this.localClipIntersection!==t.clipIntersection&&(this.localClipIntersection=t.clipIntersection,r=!0)}r&&(this.version=ks++)}}let $s=0;class Hs{constructor(e,t,s,r,i,n,o,a,u){this._nodes=e,this._geometries=t,this.id=$s++,this.renderer=s,this.object=r,this.material=i,this.scene=n,this.camera=o,this.lightsNode=a,this.context=u,this.geometry=r.geometry,this.version=i.version,this.attributes=null,this.pipeline=null,this.vertexBuffers=null,this.updateClipping(u.clippingContext),this.clippingContextVersion=this.clippingContext.version,this.initialNodesCacheKey=this.getNodesCacheKey(),this.initialCacheKey=this.getCacheKey(),this._nodeBuilderState=null,this._bindings=null,this.onDispose=null,this.isRenderObject=!0,this.onMaterialDispose=()=>{this.dispose()},this.material.addEventListener("dispose",this.onMaterialDispose)}updateClipping(e){const t=this.material;let s=this.clippingContext;Array.isArray(t.clippingPlanes)?(s!==e&&s||(s=new zs,this.clippingContext=s),s.update(e,t)):this.clippingContext!==e&&(this.clippingContext=e)}clippingNeedsUpdate(){return this.clippingContext.version!==this.clippingContextVersion&&(this.clippingContextVersion=this.clippingContext.version,!0)}getNodeBuilderState(){return this._nodeBuilderState||(this._nodeBuilderState=this._nodes.getForRender(this))}getBindings(){return this._bindings||(this._bindings=this.getNodeBuilderState().createBindings())}getIndex(){return this._geometries.getIndex(this)}getChainArray(){return[this.object,this.material,this.context,this.lightsNode]}getAttributes(){if(null!==this.attributes)return this.attributes;const e=this.getNodeBuilderState().nodeAttributes,t=this.geometry,s=[],r=new Set;for(const i of e){const e=i.node&&i.node.attribute?i.node.attribute:t.getAttribute(i.name);if(void 0===e)continue;s.push(e);const n=e.isInterleavedBufferAttribute?e.data:e;r.add(n)}return this.attributes=s,this.vertexBuffers=Array.from(r.values()),s}getVertexBuffers(){return null===this.vertexBuffers&&this.getAttributes(),this.vertexBuffers}getMaterialCacheKey(){const{object:e,material:t}=this;let s=t.customProgramCacheKey();for(const e in t){if(/^(is[A-Z])|^(visible|version|uuid|name|opacity|userData)$/.test(e))continue;let r=t[e];if(null!==r){const e=typeof r;"number"===e?r=0!==r?"1":"0":"object"===e&&(r="{}")}s+=r+","}return s+=this.clippingContextVersion+",",e.skeleton&&(s+=e.skeleton.bones.length+","),e.morphTargetInfluences&&(s+=e.morphTargetInfluences.length+","),s}get needsUpdate(){return this.initialNodesCacheKey!==this.getNodesCacheKey()}getNodesCacheKey(){return this._nodes.getCacheKey(this.scene,this.lightsNode)}getCacheKey(){return this.getMaterialCacheKey()+","+this.getNodesCacheKey()}dispose(){this.material.removeEventListener("dispose",this.onMaterialDispose),this.onDispose()}}class Ws{constructor(e,t,s,r,i,n){this.renderer=e,this.nodes=t,this.geometries=s,this.pipelines=r,this.bindings=i,this.info=n,this.chainMaps={}}get(e,t,s,r,i,n,o){const a=this.getChainMap(o),u=[e,t,n,i];let l=a.get(u);return void 0===l?(l=this.createRenderObject(this.nodes,this.geometries,this.renderer,e,t,s,r,i,n,o),a.set(u,l)):(l.updateClipping(n.clippingContext),(l.version!==t.version||l.needsUpdate||l.clippingNeedsUpdate())&&(l.initialCacheKey!==l.getCacheKey()?(l.dispose(),l=this.get(e,t,s,r,i,n,o)):l.version=t.version)),l}getChainMap(e="default"){return this.chainMaps[e]||(this.chainMaps[e]=new Ds)}dispose(){this.chainMaps={}}createRenderObject(e,t,s,r,i,n,o,a,u,l){const c=this.getChainMap(l),d=new Hs(e,t,s,r,i,n,o,a,u);return d.onDispose=()=>{this.pipelines.delete(d),this.bindings.delete(d),this.nodes.delete(d),c.delete(d.getChainArray())},d}}class js{constructor(){this.data=new WeakMap}get(e){let t=this.data.get(e);return void 0===t&&(t={},this.data.set(e,t)),t}delete(e){let t;return this.data.has(e)&&(t=this.data.get(e),this.data.delete(e)),t}has(e){return this.data.has(e)}dispose(){this.data=new WeakMap}}const qs=1,Xs=2,Ys=4,Ks=16;class Qs extends js{constructor(e){super(),this.backend=e}delete(e){void 0!==super.delete(e)&&this.backend.destroyAttribute(e)}update(e,t){const s=this.get(e);if(void 0===s.version)t===qs?this.backend.createAttribute(e):t===Xs?this.backend.createIndexAttribute(e):t===Ys&&this.backend.createStorageAttribute(e),s.version=this._getBufferAttribute(e).version;else{const t=this._getBufferAttribute(e);(s.version<t.version||t.usage===r)&&(this.backend.updateAttribute(e),s.version=t.version)}}_getBufferAttribute(e){return e.isInterleavedBufferAttribute&&(e=e.data),e}}function Zs(e){return null!==e.index?e.index.version:e.attributes.position.version}function Js(e){const t=[],s=e.index,r=e.attributes.position;if(null!==s){const e=s.array;for(let s=0,r=e.length;s<r;s+=3){const r=e[s+0],i=e[s+1],n=e[s+2];t.push(r,i,i,n,n,r)}}else{for(let e=0,s=r.array.length/3-1;e<s;e+=3){const s=e+0,r=e+1,i=e+2;t.push(s,r,r,i,i,s)}}const o=new(function(e){for(let t=e.length-1;t>=0;--t)if(e[t]>=65535)return!0;return!1}(t)?i:n)(t,1);return o.version=Zs(e),o}class er extends js{constructor(e,t){super(),this.attributes=e,this.info=t,this.wireframes=new WeakMap,this.attributeCall=new WeakMap}has(e){const t=e.geometry;return super.has(t)&&!0===this.get(t).initialized}updateForRender(e){!1===this.has(e)&&this.initGeometry(e),this.updateAttributes(e)}initGeometry(e){const t=e.geometry;this.get(t).initialized=!0,this.info.memory.geometries++;const s=()=>{this.info.memory.geometries--;const r=t.index,i=e.getAttributes();null!==r&&this.attributes.delete(r);for(const e of i)this.attributes.delete(e);const n=this.wireframes.get(t);void 0!==n&&this.attributes.delete(n),t.removeEventListener("dispose",s)};t.addEventListener("dispose",s)}updateAttributes(e){const t=e.getAttributes();for(const e of t)this.updateAttribute(e,qs);const s=this.getIndex(e);null!==s&&this.updateAttribute(s,Xs)}updateAttribute(e,t){const s=this.info.render.calls;this.attributeCall.get(e)!==s&&(this.attributes.update(e,t),this.attributeCall.set(e,s))}getIndex(e){const{geometry:t,material:s}=e;let r=t.index;if(!0===s.wireframe){const e=this.wireframes;let s=e.get(t);void 0===s?(s=Js(t),e.set(t,s)):s.version!==Zs(t)&&(this.attributes.delete(s),s=Js(t),e.set(t,s)),r=s}return r}}class tr{constructor(){this.autoReset=!0,this.frame=0,this.calls=0,this.render={calls:0,drawCalls:0,triangles:0,points:0,lines:0},this.compute={calls:0,computeCalls:0},this.memory={geometries:0,textures:0},this.timestamp={compute:0,render:0}}update(e,t,s){this.render.drawCalls++,e.isMesh||e.isSprite?this.render.triangles+=s*(t/3):e.isPoints?this.render.points+=s*t:e.isLineSegments?this.render.lines+=s*(t/2):e.isLine&&(this.render.lines+=s*(t-1))}updateTimestamp(e,t){this.timestamp[e]+=t}resetCompute(){this.compute.computeCalls=0,this.timestamp.compute=0}reset(){this.render.drawCalls=0,this.render.triangles=0,this.render.points=0,this.render.lines=0,this.timestamp.render=0}dispose(){this.reset(),this.calls=0,this.render.calls=0,this.compute.calls=0,this.timestamp.compute=0,this.timestamp.render=0,this.memory.geometries=0,this.memory.textures=0}}class sr{constructor(e){this.cacheKey=e,this.usedTimes=0}}class rr extends sr{constructor(e,t,s){super(e),this.vertexProgram=t,this.fragmentProgram=s}}class ir extends sr{constructor(e,t){super(e),this.computeProgram=t,this.isComputePipeline=!0}}let nr=0;class or{constructor(e,t,s=null,r=null){this.id=nr++,this.code=e,this.stage=t,this.transforms=s,this.attributes=r,this.usedTimes=0}}class ar extends js{constructor(e,t){super(),this.backend=e,this.nodes=t,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(e,t){const{backend:s}=this,r=this.get(e);if(this._needsComputeUpdate(e)){const i=r.pipeline;i&&(i.usedTimes--,i.computeProgram.usedTimes--);const n=this.nodes.getForCompute(e);let o=this.programs.compute.get(n.computeShader);void 0===o&&(i&&0===i.computeProgram.usedTimes&&this._releaseProgram(i.computeProgram),o=new or(n.computeShader,"compute",n.transforms,n.nodeAttributes),this.programs.compute.set(n.computeShader,o),s.createProgram(o));const a=this._getComputeCacheKey(e,o);let u=this.caches.get(a);void 0===u&&(i&&0===i.usedTimes&&this._releasePipeline(e),u=this._getComputePipeline(e,o,a,t)),u.usedTimes++,o.usedTimes++,r.version=e.version,r.pipeline=u}return r.pipeline}getForRender(e,t=null){const{backend:s}=this,r=this.get(e);if(this._needsRenderUpdate(e)){const i=r.pipeline;i&&(i.usedTimes--,i.vertexProgram.usedTimes--,i.fragmentProgram.usedTimes--);const n=e.getNodeBuilderState();let o=this.programs.vertex.get(n.vertexShader);void 0===o&&(i&&0===i.vertexProgram.usedTimes&&this._releaseProgram(i.vertexProgram),o=new or(n.vertexShader,"vertex"),this.programs.vertex.set(n.vertexShader,o),s.createProgram(o));let a=this.programs.fragment.get(n.fragmentShader);void 0===a&&(i&&0===i.fragmentProgram.usedTimes&&this._releaseProgram(i.fragmentProgram),a=new or(n.fragmentShader,"fragment"),this.programs.fragment.set(n.fragmentShader,a),s.createProgram(a));const u=this._getRenderCacheKey(e,o,a);let l=this.caches.get(u);void 0===l?(i&&0===i.usedTimes&&this._releasePipeline(i),l=this._getRenderPipeline(e,o,a,u,t)):e.pipeline=l,l.usedTimes++,o.usedTimes++,a.usedTimes++,r.pipeline=l}return r.pipeline}delete(e){const t=this.get(e).pipeline;t&&(t.usedTimes--,0===t.usedTimes&&this._releasePipeline(t),t.isComputePipeline?(t.computeProgram.usedTimes--,0===t.computeProgram.usedTimes&&this._releaseProgram(t.computeProgram)):(t.fragmentProgram.usedTimes--,t.vertexProgram.usedTimes--,0===t.vertexProgram.usedTimes&&this._releaseProgram(t.vertexProgram),0===t.fragmentProgram.usedTimes&&this._releaseProgram(t.fragmentProgram))),super.delete(e)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}updateForRender(e){this.getForRender(e)}_getComputePipeline(e,t,s,r){s=s||this._getComputeCacheKey(e,t);let i=this.caches.get(s);return void 0===i&&(i=new ir(s,t),this.caches.set(s,i),this.backend.createComputePipeline(i,r)),i}_getRenderPipeline(e,t,s,r,i){r=r||this._getRenderCacheKey(e,t,s);let n=this.caches.get(r);return void 0===n&&(n=new rr(r,t,s),this.caches.set(r,n),e.pipeline=n,this.backend.createRenderPipeline(e,i)),n}_getComputeCacheKey(e,t){return e.id+","+t.id}_getRenderCacheKey(e,t,s){return t.id+","+s.id+","+this.backend.getRenderCacheKey(e)}_releasePipeline(e){this.caches.delete(e.cacheKey)}_releaseProgram(e){const t=e.code,s=e.stage;this.programs[s].delete(t)}_needsComputeUpdate(e){const t=this.get(e);return void 0===t.pipeline||t.version!==e.version}_needsRenderUpdate(e){return void 0===this.get(e).pipeline||this.backend.needsRenderUpdate(e)}}class ur extends js{constructor(e,t,s,r,i,n){super(),this.backend=e,this.textures=s,this.pipelines=i,this.attributes=r,this.nodes=t,this.info=n,this.pipelines.bindings=this}getForRender(e){const t=e.getBindings(),s=this.get(e);return s.bindings!==t&&(s.bindings=t,this._init(t),this.backend.createBindings(t)),s.bindings}getForCompute(e){const t=this.get(e);if(void 0===t.bindings){const s=this.nodes.getForCompute(e).bindings;t.bindings=s,this._init(s),this.backend.createBindings(s)}return t.bindings}updateForCompute(e){this._update(e,this.getForCompute(e))}updateForRender(e){this._update(e,this.getForRender(e))}_init(e){for(const t of e)if(t.isSampledTexture)this.textures.updateTexture(t.texture);else if(t.isStorageBuffer){const e=t.attribute;this.attributes.update(e,Ys)}}_update(e,t){const{backend:s}=this;let r=!1;for(const e of t){if(e.isNodeUniformsGroup){if(!this.nodes.updateGroup(e))continue}if(e.isUniformBuffer){e.update()&&s.updateBinding(e)}else if(e.isSampledTexture){const t=e.texture;e.needsBindingsUpdate&&(r=!0);if(e.update()&&this.textures.updateTexture(e.texture),!0===t.isStorageTexture){const s=this.get(t);!0===e.store?s.needsMipmap=!0:!0===t.generateMipmaps&&this.textures.needsMipmaps(t)&&!0===s.needsMipmap&&(this.backend.generateMipmaps(t),s.needsMipmap=!1)}}}if(!0===r){const s=this.pipelines.getForRender(e);this.backend.updateBindings(t,s)}}}const lr={VERTEX:"vertex",FRAGMENT:"fragment"},cr={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},dr={BOOLEAN:"bool",INTEGER:"int",FLOAT:"float",VECTOR2:"vec2",VECTOR3:"vec3",VECTOR4:"vec4",MATRIX2:"mat2",MATRIX3:"mat3",MATRIX4:"mat4"},hr=["fragment","vertex"],pr=["setup","analyze","generate"],gr=[...hr,"compute"],mr=["x","y","z","w"];function fr(e){let t="{";!0===e.isNode&&(t+=e.id);for(const{property:s,childNode:r}of Tr(e))t+=","+s.slice(0,-4)+":"+r.getCacheKey();return t+="}",t}function*Tr(e,t=!1){for(const s in e){if(!0===s.startsWith("_"))continue;const r=e[s];if(!0===Array.isArray(r))for(let e=0;e<r.length;e++){const i=r[e];i&&(!0===i.isNode||t&&"function"==typeof i.toJSON)&&(yield{property:s,index:e,childNode:i})}else if(r&&!0===r.isNode)yield{property:s,childNode:r};else if("object"==typeof r)for(const e in r){const i=r[e];i&&(!0===i.isNode||t&&"function"==typeof i.toJSON)&&(yield{property:s,index:e,childNode:i})}}}function xr(e){if(null==e)return null;const t=typeof e;return!0===e.isNode?"node":"number"===t?"float":"boolean"===t?"bool":"string"===t?"string":"function"===t?"shader":!0===e.isVector2?"vec2":!0===e.isVector3?"vec3":!0===e.isVector4?"vec4":!0===e.isMatrix3?"mat3":!0===e.isMatrix4?"mat4":!0===e.isColor?"color":e instanceof ArrayBuffer?"ArrayBuffer":null}function yr(e,...r){const i=e?e.slice(-4):void 0;return 1===r.length&&("vec2"===i?r=[r[0],r[0]]:"vec3"===i?r=[r[0],r[0],r[0]]:"vec4"===i&&(r=[r[0],r[0],r[0],r[0]])),"color"===e?new o(...r):"vec2"===i?new a(...r):"vec3"===i?new u(...r):"vec4"===i?new s(...r):"mat3"===i?new t(...r):"mat4"===i?new l(...r):"bool"===e?r[0]||!1:"float"===e||"int"===e||"uint"===e?r[0]||0:"string"===e?r[0]||"":"ArrayBuffer"===e?Nr(r[0]):null}function br(e){let t="";const s=new Uint8Array(e);for(let e=0;e<s.length;e++)t+=String.fromCharCode(s[e]);return btoa(t)}function Nr(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0))).buffer}var _r=Object.freeze({__proto__:null,getCacheKey:fr,getNodeChildren:Tr,getValueType:xr,getValueFromType:yr,arrayBufferToBase64:br,base64ToArrayBuffer:Nr});const vr=new Map;let Sr=0;class Ar extends c{constructor(e=null){super(),this.nodeType=e,this.updateType=cr.NONE,this.updateBeforeType=cr.NONE,this.uuid=d.generateUUID(),this.isNode=!0,Object.defineProperty(this,"id",{value:Sr++})}get type(){return this.constructor.type}getSelf(){return this.self||this}setReference(){return this}isGlobal(){return!1}*getChildren(){for(const{childNode:e}of Tr(this))yield e}dispose(){this.dispatchEvent({type:"dispose"})}traverse(e){e(this);for(const t of this.getChildren())t.traverse(e)}getCacheKey(){return fr(this)}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getNodeType(e){const t=e.getNodeProperties(this);return t.outputNode?t.outputNode.getNodeType(e):this.nodeType}getShared(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}setup(e){const t=e.getNodeProperties(this);for(const e of this.getChildren())t["_node"+e.id]=e;return null}construct(e){return this.setup(e)}increaseUsage(e){const t=e.getDataFromNode(this);return t.usageCount=void 0===t.usageCount?1:t.usageCount+1,t.usageCount}analyze(e){if(1===this.increaseUsage(e)){const t=e.getNodeProperties(this);for(const s of Object.values(t))s&&!0===s.isNode&&s.build(e)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&!0===s.isNode)return s.build(e,t)}updateBefore(){}update(){}build(e,t=null){const s=this.getShared(e);if(this!==s)return s.build(e,t);e.addNode(this),e.addChain(this);let r=null;const i=e.getBuildStage();if("setup"===i){this.setReference(e);const t=e.getNodeProperties(this);if(!0!==t.initialized||!1===e.context.tempRead){const s=e.stack.nodes.length;t.initialized=!0,t.outputNode=this.setup(e),null!==t.outputNode&&e.stack.nodes.length!==s&&(t.outputNode=e.stack);for(const s of Object.values(t))s&&!0===s.isNode&&s.build(e)}}else if("analyze"===i)this.analyze(e);else if("generate"===i){if(1===this.generate.length){const s=this.getNodeType(e),i=e.getDataFromNode(this);r=i.snippet,void 0===r&&(r=this.generate(e)||"",i.snippet=r),r=e.format(r,s,t)}else r=this.generate(e,t)||""}return e.removeChain(this),r}getSerializeChildren(){return Tr(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:r,index:i,childNode:n}of t)void 0!==i?(void 0===s[r]&&(s[r]=Number.isInteger(i)?[]:{}),s[r][i]=n.toJSON(e.meta).uuid):s[r]=n.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(void 0!==e.inputNodes){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const r=[];for(const i of e.inputNodes[s])r.push(t[i]);this[s]=r}else if("object"==typeof e.inputNodes[s]){const r={};for(const i in e.inputNodes[s]){const n=e.inputNodes[s][i];r[i]=t[n]}this[s]=r}else{const r=e.inputNodes[s];this[s]=t[r]}}}toJSON(e){const{uuid:t,type:s}=this,r=void 0===e||"string"==typeof e;r&&(e={textures:{},images:{},nodes:{}});let i=e.nodes[t];function n(e){const t=[];for(const s in e){const r=e[s];delete r.metadata,t.push(r)}return t}if(void 0===i&&(i={uuid:t,type:s,meta:e,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},!0!==r&&(e.nodes[i.uuid]=i),this.serialize(i),delete i.meta),r){const t=n(e.textures),s=n(e.images),r=n(e.nodes);t.length>0&&(i.textures=t),s.length>0&&(i.images=s),r.length>0&&(i.nodes=r)}return i}}function Rr(e,t){if("function"!=typeof t||!e)throw new Error(`Node class ${e} is not a class`);vr.has(e)||(vr.set(e,t),t.type=e)}function Cr(e){const t=vr.get(e);if(void 0!==t)return new t}class Er extends Ar{constructor(e){super(e),this.isTempNode=!0}hasDependencies(e){return e.getDataFromNode(this).usageCount>1}build(e,t){if("generate"===e.getBuildStage()){const s=e.getVectorType(this.getNodeType(e,t)),r=e.getDataFromNode(this);if(!1!==e.context.tempRead&&void 0!==r.propertyName)return e.format(r.propertyName,s,t);if(!1!==e.context.tempWrite&&"void"!==s&&"void"!==t&&this.hasDependencies(e)){const i=super.build(e,s),n=e.getVarFromNode(this,null,s),o=e.getPropertyName(n);return e.addLineFlowCode(`${o} = ${i}`),r.snippet=i,r.propertyName=o,e.format(r.propertyName,s,t)}}return super.build(e,t)}}Rr("TempNode",Er);class wr extends Ar{constructor(e,t){super(),this.node=e,this.indexNode=t,this.isArrayElementNode=!0}getNodeType(e){return this.node.getNodeType(e)}generate(e){return`${this.node.build(e)}[ ${this.indexNode.build(e,"uint")} ]`}}Rr("ArrayElementNode",wr);class Mr extends Ar{constructor(e,t){super(),this.node=e,this.convertTo=t}getNodeType(e){const t=this.node.getNodeType(e);let s=null;for(const r of this.convertTo.split("|"))null!==s&&e.getTypeLength(t)!==e.getTypeLength(r)||(s=r);return s}serialize(e){super.serialize(e),e.convertTo=this.convertTo}deserialize(e){super.deserialize(e),this.convertTo=e.convertTo}generate(e,t){const s=this.node,r=this.getNodeType(e),i=s.build(e,r);return e.format(i,r,t)}}Rr("ConvertNode",Mr);class Fr extends Er{constructor(e=[],t=null){super(t),this.nodes=e}getNodeType(e){return null!==this.nodeType?e.getVectorType(this.nodeType):e.getTypeFromLength(this.nodes.reduce(((t,s)=>t+e.getTypeLength(s.getNodeType(e))),0))}generate(e,t){const s=this.getNodeType(e),r=this.nodes,i=e.getComponentType(s),n=[];for(const t of r){let s=t.build(e);const r=e.getComponentType(t.getNodeType(e));r!==i&&(s=e.format(s,r,i)),n.push(s)}const o=`${e.getType(s)}( ${n.join(", ")} )`;return e.format(o,s,t)}}Rr("JoinNode",Fr);const Br=mr.join("");class Or extends Ar{constructor(e,t="x"){super(),this.node=e,this.components=t,this.isSplitNode=!0}getVectorLength(){let e=this.components.length;for(const t of this.components)e=Math.max(mr.indexOf(t)+1,e);return e}getComponentType(e){return e.getComponentType(this.node.getNodeType(e))}getNodeType(e){return e.getTypeFromLength(this.components.length,this.getComponentType(e))}generate(e,t){const s=this.node,r=e.getTypeLength(s.getNodeType(e));let i=null;if(r>1){let n=null;this.getVectorLength()>=r&&(n=e.getTypeFromLength(this.getVectorLength(),this.getComponentType(e)));const o=s.build(e,n);i=this.components.length===r&&this.components===Br.slice(0,this.components.length)?e.format(o,n,t):e.format(`${o}.${this.components}`,this.getNodeType(e),t)}else i=s.build(e,t);return i}serialize(e){super.serialize(e),e.components=this.components}deserialize(e){super.deserialize(e),this.components=e.components}}Rr("SplitNode",Or);class Ur extends Er{constructor(e,t,s){super(),this.sourceNode=e,this.components=t,this.targetNode=s}getNodeType(e){return this.sourceNode.getNodeType(e)}generate(e){const{sourceNode:t,components:s,targetNode:r}=this,i=this.getNodeType(e),n=e.getTypeFromLength(s.length),o=r.build(e,n),a=t.build(e,i),u=e.getTypeLength(i),l=[];for(let e=0;e<u;e++){const t=mr[e];t===s[0]?(l.push(o),e+=s.length-1):l.push(a+"."+t)}return`${e.getType(i)}( ${l.join(", ")} )`}}Rr("SetNode",Ur);class Lr extends Ar{constructor(e,t=null){super(t),this.isInputNode=!0,this.value=e,this.precision=null}getNodeType(){return null===this.nodeType?xr(this.value):this.nodeType}getInputType(e){return this.getNodeType(e)}setPrecision(e){return this.precision=e,this}serialize(e){super.serialize(e),e.value=this.value,this.value&&this.value.toArray&&(e.value=this.value.toArray()),e.valueType=xr(this.value),e.nodeType=this.nodeType,"ArrayBuffer"===e.valueType&&(e.value=br(e.value)),e.precision=this.precision}deserialize(e){super.deserialize(e),this.nodeType=e.nodeType,this.value=Array.isArray(e.value)?yr(e.valueType,...e.value):e.value,this.precision=e.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(e.value))}generate(){}}Rr("InputNode",Lr);class Ir extends Lr{constructor(e,t=null){super(e,t),this.isConstNode=!0}generateConst(e){return e.generateConst(this.getNodeType(e),this.value)}generate(e,t){const s=this.getNodeType(e);return e.format(this.generateConst(e),s,t)}}Rr("ConstNode",Ir);let Pr=null;const Dr=new Map;function Vr(e,t){if(!Dr.has(e)){if("function"!=typeof t)throw new Error(`Node element ${e} is not a function`);Dr.set(e,t)}}const Gr=e=>e.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),kr={setup(e,t){const s=t.shift();return e(di(s),...t)},get(e,t,s){if("string"==typeof t&&void 0===e[t]){if(!0!==e.isStackNode&&"assign"===t)return(...e)=>(Pr.assign(s,...e),s);if(Dr.has(t)){const r=Dr.get(t);return e.isStackNode?(...e)=>s.add(r(...e)):(...e)=>r(s,...e)}if("self"===t)return e;if(t.endsWith("Assign")&&Dr.has(t.slice(0,t.length-6))){const r=Dr.get(t.slice(0,t.length-6));return e.isStackNode?(...e)=>s.assign(e[0],r(...e)):(...e)=>s.assign(r(s,...e))}if(!0===/^[xyzwrgbastpq]{1,4}$/.test(t))return t=Gr(t),ci(new Or(s,t));if(!0===/^set[XYZWRGBASTPQ]{1,4}$/.test(t))return t=(t=Gr(t.slice(3).toLowerCase())).split("").sort().join(""),s=>ci(new Ur(e,t,s));if("width"===t||"height"===t||"depth"===t)return"width"===t?t="x":"height"===t?t="y":"depth"===t&&(t="z"),ci(new Or(e,t));if(!0===/^\d+$/.test(t))return ci(new wr(s,new Ir(Number(t),"uint")))}return Reflect.get(e,t,s)},set:(e,t,s,r)=>"string"!=typeof t||void 0!==e[t]||!0!==/^[xyzwrgbastpq]{1,4}$/.test(t)&&"width"!==t&&"height"!==t&&"depth"!==t&&!0!==/^\d+$/.test(t)?Reflect.set(e,t,s,r):(r[t].assign(s),!0)},zr=new WeakMap,$r=new WeakMap,Hr=function(e,t=null){for(const s in e)e[s]=ci(e[s],t);return e},Wr=function(e,t=null){const s=e.length;for(let r=0;r<s;r++)e[r]=ci(e[r],t);return e},jr=function(e,t=null,s=null,r=null){const i=e=>ci(null!==r?Object.assign(e,r):e);return null===t?(...t)=>i(new e(...hi(t))):null!==s?(s=ci(s),(...r)=>i(new e(t,...hi(r),s))):(...s)=>i(new e(t,...hi(s)))},qr=function(e,...t){return ci(new e(...hi(t)))};class Xr extends Ar{constructor(e,t){super(),this.shaderNode=e,this.inputNodes=t}getNodeType(e){const{outputNode:t}=e.getNodeProperties(this);return t?t.getNodeType(e):super.getNodeType(e)}call(e){const{shaderNode:t,inputNodes:s}=this;if(t.layout){let r=$r.get(e.constructor);void 0===r&&(r=new WeakMap,$r.set(e.constructor,r));let i=r.get(t);return void 0===i&&(i=ci(e.buildFunctionNode(t)),r.set(t,i)),null!==e.currentFunctionNode&&e.currentFunctionNode.includes.push(i),ci(i.call(s))}const r=t.jsFunc,i=null!==s?r(s,e.stack,e):r(e.stack,e);return ci(i)}setup(e){return e.addStack(),e.stack.outputNode=this.call(e),e.removeStack()}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);return null===s?this.call(e).build(e,t):super.generate(e,t)}}class Yr extends Ar{constructor(e){super(),this.jsFunc=e,this.layout=null}get isArrayInput(){return/^\((\s+)?\[/.test(this.jsFunc.toString())}setLayout(e){return this.layout=e,this}call(e=null){return di(e),ci(new Xr(this,e))}setup(){return this.call()}}const Kr=[!1,!0],Qr=[0,1,2,3],Zr=[-1,-2],Jr=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],ei=new Map;for(const e of Kr)ei.set(e,new Ir(e));const ti=new Map;for(const e of Qr)ti.set(e,new Ir(e,"uint"));const si=new Map([...ti].map((e=>new Ir(e.value,"int"))));for(const e of Zr)si.set(e,new Ir(e,"int"));const ri=new Map([...si].map((e=>new Ir(e.value))));for(const e of Jr)ri.set(e,new Ir(e));for(const e of Jr)ri.set(-e,new Ir(-e));const ii={bool:ei,uint:ti,ints:si,float:ri},ni=new Map([...ei,...ri]),oi=(e,t)=>ni.has(e)?ni.get(e):!0===e.isNode?e:new Ir(e,t),ai=function(e,t=null){return(...s)=>{if((0===s.length||!["bool","float","int","uint"].includes(e)&&s.every((e=>"object"!=typeof e)))&&(s=[yr(e,...s)]),1===s.length&&null!==t&&t.has(s[0]))return ci(t.get(s[0]));if(1===s.length){const t=oi(s[0],e);return(e=>{try{return e.getNodeType()}catch(e){return}})(t)===e?ci(t):ci(new Mr(t,e))}const r=s.map((e=>oi(e)));return ci(new Fr(r,e))}},ui=e=>null!=e?e.nodeType||e.convertTo||("string"==typeof e?e:null):null;function li(e){return new Proxy(new Yr(e),kr)}const ci=(e,t=null)=>function(e,t=null){const s=xr(e);if("node"===s){let t=zr.get(e);return void 0===t&&(t=new Proxy(e,kr),zr.set(e,t),zr.set(t,t)),t}return null===t&&("float"===s||"boolean"===s)||s&&"shader"!==s&&"string"!==s?ci(oi(e,t)):"shader"===s?fi(e):e}(e,t),di=(e,t=null)=>new Hr(e,t),hi=(e,t=null)=>new Wr(e,t),pi=(...e)=>new jr(...e),gi=(...e)=>new qr(...e),mi=e=>new li(e),fi=e=>{const t=new li(e),s=(...e)=>{let s;return di(e),s=e[0]&&e[0].isNode?[...e]:e[0],t.call(s)};return s.shaderNode=t,s.setLayout=e=>(t.setLayout(e),s),s};Rr("ShaderNode",li);const Ti=e=>{Pr=e},xi=()=>Pr,yi=(...e)=>Pr.if(...e);function bi(e){return Pr&&Pr.add(e),e}Vr("append",bi);const Ni=new ai("color"),_i=new ai("float",ii.float),vi=new ai("int",ii.int),Si=new ai("uint",ii.uint),Ai=new ai("bool",ii.bool),Ri=new ai("vec2"),Ci=new ai("ivec2"),Ei=new ai("uvec2"),wi=new ai("bvec2"),Mi=new ai("vec3"),Fi=new ai("ivec3"),Bi=new ai("uvec3"),Oi=new ai("bvec3"),Ui=new ai("vec4"),Li=new ai("ivec4"),Ii=new ai("uvec4"),Pi=new ai("bvec4"),Di=new ai("mat2"),Vi=new ai("imat2"),Gi=new ai("umat2"),ki=new ai("bmat2"),zi=new ai("mat3"),$i=new ai("imat3"),Hi=new ai("umat3"),Wi=new ai("bmat3"),ji=new ai("mat4"),qi=new ai("imat4"),Xi=new ai("umat4"),Yi=new ai("bmat4"),Ki=(e="")=>ci(new Ir(e,"string")),Qi=e=>ci(new Ir(e,"ArrayBuffer"));Vr("color",Ni),Vr("float",_i),Vr("int",vi),Vr("uint",Si),Vr("bool",Ai),Vr("vec2",Ri),Vr("ivec2",Ci),Vr("uvec2",Ei),Vr("bvec2",wi),Vr("vec3",Mi),Vr("ivec3",Fi),Vr("uvec3",Bi),Vr("bvec3",Oi),Vr("vec4",Ui),Vr("ivec4",Li),Vr("uvec4",Ii),Vr("bvec4",Pi),Vr("mat2",Di),Vr("imat2",Vi),Vr("umat2",Gi),Vr("bmat2",ki),Vr("mat3",zi),Vr("imat3",$i),Vr("umat3",Hi),Vr("bmat3",Wi),Vr("mat4",ji),Vr("imat4",qi),Vr("umat4",Xi),Vr("bmat4",Yi),Vr("string",Ki),Vr("arrayBuffer",Qi);const Zi=pi(wr),Ji=(e,t)=>ci(new Mr(ci(e),t)),en=(e,t)=>ci(new Or(ci(e),t));Vr("element",Zi),Vr("convert",Ji);class tn extends Er{constructor(e,t){super(),this.targetNode=e,this.sourceNode=t}hasDependencies(){return!1}getNodeType(e,t){return"void"!==t?this.targetNode.getNodeType(e):"void"}needsSplitAssign(e){const{targetNode:t}=this;if(!1===e.isAvailable("swizzleAssign")&&t.isSplitNode&&t.components.length>1){const s=e.getTypeLength(t.node.getNodeType(e));return mr.join("").slice(0,s)!==t.components}return!1}generate(e,t){const{targetNode:s,sourceNode:r}=this,i=this.needsSplitAssign(e),n=s.getNodeType(e),o=s.context({assign:!0}).build(e),a=r.build(e,n),u=r.getNodeType(e),l=e.getDataFromNode(this);let c;if(!0===l.initialized)"void"!==t&&(c=o);else if(i){const r=e.getVarFromNode(this,null,n),i=e.getPropertyName(r);e.addLineFlowCode(`${i} = ${a}`);const u=s.node.context({assign:!0}).build(e);for(let t=0;t<s.components.length;t++){const r=s.components[t];e.addLineFlowCode(`${u}.${r} = ${i}[ ${t} ]`)}"void"!==t&&(c=o)}else c=`${o} = ${a}`,"void"!==t&&"void"!==u||(e.addLineFlowCode(c),"void"!==t&&(c=o));return l.initialized=!0,e.format(c,n,t)}}const sn=pi(tn);Rr("AssignNode",tn),Vr("assign",sn);class rn extends Ar{constructor(e,t=null){super(),this.node=e,this.name=t,this.isVaryingNode=!0}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{name:t,node:s}=this,r=this.getNodeType(e),i=e.getVaryingFromNode(this,t,r);i.needsInterpolation||(i.needsInterpolation="fragment"===e.shaderStage);const n=e.getPropertyName(i,lr.VERTEX);return e.flowNodeFromShaderStage(lr.VERTEX,s,r,n),e.getPropertyName(i)}}const nn=pi(rn);Vr("varying",nn),Rr("VaryingNode",rn);class on extends Ar{constructor(e,t=null){super(t),this._attributeName=e}isGlobal(){return!0}getHash(e){return this.getAttributeName(e)}getNodeType(e){let t=super.getNodeType(e);if(null===t){const s=this.getAttributeName(e);if(e.hasGeometryAttribute(s)){const r=e.geometry.getAttribute(s);t=e.getTypeFromAttribute(r)}else t="float"}return t}setAttributeName(e){return this._attributeName=e,this}getAttributeName(){return this._attributeName}generate(e){const t=this.getAttributeName(e),s=this.getNodeType(e);if(!0===e.hasGeometryAttribute(t)){const r=e.geometry.getAttribute(t),i=e.getTypeFromAttribute(r),n=e.getAttribute(t,i);if("vertex"===e.shaderStage)return e.format(n.name,i,s);return nn(this).build(e,s)}return e.generateConst(s)}}const an=(e,t)=>ci(new on(e,t));Rr("AttributeNode",on);class un extends Ar{constructor(e,t){super(),this.isBypassNode=!0,this.outputNode=e,this.callNode=t}getNodeType(e){return this.outputNode.getNodeType(e)}generate(e){const t=this.callNode.build(e,"void");return""!==t&&e.addLineFlowCode(t),this.outputNode.build(e)}}const ln=pi(un);Vr("bypass",ln),Rr("BypassNode",un);let cn=0;class dn{constructor(){this.id=cn++,this.nodesData=new WeakMap}getNodeData(e){return this.nodesData.get(e)}setNodeData(e,t){this.nodesData.set(e,t)}}class hn extends Ar{constructor(e,t=new dn){super(),this.isCacheNode=!0,this.node=e,this.cache=t}getNodeType(e){return this.node.getNodeType(e)}build(e,...t){const s=e.getCache(),r=this.cache||e.globalCache;e.setCache(r);const i=this.node.build(e,...t);return e.setCache(s),i}}const pn=pi(hn);Vr("cache",pn),Vr("globalCache",(e=>pn(e,null))),Rr("CacheNode",hn);class gn extends Ar{constructor(e,t={}){super(),this.isContextNode=!0,this.node=e,this.context=t}getNodeType(e){return this.node.getNodeType(e)}setup(e){const t=e.getContext();e.setContext({...e.context,...this.context});const s=this.node.build(e);return e.setContext(t),s}generate(e,t){const s=e.getContext();e.setContext({...e.context,...this.context});const r=this.node.build(e,t);return e.setContext(s),r}}const mn=pi(gn),fn=(e,t)=>mn(e,{label:t});Vr("context",mn),Vr("label",fn),Rr("ContextNode",gn);class Tn extends Ar{constructor(e){super("uint"),this.scope=e,this.isInstanceIndexNode=!0}generate(e){const t=this.getNodeType(e),s=this.scope;let r,i;if(s===Tn.VERTEX)r=e.getVertexIndex();else{if(s!==Tn.INSTANCE)throw new Error("THREE.IndexNode: Unknown scope: "+s);r=e.getInstanceIndex()}if("vertex"===e.shaderStage||"compute"===e.shaderStage)i=r;else{i=nn(this).build(e,t)}return i}}Tn.VERTEX="vertex",Tn.INSTANCE="instance";const xn=gi(Tn,Tn.VERTEX),yn=gi(Tn,Tn.INSTANCE);Rr("IndexNode",Tn);class bn{start(){}finish(){}direct(){}indirectDiffuse(){}indirectSpecular(){}ambientOcclusion(){}}class Nn extends Ar{constructor(e,t=null){super(),this.node=e,this.name=t,this.isVarNode=!0}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{node:t,name:s}=this,r=e.getVarFromNode(this,s,e.getVectorType(this.getNodeType(e))),i=e.getPropertyName(r),n=t.build(e,r.type);return e.addLineFlowCode(`${i} = ${n}`),i}}const _n=pi(Nn);Vr("temp",_n),Vr("toVar",((...e)=>_n(...e).append())),Rr("VarNode",Nn);class vn{constructor(e,t,s=null){this.isNodeAttribute=!0,this.name=e,this.type=t,this.node=s}}class Sn{constructor(e,t,s,r=void 0){this.isNodeUniform=!0,this.name=e,this.type=t,this.node=s.getSelf(),this.needsUpdate=r}get value(){return this.node.value}set value(e){this.node.value=e}get id(){return this.node.id}get groupNode(){return this.node.groupNode}}class An{constructor(e,t){this.isNodeVar=!0,this.name=e,this.type=t}}class Rn extends An{constructor(e,t){super(e,t),this.needsInterpolation=!1,this.isNodeVarying=!0}}class Cn{constructor(e,t,s=""){this.name=e,this.type=t,this.code=s,Object.defineProperty(this,"isNodeCode",{value:!0})}}class En{constructor(){this.keywords=[],this.nodes=[],this.keywordsCallback={}}getNode(e){let t=this.nodes[e];return void 0===t&&void 0!==this.keywordsCallback[e]&&(t=this.keywordsCallback[e](e),this.nodes[e]=t),t}addKeyword(e,t){return this.keywords.push(e),this.keywordsCallback[e]=t,this}parse(e){const t=this.keywords,s=new RegExp(`\\b${t.join("\\b|\\b")}\\b`,"g"),r=e.match(s),i=[];if(null!==r)for(const e of r){const t=this.getNode(e);void 0!==t&&-1===i.indexOf(t)&&i.push(t)}return i}include(e,t){const s=this.parse(t);for(const t of s)t.build(e)}}class wn extends Ar{constructor(e,t=null,s=!1){super(e),this.name=t,this.varying=s,this.isPropertyNode=!0}getHash(e){return this.name||super.getHash(e)}isGlobal(){return!0}generate(e){let t;return!0===this.varying?(t=e.getVaryingFromNode(this,this.name),t.needsInterpolation=!0):t=e.getVarFromNode(this,this.name),e.getPropertyName(t)}}const Mn=(e,t)=>ci(new wn(e,t)),Fn=(e,t)=>ci(new wn(e,t,!0)),Bn=gi(wn,"vec4","DiffuseColor"),On=gi(wn,"float","Roughness"),Un=gi(wn,"float","Metalness"),Ln=gi(wn,"float","Clearcoat"),In=gi(wn,"float","ClearcoatRoughness"),Pn=gi(wn,"vec3","Sheen"),Dn=gi(wn,"float","SheenRoughness"),Vn=gi(wn,"float","Iridescence"),Gn=gi(wn,"float","IridescenceIOR"),kn=gi(wn,"float","IridescenceThickness"),zn=gi(wn,"color","SpecularColor"),$n=gi(wn,"float","Shininess"),Hn=gi(wn,"vec4","Output"),Wn=gi(wn,"float","dashSize"),jn=gi(wn,"float","gapSize"),qn=gi(wn,"float","pointWidth");Rr("PropertyNode",wn);class Xn extends wn{constructor(e,t=null){super(e,t),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}const Yn=(e,t)=>ci(new Xn(e,t));Rr("ParameterNode",Xn);class Kn extends Ar{constructor(e="",t=[],s=""){super("code"),this.isCodeNode=!0,this.code=e,this.language=s,this.includes=t}isGlobal(){return!0}setIncludes(e){return this.includes=e,this}getIncludes(){return this.includes}generate(e){const t=this.getIncludes(e);for(const s of t)s.build(e);const s=e.getCodeFromNode(this,this.getNodeType(e));return s.code=this.code,s.code}serialize(e){super.serialize(e),e.code=this.code,e.language=this.language}deserialize(e){super.deserialize(e),this.code=e.code,this.language=e.language}}const Qn=pi(Kn),Zn=(e,t)=>Qn(e,t,"js"),Jn=(e,t)=>Qn(e,t,"wgsl"),eo=(e,t)=>Qn(e,t,"glsl");Rr("CodeNode",Kn);class to extends Kn{constructor(e="",t=[],s=""){super(e,t,s),this.keywords={}}getNodeType(e){return this.getNodeFunction(e).type}getInputs(e){return this.getNodeFunction(e).inputs}getNodeFunction(e){const t=e.getDataFromNode(this);let s=t.nodeFunction;return void 0===s&&(s=e.parser.parseFunction(this.code),t.nodeFunction=s),s}generate(e,t){super.generate(e);const s=this.getNodeFunction(e),r=s.name,i=s.type,n=e.getCodeFromNode(this,i);""!==r&&(n.name=r);const o=e.getPropertyName(n);let a=this.getNodeFunction(e).getCode(o);const u=this.keywords,l=Object.keys(u);if(l.length>0)for(const t of l){const s=new RegExp(`\\b${t}\\b`,"g"),r=u[t].build(e,"property");a=a.replace(s,r)}return n.code=a+"\n","property"===t?o:e.format(`${o}()`,i,t)}}const so=(e,t=[],s="")=>{for(let e=0;e<t.length;e++){const s=t[e];"function"==typeof s&&(t[e]=s.functionNode)}const r=ci(new to(e,t,s)),i=(...e)=>r.call(...e);return i.functionNode=r,i},ro=(e,t)=>so(e,t,"glsl"),io=(e,t)=>so(e,t,"wgsl");Rr("FunctionNode",to);class no extends Ar{constructor(e,t=!1){super("string"),this.name=e,this.version=0,this.shared=t,this.isUniformGroup=!0}set needsUpdate(e){!0===e&&this.version++}}const oo=e=>new no(e),ao=e=>new no(e,!0),uo=ao("frame"),lo=ao("render"),co=oo("object");Rr("UniformGroupNode",no);class ho extends Lr{constructor(e,t=null){super(e,t),this.isUniformNode=!0,this.groupNode=co}setGroup(e){return this.groupNode=e,this}getGroup(){return this.groupNode}getUniformHash(e){return this.getHash(e)}generate(e,t){const s=this.getNodeType(e),r=this.getUniformHash(e);let i=e.getNodeFromHash(r);void 0===i&&(e.setHashNode(this,r),i=this);const n=i.getInputType(e),o=e.getUniformFromNode(i,n,e.shaderStage,e.context.label),a=e.getPropertyName(o);return void 0!==e.context.label&&delete e.context.label,e.format(a,s,t)}}const po=(e,t)=>{const s=ui(t||e),r=e&&!0===e.isNode?e.node&&e.node.value||e.value:e;return ci(new ho(r,s))};Rr("UniformNode",ho);class go extends on{constructor(e=0){super(null,"vec2"),this.isUVNode=!0,this.index=e}getAttributeName(){const e=this.index;return"uv"+(e>0?e:"")}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}const mo=(...e)=>ci(new go(...e));Rr("UVNode",go);class fo extends Ar{constructor(e,t=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=e,this.levelNode=t}generate(e,t){const s=this.textureNode.build(e,"property"),r=this.levelNode.build(e,"int");return e.format(`${e.getMethod("textureDimensions")}( ${s}, ${r} )`,this.getNodeType(e),t)}}const To=pi(fo);Vr("textureSize",To),Rr("TextureSizeNode",fo);class xo extends Er{constructor(e,t,s,...r){if(super(),this.op=e,r.length>0){let t=s;for(let s=0;s<r.length;s++)t=new xo(e,t,r[s]);s=t}this.aNode=t,this.bNode=s}getNodeType(e,t){const s=this.op,r=this.aNode,i=this.bNode,n=r.getNodeType(e),o=void 0!==i?i.getNodeType(e):null;if("void"===n||"void"===o)return"void";if("%"===s)return n;if("~"===s||"&"===s||"|"===s||"^"===s||">>"===s||"<<"===s)return e.getIntegerType(n);if("!"===s||"=="===s||"&&"===s||"||"===s||"^^"===s)return"bool";if("<"===s||">"===s||"<="===s||">="===s){const s=t?e.getTypeLength(t):Math.max(e.getTypeLength(n),e.getTypeLength(o));return s>1?`bvec${s}`:"bool"}return"float"===n&&e.isMatrix(o)?o:e.isMatrix(n)&&e.isVector(o)?e.getVectorFromMatrix(n):e.isVector(n)&&e.isMatrix(o)?e.getVectorFromMatrix(o):e.getTypeLength(o)>e.getTypeLength(n)?o:n}generate(e,t){const s=this.op,r=this.aNode,i=this.bNode,n=this.getNodeType(e,t);let o=null,a=null;"void"!==n?(o=r.getNodeType(e),a=void 0!==i?i.getNodeType(e):null,"<"===s||">"===s||"<="===s||">="===s||"=="===s?e.isVector(o)?a=o:o=a="float":">>"===s||"<<"===s?(o=n,a=e.changeComponentType(a,"uint")):e.isMatrix(o)&&e.isVector(a)?a=e.getVectorFromMatrix(o):o=e.isVector(o)&&e.isMatrix(a)?e.getVectorFromMatrix(a):a=n):o=a=n;const u=r.build(e,o),l=void 0!==i?i.build(e,a):null,c=e.getTypeLength(t),d=e.getFunctionOperator(s);return"void"!==t?"<"===s&&c>1?e.format(`${e.getMethod("lessThan")}( ${u}, ${l} )`,n,t):"<="===s&&c>1?e.format(`${e.getMethod("lessThanEqual")}( ${u}, ${l} )`,n,t):">"===s&&c>1?e.format(`${e.getMethod("greaterThan")}( ${u}, ${l} )`,n,t):">="===s&&c>1?e.format(`${e.getMethod("greaterThanEqual")}( ${u}, ${l} )`,n,t):"!"===s||"~"===s?e.format(`(${s}${u})`,o,t):d?e.format(`${d}( ${u}, ${l} )`,n,t):e.format(`( ${u} ${s} ${l} )`,n,t):"void"!==o?d?e.format(`${d}( ${u}, ${l} )`,n,t):e.format(`${u} ${s} ${l}`,n,t):void 0}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}const yo=pi(xo,"+"),bo=pi(xo,"-"),No=pi(xo,"*"),_o=pi(xo,"/"),vo=pi(xo,"%"),So=pi(xo,"=="),Ao=pi(xo,"!="),Ro=pi(xo,"<"),Co=pi(xo,">"),Eo=pi(xo,"<="),wo=pi(xo,">="),Mo=pi(xo,"&&"),Fo=pi(xo,"||"),Bo=pi(xo,"!"),Oo=pi(xo,"^^"),Uo=pi(xo,"&"),Lo=pi(xo,"~"),Io=pi(xo,"|"),Po=pi(xo,"^"),Do=pi(xo,"<<"),Vo=pi(xo,">>");Vr("add",yo),Vr("sub",bo),Vr("mul",No),Vr("div",_o),Vr("remainder",vo),Vr("equal",So),Vr("notEqual",Ao),Vr("lessThan",Ro),Vr("greaterThan",Co),Vr("lessThanEqual",Eo),Vr("greaterThanEqual",wo),Vr("and",Mo),Vr("or",Fo),Vr("not",Bo),Vr("xor",Oo),Vr("bitAnd",Uo),Vr("bitNot",Lo),Vr("bitOr",Io),Vr("bitXor",Po),Vr("shiftLeft",Do),Vr("shiftRight",Vo),Rr("OperatorNode",xo);class Go extends Er{constructor(e,t,s=null,r=null){super(),this.method=e,this.aNode=t,this.bNode=s,this.cNode=r}getInputType(e){const t=this.aNode.getNodeType(e),s=this.bNode?this.bNode.getNodeType(e):null,r=this.cNode?this.cNode.getNodeType(e):null,i=e.isMatrix(t)?0:e.getTypeLength(t),n=e.isMatrix(s)?0:e.getTypeLength(s),o=e.isMatrix(r)?0:e.getTypeLength(r);return i>n&&i>o?t:n>o?s:o>i?r:t}getNodeType(e){const t=this.method;return t===Go.LENGTH||t===Go.DISTANCE||t===Go.DOT?"float":t===Go.CROSS?"vec3":t===Go.ALL?"bool":t===Go.EQUALS?e.changeComponentType(this.aNode.getNodeType(e),"bool"):t===Go.MOD?this.aNode.getNodeType(e):this.getInputType(e)}generate(e,t){const s=this.method,r=this.getNodeType(e),i=this.getInputType(e),n=this.aNode,o=this.bNode,a=this.cNode,u=!0===e.renderer.isWebGLRenderer;if(s===Go.TRANSFORM_DIRECTION){let s=n,r=o;e.isMatrix(s.getNodeType(e))?r=Ui(Mi(r),0):s=Ui(Mi(s),0);const i=No(s,r).xyz;return ia(i).build(e,t)}if(s===Go.NEGATE)return e.format("( - "+n.build(e,i)+" )",r,t);if(s===Go.ONE_MINUS)return bo(1,n).build(e,t);if(s===Go.RECIPROCAL)return _o(1,n).build(e,t);if(s===Go.DIFFERENCE)return ha(bo(n,o)).build(e,t);{const l=[];return s===Go.CROSS||s===Go.MOD?l.push(n.build(e,r),o.build(e,r)):s===Go.STEP?l.push(n.build(e,1===e.getTypeLength(n.getNodeType(e))?"float":i),o.build(e,i)):u&&(s===Go.MIN||s===Go.MAX)||s===Go.MOD?l.push(n.build(e,i),o.build(e,1===e.getTypeLength(o.getNodeType(e))?"float":i)):s===Go.REFRACT?l.push(n.build(e,i),o.build(e,i),a.build(e,"float")):s===Go.MIX?l.push(n.build(e,i),o.build(e,i),a.build(e,1===e.getTypeLength(a.getNodeType(e))?"float":i)):(l.push(n.build(e,i)),null!==o&&l.push(o.build(e,i)),null!==a&&l.push(a.build(e,i))),e.format(`${e.getMethod(s,r)}( ${l.join(", ")} )`,r,t)}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}Go.ALL="all",Go.ANY="any",Go.EQUALS="equals",Go.RADIANS="radians",Go.DEGREES="degrees",Go.EXP="exp",Go.EXP2="exp2",Go.LOG="log",Go.LOG2="log2",Go.SQRT="sqrt",Go.INVERSE_SQRT="inversesqrt",Go.FLOOR="floor",Go.CEIL="ceil",Go.NORMALIZE="normalize",Go.FRACT="fract",Go.SIN="sin",Go.COS="cos",Go.TAN="tan",Go.ASIN="asin",Go.ACOS="acos",Go.ATAN="atan",Go.ABS="abs",Go.SIGN="sign",Go.LENGTH="length",Go.NEGATE="negate",Go.ONE_MINUS="oneMinus",Go.DFDX="dFdx",Go.DFDY="dFdy",Go.ROUND="round",Go.RECIPROCAL="reciprocal",Go.TRUNC="trunc",Go.FWIDTH="fwidth",Go.BITCAST="bitcast",Go.ATAN2="atan2",Go.MIN="min",Go.MAX="max",Go.MOD="mod",Go.STEP="step",Go.REFLECT="reflect",Go.DISTANCE="distance",Go.DIFFERENCE="difference",Go.DOT="dot",Go.CROSS="cross",Go.POW="pow",Go.TRANSFORM_DIRECTION="transformDirection",Go.MIX="mix",Go.CLAMP="clamp",Go.REFRACT="refract",Go.SMOOTHSTEP="smoothstep",Go.FACEFORWARD="faceforward";const ko=_i(1e-6),zo=_i(1e6),$o=_i(Math.PI),Ho=_i(2*Math.PI),Wo=pi(Go,Go.ALL),jo=pi(Go,Go.ANY),qo=pi(Go,Go.EQUALS),Xo=pi(Go,Go.RADIANS),Yo=pi(Go,Go.DEGREES),Ko=pi(Go,Go.EXP),Qo=pi(Go,Go.EXP2),Zo=pi(Go,Go.LOG),Jo=pi(Go,Go.LOG2),ea=pi(Go,Go.SQRT),ta=pi(Go,Go.INVERSE_SQRT),sa=pi(Go,Go.FLOOR),ra=pi(Go,Go.CEIL),ia=pi(Go,Go.NORMALIZE),na=pi(Go,Go.FRACT),oa=pi(Go,Go.SIN),aa=pi(Go,Go.COS),ua=pi(Go,Go.TAN),la=pi(Go,Go.ASIN),ca=pi(Go,Go.ACOS),da=pi(Go,Go.ATAN),ha=pi(Go,Go.ABS),pa=pi(Go,Go.SIGN),ga=pi(Go,Go.LENGTH),ma=pi(Go,Go.NEGATE),fa=pi(Go,Go.ONE_MINUS),Ta=pi(Go,Go.DFDX),xa=pi(Go,Go.DFDY),ya=pi(Go,Go.ROUND),ba=pi(Go,Go.RECIPROCAL),Na=pi(Go,Go.TRUNC),_a=pi(Go,Go.FWIDTH),va=pi(Go,Go.BITCAST),Sa=pi(Go,Go.ATAN2),Aa=pi(Go,Go.MIN),Ra=pi(Go,Go.MAX),Ca=pi(Go,Go.MOD),Ea=pi(Go,Go.STEP),wa=pi(Go,Go.REFLECT),Ma=pi(Go,Go.DISTANCE),Fa=pi(Go,Go.DIFFERENCE),Ba=pi(Go,Go.DOT),Oa=pi(Go,Go.CROSS),Ua=pi(Go,Go.POW),La=pi(Go,Go.POW,2),Ia=pi(Go,Go.POW,3),Pa=pi(Go,Go.POW,4),Da=pi(Go,Go.TRANSFORM_DIRECTION),Va=e=>No(pa(e),Ua(ha(e),1/3)),Ga=e=>Ba(e,e),ka=pi(Go,Go.MIX),za=(e,t=0,s=1)=>ci(new Go(Go.CLAMP,ci(e),ci(t),ci(s))),$a=e=>za(e),Ha=pi(Go,Go.REFRACT),Wa=pi(Go,Go.SMOOTHSTEP),ja=pi(Go,Go.FACEFORWARD);Vr("all",Wo),Vr("any",jo),Vr("equals",qo),Vr("radians",Xo),Vr("degrees",Yo),Vr("exp",Ko),Vr("exp2",Qo),Vr("log",Zo),Vr("log2",Jo),Vr("sqrt",ea),Vr("inverseSqrt",ta),Vr("floor",sa),Vr("ceil",ra),Vr("normalize",ia),Vr("fract",na),Vr("sin",oa),Vr("cos",aa),Vr("tan",ua),Vr("asin",la),Vr("acos",ca),Vr("atan",da),Vr("abs",ha),Vr("sign",pa),Vr("length",ga),Vr("lengthSq",Ga),Vr("negate",ma),Vr("oneMinus",fa),Vr("dFdx",Ta),Vr("dFdy",xa),Vr("round",ya),Vr("reciprocal",ba),Vr("trunc",Na),Vr("fwidth",_a),Vr("atan2",Sa),Vr("min",Aa),Vr("max",Ra),Vr("mod",Ca),Vr("step",Ea),Vr("reflect",wa),Vr("distance",Ma),Vr("dot",Ba),Vr("cross",Oa),Vr("pow",Ua),Vr("pow2",La),Vr("pow3",Ia),Vr("pow4",Pa),Vr("transformDirection",Da),Vr("mix",((e,t,s)=>ka(t,s,e))),Vr("clamp",za),Vr("refract",Ha),Vr("smoothstep",((e,t,s)=>Wa(t,s,e))),Vr("faceForward",ja),Vr("difference",Fa),Vr("saturate",$a),Vr("cbrt",Va),Rr("MathNode",Go);const qa=fi((e=>{const{value:t}=e,{rgb:s}=t,r=s.mul(.9478672986).add(.0521327014).pow(2.4),i=s.mul(.0773993808),n=s.lessThanEqual(.04045),o=ka(r,i,n);return Ui(o,t.a)})),Xa=fi((e=>{const{value:t}=e,{rgb:s}=t,r=s.pow(.41666).mul(1.055).sub(.055),i=s.mul(12.92),n=s.lessThanEqual(.0031308),o=ka(r,i,n);return Ui(o,t.a)})),Ya=e=>{let t=null;return e===h?t="Linear":e===p&&(t="sRGB"),t},Ka=(e,t)=>Ya(e)+"To"+Ya(t);class Qa extends Er{constructor(e,t){super("vec4"),this.method=e,this.node=t}setup(){const{method:e,node:t}=this;return e===Qa.LINEAR_TO_LINEAR?t:Za[e]({value:t})}}Qa.LINEAR_TO_LINEAR="LinearToLinear",Qa.LINEAR_TO_sRGB="LinearTosRGB",Qa.sRGB_TO_LINEAR="sRGBToLinear";const Za={[Qa.LINEAR_TO_sRGB]:Xa,[Qa.sRGB_TO_LINEAR]:qa},Ja=(e,t)=>ci(new Qa(Ka(h,t),ci(e))),eu=(e,t)=>ci(new Qa(Ka(t,h),ci(e))),tu=pi(Qa,Qa.LINEAR_TO_sRGB),su=pi(Qa,Qa.sRGB_TO_LINEAR);Vr("linearTosRGB",tu),Vr("sRGBToLinear",su),Vr("linearToColorSpace",Ja),Vr("colorSpaceToLinear",eu),Rr("ColorSpaceNode",Qa);class ru extends Ar{constructor(e="",t="void"){super(t),this.snippet=e}generate(e,t){const s=this.getNodeType(e),r=this.snippet;if("void"!==s)return e.format(`( ${r} )`,s,t);e.addLineFlowCode(r)}}const iu=pi(ru);Rr("ExpressionNode",ru);class nu extends ho{constructor(e){super(0),this.textureNode=e,this.updateType=cr.FRAME}get texture(){return this.textureNode.value}update(){const e=this.texture,t=e.images,s=t&&t.length>0?t[0]&&t[0].image||t[0]:e.image;if(s&&void 0!==s.width){const{width:e,height:t}=s;this.value=Math.log2(Math.max(e,t))}}}const ou=pi(nu);Rr("MaxMipLevelNode",nu);class au extends ho{constructor(e,t=null,s=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=s,this.compareNode=null,this.depthNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=cr.NONE,this.setUpdateMatrix(null===t)}getUniformHash(){return this.value.uuid}getNodeType(){return!0===this.value.isDepthTexture?"float":"vec4"}getInputType(){return"texture"}getDefaultUV(){return mo(this.value.channel)}setReference(){return this.value}getTransformedUV(e){const t=this.value;return po(t.matrix).mul(Mi(e,1)).xy}setUpdateMatrix(e){return this.updateMatrix=e,this.updateType=e?cr.FRAME:cr.NONE,this}setupUV(e,t){const s=this.value;return!e.isFlipY()||!0!==s.isRenderTargetTexture&&!0!==s.isFramebufferTexture&&!0!==s.isDepthTexture||(t=t.setY(t.y.oneMinus())),t}setup(e){const t=e.getNodeProperties(this);let s=this.uvNode;null!==s&&!0!==e.context.forceUVContext||!e.context.getUV||(s=e.context.getUV(this)),s||(s=this.getDefaultUV()),!0===this.updateMatrix&&(s=this.getTransformedUV(s)),s=this.setupUV(e,s);let r=this.levelNode;null===r&&e.context.getTextureLevel&&(r=e.context.getTextureLevel(this)),null!==r&&void 0!==e.context.getTextureLevelAlgorithm&&(r=e.context.getTextureLevelAlgorithm(this,r)),t.uvNode=s,t.levelNode=r,t.compareNode=this.compareNode,t.depthNode=this.depthNode}generateUV(e,t){return t.build(e,!0===this.sampler?"vec2":"ivec2")}generateSnippet(e,t,s,r,i,n){const o=this.value;let a;return a=r?e.generateTextureLevel(o,t,s,r,i):n?e.generateTextureCompare(o,t,s,n,i):!1===this.sampler?e.generateTextureLoad(o,t,s,i):e.generateTexture(o,t,s,i),a}generate(e,t){const s=e.getNodeProperties(this),r=this.value;if(!r||!0!==r.isTexture)throw new Error("TextureNode: Need a three.js texture.");const i=super.generate(e,"property");if("sampler"===t)return i+"_sampler";if(e.isReference(t))return i;{const n=e.getDataFromNode(this);let o=n.propertyName;if(void 0===o){const{uvNode:t,levelNode:r,compareNode:a,depthNode:u}=s,l=this.generateUV(e,t),c=r?r.build(e,"float"):null,d=u?u.build(e,"int"):null,h=a?a.build(e,"float"):null,p=e.getVarFromNode(this);o=e.getPropertyName(p);const g=this.generateSnippet(e,i,l,c,d,h);e.addLineFlowCode(`${o} = ${g}`),!1!==e.context.tempWrite&&(n.snippet=g,n.propertyName=o)}let a=o;const u=this.getNodeType(e);return e.needsColorSpaceToLinear(r)&&(a=eu(iu(a,u),r.colorSpace).setup(e).build(e,u)),e.format(a,u,t)}}setSampler(e){return this.sampler=e,this}getSampler(){return this.sampler}uv(e){const t=this.clone();return t.uvNode=e,ci(t)}blur(e){const t=this.clone();return t.levelNode=e.mul(ou(t)),ci(t)}level(e){const t=this.clone();return t.levelNode=e,t}size(e){return To(this,e)}compare(e){const t=this.clone();return t.compareNode=ci(e),ci(t)}depth(e){const t=this.clone();return t.depthNode=ci(e),ci(t)}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value]}update(){const e=this.value;!0===e.matrixAutoUpdate&&e.updateMatrix()}clone(){const e=new this.constructor(this.value,this.uvNode,this.levelNode);return e.sampler=this.sampler,e}}const uu=pi(au),lu=(...e)=>uu(...e).setSampler(!1),cu=e=>(!0===e.isNode?e:uu(e)).convert("sampler");Vr("texture",uu),Rr("TextureNode",au);class du extends ho{constructor(e,t,s=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferCount=s}getInputType(){return"buffer"}}const hu=(e,t,s)=>ci(new du(e,t,s));Rr("BufferNode",du);class pu extends wr{constructor(e,t){super(e,t),this.isArrayBufferElementNode=!0}getNodeType(e){return this.node.getElementType(e)}generate(e){const t=super.generate(e),s=this.getNodeType();return e.format(t,"vec4",s)}}class gu extends du{constructor(e,t=null){super(null,"vec4"),this.array=e,this.elementType=t,this._elementType=null,this._elementLength=0,this.updateType=cr.RENDER,this.isArrayBufferNode=!0}getElementType(){return this.elementType||this._elementType}getElementLength(){return this._elementLength}update(){const{array:e,value:t}=this,s=this.getElementLength(),r=this.getElementType();if(1===s)for(let s=0;s<e.length;s++){t[4*s]=e[s]}else if("color"===r)for(let s=0;s<e.length;s++){const r=4*s,i=e[s];t[r]=i.r,t[r+1]=i.g,t[r+2]=i.b||0}else for(let s=0;s<e.length;s++){const r=4*s,i=e[s];t[r]=i.x,t[r+1]=i.y,t[r+2]=i.z||0,t[r+3]=i.w||0}}setup(e){const t=this.array.length;return this._elementType=null===this.elementType?xr(this.array[0]):this.elementType,this._elementLength=e.getTypeLength(this._elementType),this.value=new Float32Array(4*t),this.bufferCount=t,super.setup(e)}element(e){return ci(new pu(this,ci(e)))}}const mu=(e,t)=>ci(new gu(e,t));Rr("UniformsNode",gu);class fu extends wr{constructor(e,t){super(e,t),this.referenceNode=e,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(e){const t=super.generate(e),s=this.referenceNode.getNodeType(),r=this.getNodeType();return e.format(t,s,r)}}class Tu extends Ar{constructor(e,t,s=null,r=null){super(),this.property=e,this.uniformType=t,this.object=s,this.count=r,this.properties=e.split("."),this.reference=null,this.node=null,this.updateType=cr.OBJECT}element(e){return ci(new fu(this,ci(e)))}setNodeType(e){let t=null;t=null!==this.count?hu(null,e,this.count):Array.isArray(this.getValueFromReference())?mu(null,e):"texture"===e?uu(null):po(null,e),this.node=t}getNodeType(e){return this.node.getNodeType(e)}getValueFromReference(e=this.reference){const{properties:t}=this;let s=e[t[0]];for(let e=1;e<t.length;e++)s=s[t[e]];return s}setReference(e){return this.reference=null!==this.object?this.object:e.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){null===this.node&&this.setNodeType(this.uniformType);const e=this.getValueFromReference();Array.isArray(e)?this.node.array=e:this.node.value=e}}const xu=(e,t,s)=>ci(new Tu(e,t,s)),yu=(e,t,s,r)=>ci(new Tu(e,t,r,s));Rr("ReferenceNode",Tu);class bu extends Tu{constructor(e,t,s=null){super(e,t,s),this.material=s}setReference(e){return this.reference=null!==this.material?this.material:e.material,this.reference}}const Nu=(e,t,s)=>ci(new bu(e,t,s));Rr("MaterialReferenceNode",bu);class _u extends Ar{constructor(e=_u.VIEW_MATRIX,t=null){super(),this.scope=e,this.object3d=t,this.updateType=cr.OBJECT,this._uniformNode=new ho(null)}getNodeType(){const e=this.scope;return e===_u.WORLD_MATRIX||e===_u.VIEW_MATRIX?"mat4":e===_u.NORMAL_MATRIX?"mat3":e===_u.POSITION||e===_u.VIEW_POSITION||e===_u.DIRECTION||e===_u.SCALE?"vec3":void 0}update(e){const t=this.object3d,s=this._uniformNode,r=this.scope;if(r===_u.VIEW_MATRIX)s.value=t.modelViewMatrix;else if(r===_u.NORMAL_MATRIX)s.value=t.normalMatrix;else if(r===_u.WORLD_MATRIX)s.value=t.matrixWorld;else if(r===_u.POSITION)s.value=s.value||new u,s.value.setFromMatrixPosition(t.matrixWorld);else if(r===_u.SCALE)s.value=s.value||new u,s.value.setFromMatrixScale(t.matrixWorld);else if(r===_u.DIRECTION)s.value=s.value||new u,t.getWorldDirection(s.value);else if(r===_u.VIEW_POSITION){const r=e.camera;s.value=s.value||new u,s.value.setFromMatrixPosition(t.matrixWorld),s.value.applyMatrix4(r.matrixWorldInverse)}}generate(e){const t=this.scope;return t===_u.WORLD_MATRIX||t===_u.VIEW_MATRIX?this._uniformNode.nodeType="mat4":t===_u.NORMAL_MATRIX?this._uniformNode.nodeType="mat3":t!==_u.POSITION&&t!==_u.VIEW_POSITION&&t!==_u.DIRECTION&&t!==_u.SCALE||(this._uniformNode.nodeType="vec3"),this._uniformNode.build(e)}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}_u.VIEW_MATRIX="viewMatrix",_u.NORMAL_MATRIX="normalMatrix",_u.WORLD_MATRIX="worldMatrix",_u.POSITION="position",_u.SCALE="scale",_u.VIEW_POSITION="viewPosition",_u.DIRECTION="direction";const vu=pi(_u,_u.DIRECTION),Su=pi(_u,_u.VIEW_MATRIX),Au=pi(_u,_u.NORMAL_MATRIX),Ru=pi(_u,_u.WORLD_MATRIX),Cu=pi(_u,_u.POSITION),Eu=pi(_u,_u.SCALE),wu=pi(_u,_u.VIEW_POSITION);Rr("Object3DNode",_u);class Mu extends _u{constructor(e=Mu.POSITION){super(e),this.updateType=cr.RENDER}getNodeType(e){const t=this.scope;return t===Mu.PROJECTION_MATRIX||t===Mu.PROJECTION_MATRIX_INVERSE?"mat4":t===Mu.NEAR||t===Mu.FAR||t===Mu.LOG_DEPTH?"float":super.getNodeType(e)}update(e){const t=e.camera,s=this._uniformNode,r=this.scope;r===Mu.VIEW_MATRIX?s.value=t.matrixWorldInverse:r===Mu.PROJECTION_MATRIX?s.value=t.projectionMatrix:r===Mu.PROJECTION_MATRIX_INVERSE?s.value=t.projectionMatrixInverse:r===Mu.NEAR?s.value=t.near:r===Mu.FAR?s.value=t.far:r===Mu.LOG_DEPTH?s.value=2/(Math.log(t.far+1)/Math.LN2):(this.object3d=t,super.update(e))}generate(e){const t=this.scope;return t===Mu.PROJECTION_MATRIX||t===Mu.PROJECTION_MATRIX_INVERSE?this._uniformNode.nodeType="mat4":t!==Mu.NEAR&&t!==Mu.FAR&&t!==Mu.LOG_DEPTH||(this._uniformNode.nodeType="float"),super.generate(e)}}Mu.PROJECTION_MATRIX="projectionMatrix",Mu.PROJECTION_MATRIX_INVERSE="projectionMatrixInverse",Mu.NEAR="near",Mu.FAR="far",Mu.LOG_DEPTH="logDepth";const Fu=gi(Mu,Mu.PROJECTION_MATRIX),Bu=gi(Mu,Mu.PROJECTION_MATRIX_INVERSE),Ou=gi(Mu,Mu.NEAR),Uu=gi(Mu,Mu.FAR),Lu=gi(Mu,Mu.LOG_DEPTH),Iu=gi(Mu,Mu.VIEW_MATRIX),Pu=gi(Mu,Mu.NORMAL_MATRIX),Du=gi(Mu,Mu.WORLD_MATRIX),Vu=gi(Mu,Mu.POSITION);Rr("CameraNode",Mu);class Gu extends _u{constructor(e=Gu.VIEW_MATRIX){super(e)}update(e){this.object3d=e.object,super.update(e)}}const ku=gi(Gu,Gu.DIRECTION),zu=gi(Gu,Gu.VIEW_MATRIX).label("modelViewMatrix").temp("ModelViewMatrix"),$u=gi(Gu,Gu.NORMAL_MATRIX),Hu=gi(Gu,Gu.WORLD_MATRIX),Wu=gi(Gu,Gu.POSITION),ju=gi(Gu,Gu.SCALE),qu=gi(Gu,Gu.VIEW_POSITION);Rr("ModelNode",Gu);class Xu extends Ar{constructor(e=Xu.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`normal-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===Xu.GEOMETRY)s=an("normal","vec3");else if(t===Xu.LOCAL)s=nn(Yu);else if(t===Xu.VIEW){const e=$u.mul(Ku);s=ia(nn(e))}else if(t===Xu.WORLD){const e=Qu.transformDirection(Iu);s=ia(nn(e))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}Xu.GEOMETRY="geometry",Xu.LOCAL="local",Xu.VIEW="view",Xu.WORLD="world";const Yu=gi(Xu,Xu.GEOMETRY),Ku=gi(Xu,Xu.LOCAL).temp("Normal"),Qu=gi(Xu,Xu.VIEW),Zu=gi(Xu,Xu.WORLD),Ju=Mn("vec3","TransformedNormalView"),el=Ju.transformDirection(Iu).normalize(),tl=Mn("vec3","TransformedClearcoatNormalView");Rr("NormalNode",Xu);const sl=new Map;class rl extends Ar{constructor(e){super(),this.scope=e}getCache(e,t){let s=sl.get(e);return void 0===s&&(s=Nu(e,t),sl.set(e,s)),s}getFloat(e){return this.getCache(e,"float")}getColor(e){return this.getCache(e,"color")}getTexture(e){return this.getCache("map"===e?"map":e+"Map","texture")}setup(e){const t=e.context.material,s=this.scope;let r=null;if(s===rl.COLOR){const e=this.getColor(s);r=t.map&&!0===t.map.isTexture?e.mul(this.getTexture("map")):e}else if(s===rl.OPACITY){const e=this.getFloat(s);r=t.alphaMap&&!0===t.alphaMap.isTexture?e.mul(this.getTexture("alpha")):e}else if(s===rl.SPECULAR_STRENGTH)r=t.specularMap&&!0===t.specularMap.isTexture?this.getTexture(s).r:_i(1);else if(s===rl.ROUGHNESS){const e=this.getFloat(s);r=t.roughnessMap&&!0===t.roughnessMap.isTexture?e.mul(this.getTexture(s).g):e}else if(s===rl.METALNESS){const e=this.getFloat(s);r=t.metalnessMap&&!0===t.metalnessMap.isTexture?e.mul(this.getTexture(s).b):e}else if(s===rl.EMISSIVE){const e=this.getColor(s);r=t.emissiveMap&&!0===t.emissiveMap.isTexture?e.mul(this.getTexture(s)):e}else if(s===rl.NORMAL)r=t.normalMap?this.getTexture("normal").normalMap(this.getCache("normalScale","vec2")):t.bumpMap?this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")):Qu;else if(s===rl.CLEARCOAT){const e=this.getFloat(s);r=t.clearcoatMap&&!0===t.clearcoatMap.isTexture?e.mul(this.getTexture(s).r):e}else if(s===rl.CLEARCOAT_ROUGHNESS){const e=this.getFloat(s);r=t.clearcoatRoughnessMap&&!0===t.clearcoatRoughnessMap.isTexture?e.mul(this.getTexture(s).r):e}else if(s===rl.CLEARCOAT_NORMAL)r=t.clearcoatNormalMap?this.getTexture(s).normalMap(this.getCache(s+"Scale","vec2")):Qu;else if(s===rl.SHEEN){const e=this.getColor("sheenColor").mul(this.getFloat("sheen"));r=t.sheenColorMap&&!0===t.sheenColorMap.isTexture?e.mul(this.getTexture("sheenColor").rgb):e}else if(s===rl.SHEEN_ROUGHNESS){const e=this.getFloat(s);r=t.sheenRoughnessMap&&!0===t.sheenRoughnessMap.isTexture?e.mul(this.getTexture(s).a):e,r=r.clamp(.07,1)}else if(s===rl.IRIDESCENCE_THICKNESS){const e=xu("1","float",t.iridescenceThicknessRange);if(t.iridescenceThicknessMap){const i=xu("0","float",t.iridescenceThicknessRange);r=e.sub(i).mul(this.getTexture(s).g).add(i)}else r=e}else{const t=this.getNodeType(e);r=this.getCache(s,t)}return r}}rl.ALPHA_TEST="alphaTest",rl.COLOR="color",rl.OPACITY="opacity",rl.SHININESS="shininess",rl.SPECULAR_COLOR="specular",rl.SPECULAR_STRENGTH="specularStrength",rl.REFLECTIVITY="reflectivity",rl.ROUGHNESS="roughness",rl.METALNESS="metalness",rl.NORMAL="normal",rl.CLEARCOAT="clearcoat",rl.CLEARCOAT_ROUGHNESS="clearcoatRoughness",rl.CLEARCOAT_NORMAL="clearcoatNormal",rl.EMISSIVE="emissive",rl.ROTATION="rotation",rl.SHEEN="sheen",rl.SHEEN_ROUGHNESS="sheenRoughness",rl.IRIDESCENCE="iridescence",rl.IRIDESCENCE_IOR="iridescenceIOR",rl.IRIDESCENCE_THICKNESS="iridescenceThickness",rl.LINE_SCALE="scale",rl.LINE_DASH_SIZE="dashSize",rl.LINE_GAP_SIZE="gapSize",rl.LINE_WIDTH="linewidth",rl.LINE_DASH_OFFSET="dashOffset",rl.POINT_WIDTH="pointWidth";const il=gi(rl,rl.ALPHA_TEST),nl=gi(rl,rl.COLOR),ol=gi(rl,rl.SHININESS),al=gi(rl,rl.EMISSIVE),ul=gi(rl,rl.OPACITY),ll=gi(rl,rl.SPECULAR_COLOR),cl=gi(rl,rl.SPECULAR_STRENGTH),dl=gi(rl,rl.REFLECTIVITY),hl=gi(rl,rl.ROUGHNESS),pl=gi(rl,rl.METALNESS),gl=gi(rl,rl.NORMAL),ml=gi(rl,rl.CLEARCOAT),fl=gi(rl,rl.CLEARCOAT_ROUGHNESS),Tl=gi(rl,rl.CLEARCOAT_NORMAL),xl=gi(rl,rl.ROTATION),yl=gi(rl,rl.SHEEN),bl=gi(rl,rl.SHEEN_ROUGHNESS),Nl=gi(rl,rl.IRIDESCENCE),_l=gi(rl,rl.IRIDESCENCE_IOR),vl=gi(rl,rl.IRIDESCENCE_THICKNESS),Sl=gi(rl,rl.LINE_SCALE),Al=gi(rl,rl.LINE_DASH_SIZE),Rl=gi(rl,rl.LINE_GAP_SIZE),Cl=gi(rl,rl.LINE_WIDTH),El=gi(rl,rl.LINE_DASH_OFFSET),wl=gi(rl,rl.POINT_WIDTH);Rr("MaterialNode",rl);class Ml extends Ar{constructor(e=Ml.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`position-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===Ml.GEOMETRY)s=an("position","vec3");else if(t===Ml.LOCAL)s=nn(Fl);else if(t===Ml.WORLD){const e=Hu.mul(Bl);s=nn(e)}else if(t===Ml.VIEW){const e=zu.mul(Bl);s=nn(e)}else if(t===Ml.VIEW_DIRECTION){const e=Ll.negate();s=ia(nn(e))}else if(t===Ml.WORLD_DIRECTION){const e=Bl.transformDirection(Hu);s=ia(nn(e))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}Ml.GEOMETRY="geometry",Ml.LOCAL="local",Ml.WORLD="world",Ml.WORLD_DIRECTION="worldDirection",Ml.VIEW="view",Ml.VIEW_DIRECTION="viewDirection";const Fl=gi(Ml,Ml.GEOMETRY),Bl=gi(Ml,Ml.LOCAL).temp("Position"),Ol=gi(Ml,Ml.WORLD),Ul=gi(Ml,Ml.WORLD_DIRECTION),Ll=gi(Ml,Ml.VIEW),Il=gi(Ml,Ml.VIEW_DIRECTION);Rr("PositionNode",Ml);class Pl extends Er{constructor(e=null){super("vec4"),this.positionNode=e}setup(e){if("fragment"===e.shaderStage)return nn(e.context.mvp);const t=this.positionNode||Bl;return Fu.mul(zu).mul(t)}}const Dl=pi(Pl);Rr("ModelViewProjectionNode",Pl);class Vl extends Lr{constructor(e,t=null,s=0,r=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferStride=s,this.bufferOffset=r,this.usage=g,this.instanced=!1,this.attribute=null,e&&!0===e.isBufferAttribute&&(this.attribute=e,this.usage=e.usage,this.instanced=e.isInstancedBufferAttribute)}getNodeType(e){return null===this.bufferType&&(this.bufferType=e.getTypeFromAttribute(this.attribute)),this.bufferType}setup(e){if(null!==this.attribute)return;const t=this.getNodeType(e),s=this.value,r=e.getTypeLength(t),i=this.bufferStride||r,n=this.bufferOffset,o=!0===s.isInterleavedBuffer?s:new m(s,i),a=new f(o,r,n);o.setUsage(this.usage),this.attribute=a,this.attribute.isInstancedBufferAttribute=this.instanced}generate(e){const t=this.getNodeType(e),s=e.getBufferAttributeFromNode(this,t),r=e.getPropertyName(s);let i=null;if("vertex"===e.shaderStage||"compute"===e.shaderStage)this.name=r,i=r;else{i=nn(this).build(e,t)}return i}getInputType(){return"bufferAttribute"}setUsage(e){return this.usage=e,this}setInstanced(e){return this.instanced=e,this}}const Gl=(e,t,s,r)=>ci(new Vl(e,t,s,r)),kl=(e,t,s,i)=>Gl(e,t,s,i).setUsage(r),zl=(e,t,s,r)=>Gl(e,t,s,r).setInstanced(!0),$l=(e,t,s,r)=>kl(e,t,s,r).setInstanced(!0);Vr("toAttribute",(e=>Gl(e.value))),Rr("BufferAttributeNode",Vl);class Hl extends Ar{constructor(e){super("void"),this.instanceMesh=e,this.instanceMatrixNode=null}setup(){let e=this.instanceMatrixNode;if(null===e){const t=this.instanceMesh.instanceMatrix,s=new T(t.array,16,1),i=t.usage===r?$l:zl,n=[i(s,"vec4",16,0),i(s,"vec4",16,4),i(s,"vec4",16,8),i(s,"vec4",16,12)];e=ji(...n),this.instanceMatrixNode=e}const t=e.mul(Bl).xyz,s=zi(e[0].xyz,e[1].xyz,e[2].xyz),i=Ku.div(Mi(s[0].dot(s[0]),s[1].dot(s[1]),s[2].dot(s[2]))),n=s.mul(i).xyz;Bl.assign(t),Ku.assign(n)}}const Wl=pi(Hl);Rr("InstanceNode",Hl);class jl extends Ar{constructor(e=jl.LOCAL){super(),this.scope=e}getHash(){return`tangent-${this.scope}`}getNodeType(){return this.scope===jl.GEOMETRY?"vec4":"vec3"}generate(e){const t=this.scope;let s=null;if(t===jl.GEOMETRY)s=an("tangent","vec4"),!1===e.geometry.hasAttribute("tangent")&&e.geometry.computeTangents();else if(t===jl.LOCAL)s=nn(ql.xyz);else if(t===jl.VIEW){const e=zu.mul(Ui(Xl,0)).xyz;s=ia(nn(e))}else if(t===jl.WORLD){const e=Yl.transformDirection(Iu);s=ia(nn(e))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}jl.GEOMETRY="geometry",jl.LOCAL="local",jl.VIEW="view",jl.WORLD="world";const ql=gi(jl,jl.GEOMETRY),Xl=gi(jl,jl.LOCAL),Yl=gi(jl,jl.VIEW),Kl=gi(jl,jl.WORLD),Ql=_n(Yl,"TransformedTangentView"),Zl=ia(Ql.transformDirection(Iu));Rr("TangentNode",jl);class Jl extends Ar{constructor(e,t=!1){let s,r,i;super("void"),this.skinnedMesh=e,this.useReference=t,this.updateType=cr.OBJECT,this.skinIndexNode=an("skinIndex","uvec4"),this.skinWeightNode=an("skinWeight","vec4"),t?(s=xu("bindMatrix","mat4"),r=xu("bindMatrixInverse","mat4"),i=yu("skeleton.boneMatrices","mat4",e.skeleton.bones.length)):(s=po(e.bindMatrix,"mat4"),r=po(e.bindMatrixInverse,"mat4"),i=hu(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length)),this.bindMatrixNode=s,this.bindMatrixInverseNode=r,this.boneMatricesNode=i}setup(e){const{skinIndexNode:t,skinWeightNode:s,bindMatrixNode:r,bindMatrixInverseNode:i,boneMatricesNode:n}=this,o=n.element(t.x),a=n.element(t.y),u=n.element(t.z),l=n.element(t.w),c=r.mul(Bl),d=yo(o.mul(s.x).mul(c),a.mul(s.y).mul(c),u.mul(s.z).mul(c),l.mul(s.w).mul(c)),h=i.mul(d).xyz;let p=yo(s.x.mul(o),s.y.mul(a),s.z.mul(u),s.w.mul(l));p=i.mul(p).mul(r);const g=p.transformDirection(Ku).xyz;Bl.assign(h),Ku.assign(g),e.hasGeometryAttribute("tangent")&&Xl.assign(g)}generate(e,t){if("void"!==t)return Bl.build(e,t)}update(e){(this.useReference?e.object:this.skinnedMesh).skeleton.update()}}const ec=e=>ci(new Jl(e));Rr("SkinningNode",Jl);class tc extends Ar{constructor(e=[]){super(),this.params=e}getVarName(e){return String.fromCharCode("i".charCodeAt()+e)}getProperties(e){const t=e.getNodeProperties(this);if(void 0!==t.stackNode)return t;const s={};for(let e=0,t=this.params.length-1;e<t;e++){const t=this.params[e],r=!0!==t.isNode&&t.name||this.getVarName(e),i=!0!==t.isNode&&t.type||"int";s[r]=iu(r,i)}return t.returnsNode=this.params[this.params.length-1](s,e.addStack(),e),t.stackNode=e.removeStack(),t}getNodeType(e){const{returnsNode:t}=this.getProperties(e);return t?t.getNodeType(e):"void"}setup(e){this.getProperties(e)}generate(e){const t=this.getProperties(e),s=this.params,r=t.stackNode;for(let t=0,r=s.length-1;t<r;t++){const r=s[t];let i=null,n=null,o=null,a=null,u=null,l=null;r.isNode?(a="int",o=this.getVarName(t),i="0",n=r.build(e,a),u="<"):(a=r.type||"int",o=r.name||this.getVarName(t),i=r.start,n=r.end,u=r.condition,l=r.update,"number"==typeof i?i=i.toString():i&&i.isNode&&(i=i.build(e,a)),"number"==typeof n?n=n.toString():n&&n.isNode&&(n=n.build(e,a)),void 0!==i&&void 0===n?(i+=" - 1",n="0",u=">="):void 0!==n&&void 0===i&&(i="0",u="<"),void 0===u&&(u=Number(i)>Number(n)?">=":"<"));const c={start:i,end:n,condition:u},d=c.start,h=c.end;let p="",g="",m="";l||(l="int"===a||"uint"===a?u.includes("<")?"++":"--":u.includes("<")?"+= 1.":"-= 1."),p+=e.getVar(a,o)+" = "+d,g+=o+" "+u+" "+h,m+=o+" "+l;const f=`for ( ${p}; ${g}; ${m} )`;e.addFlowCode((0===t?"\n":"")+e.tab+f+" {\n\n").addFlowTab()}const i=mn(r,{tempWrite:!1}).build(e,"void"),n=t.returnsNode?t.returnsNode.build(e):"";e.removeFlowTab().addFlowCode("\n"+e.tab+i);for(let t=0,s=this.params.length-1;t<s;t++)e.addFlowCode((0===t?"":e.tab)+"}\n\n").removeFlowTab();return e.addFlowTab(),n}}const sc=(...e)=>ci(new tc(hi(e,"int"))).append(),rc=()=>iu("continue").append(),ic=()=>iu("break").append();Vr("loop",((e,...t)=>ln(e,sc(...t)))),Rr("LoopNode",tc);const nc=new WeakMap,oc=new s,ac=fi((({bufferMap:e,influence:t,stride:s,width:r,depth:i,offset:n})=>{const o=vi(xn).mul(s).add(n),a=o.div(r),u=o.sub(a.mul(r));return lu(e,Ci(u,a)).depth(i).mul(t)}));class uc extends Ar{constructor(e){super("void"),this.mesh=e,this.morphBaseInfluence=po(1),this.updateType=cr.OBJECT}setup(e){const{geometry:t}=e,s=void 0!==t.morphAttributes.position,r=void 0!==t.morphAttributes.normal,i=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,n=void 0!==i?i.length:0,{texture:o,stride:u,size:l}=function(e){const t=void 0!==e.morphAttributes.position,s=void 0!==e.morphAttributes.normal,r=void 0!==e.morphAttributes.color,i=e.morphAttributes.position||e.morphAttributes.normal||e.morphAttributes.color,n=void 0!==i?i.length:0;let o=nc.get(e);if(void 0===o||o.count!==n){void 0!==o&&o.texture.dispose();const u=e.morphAttributes.position||[],l=e.morphAttributes.normal||[],c=e.morphAttributes.color||[];let d=0;!0===t&&(d=1),!0===s&&(d=2),!0===r&&(d=3);let h=e.attributes.position.count*d,p=1;const g=4096;h>g&&(p=Math.ceil(h/g),h=g);const m=new Float32Array(h*p*4*n),f=new x(m,h,p,n);f.type=y,f.needsUpdate=!0;const T=4*d;for(let N=0;N<n;N++){const _=u[N],v=l[N],S=c[N],A=h*p*4*N;for(let R=0;R<_.count;R++){const C=R*T;!0===t&&(oc.fromBufferAttribute(_,R),m[A+C+0]=oc.x,m[A+C+1]=oc.y,m[A+C+2]=oc.z,m[A+C+3]=0),!0===s&&(oc.fromBufferAttribute(v,R),m[A+C+4]=oc.x,m[A+C+5]=oc.y,m[A+C+6]=oc.z,m[A+C+7]=0),!0===r&&(oc.fromBufferAttribute(S,R),m[A+C+8]=oc.x,m[A+C+9]=oc.y,m[A+C+10]=oc.z,m[A+C+11]=4===S.itemSize?oc.w:1)}}function b(){f.dispose(),nc.delete(e),e.removeEventListener("dispose",b)}o={count:n,texture:f,stride:d,size:new a(h,p)},nc.set(e,o),e.addEventListener("dispose",b)}return o}(t);!0===s&&Bl.mulAssign(this.morphBaseInfluence),!0===r&&Ku.mulAssign(this.morphBaseInfluence);const c=vi(l.width);sc(n,(({i:e})=>{const t=xu("morphTargetInfluences","float").element(e);!0===s&&Bl.addAssign(ac({bufferMap:o,influence:t,stride:u,width:c,depth:e,offset:vi(0)})),!0===r&&Ku.addAssign(ac({bufferMap:o,influence:t,stride:u,width:c,depth:e,offset:vi(1)}))}))}update(){const e=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?e.value=1:e.value=1-this.mesh.morphTargetInfluences.reduce(((e,t)=>e+t),0)}}const lc=pi(uc);Rr("MorphNode",uc);class cc extends Ar{constructor(){super("vec3")}getHash(){return"reflectVector"}setup(){return Il.negate().reflect(Ju).transformDirection(Iu)}}const dc=gi(cc);Rr("ReflectVectorNode",cc);class hc extends au{constructor(e,t=null,s=null){super(e,t,s),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){return dc}setUpdateMatrix(){}setupUV(e,t){const s=this.value;return e.renderer.coordinateSystem!==b&&s.isRenderTargetTexture?t:Mi(t.x.negate(),t.yz)}generateUV(e,t){return t.build(e,"vec3")}}const pc=pi(hc);Vr("cubeTexture",pc),Rr("CubeTextureNode",hc);class gc extends Ar{constructor(){super("vec3")}generate(){}}Rr("LightingNode",gc);let mc=null;class fc extends gc{constructor(e=null){super(),this.updateType=cr.FRAME,this.light=e,this.rtt=null,this.shadowNode=null,this.color=new o,this._defaultColorNode=po(this.color),this.colorNode=this._defaultColorNode,this.isAnalyticLightNode=!0}getCacheKey(){return super.getCacheKey()+"-"+this.light.id+"-"+(this.light.castShadow?"1":"0")}getHash(){return this.light.uuid}setupShadow(e){let t=this.shadowNode;if(null===t){null===mc&&(mc=e.createNodeMaterial(),mc.fragmentNode=Ui(0,0,0,1),mc.isShadowNodeMaterial=!0);const s=this.light.shadow,r=e.getRenderTarget(s.mapSize.width,s.mapSize.height),i=new N;i.minFilter=_,i.magFilter=_,i.image.width=s.mapSize.width,i.image.height=s.mapSize.height,i.compareFunction=v,r.depthTexture=i,s.camera.updateProjectionMatrix();const n=xu("bias","float",s),o=xu("normalBias","float",s);let a=po(s.matrix).mul(Ol.add(Zu.mul(o)));a=a.xyz.div(a.w);const u=a.x.greaterThanEqual(0).and(a.x.lessThanEqual(1)).and(a.y.greaterThanEqual(0)).and(a.y.lessThanEqual(1)).and(a.z.lessThanEqual(1));let l=a.z.add(n);e.renderer.coordinateSystem===b&&(l=l.mul(2).sub(1)),a=Mi(a.x,a.y.oneMinus(),l);const c=(e,t,s)=>uu(e,t).compare(s);t=c(i,a.xy,a.z);const d=uu(r.texture,a);this.rtt=r,this.colorNode=this.colorNode.mul(u.mix(1,t.mix(d.a.mix(1,d),1))),this.shadowNode=t,this.updateBeforeType=cr.RENDER}}setup(e){this.light.castShadow?this.setupShadow(e):null!==this.shadowNode&&this.disposeShadow()}updateShadow(e){const{rtt:t,light:s}=this,{renderer:r,scene:i}=e,n=i.overrideMaterial;i.overrideMaterial=mc,t.setSize(s.shadow.mapSize.width,s.shadow.mapSize.height),s.shadow.updateMatrices(s);const o=r.getRenderTarget(),a=r.getRenderObjectFunction();r.setRenderObjectFunction(((e,...t)=>{!0===e.castShadow&&r.renderObject(e,...t)})),r.setRenderTarget(t),r.render(i,s.shadow.camera),r.setRenderTarget(o),r.setRenderObjectFunction(a),i.overrideMaterial=n}disposeShadow(){this.rtt.dispose(),this.shadowNode=null,this.rtt=null,this.colorNode=this._defaultColorNode}updateBefore(e){const{light:t}=this;t.castShadow&&this.updateShadow(e)}update(){const{light:e}=this;this.color.copy(e.color).multiplyScalar(e.intensity)}}Rr("AnalyticLightNode",fc);const Tc=new WeakMap;class xc extends Ar{constructor(e=[]){super("vec3"),this.totalDiffuseNode=Mi().temp("totalDiffuse"),this.totalSpecularNode=Mi().temp("totalSpecular"),this.outgoingLightNode=Mi().temp("outgoingLight"),this.lightNodes=e,this._hash=null}get hasLight(){return this.lightNodes.length>0}getHash(){if(null===this._hash){const e=[];for(const t of this.lightNodes)e.push(t.getHash());this._hash="lights-"+e.join(",")}return this._hash}setup(e){const t=e.context,s=t.lightingModel;let r=this.outgoingLightNode;if(s){const{lightNodes:i,totalDiffuseNode:n,totalSpecularNode:o}=this;t.outgoingLight=r;const a=e.addStack();s.start(t,a,e);for(const t of i)t.build(e);s.indirectDiffuse(t,a,e),s.indirectSpecular(t,a,e),s.ambientOcclusion(t,a,e);const{backdrop:u,backdropAlpha:l}=t,{directDiffuse:c,directSpecular:d,indirectDiffuse:h,indirectSpecular:p}=t.reflectedLight;let g=c.add(h);null!==u&&(g=Mi(null!==l?l.mix(g,u):u)),n.assign(g),o.assign(d.add(p)),r.assign(n.add(o)),s.finish(t,a,e),r=r.bypass(e.removeStack())}return r}_getLightNodeById(e){for(const t of this.lightNodes)if(t.isAnalyticLightNode&&t.light.id===e)return t;return null}fromLights(e=[]){const t=[];e=(e=>e.sort(((e,t)=>e.id-t.id)))(e);for(const s of e){let e=this._getLightNodeById(s.id);if(null===e){const t=s.constructor,r=Tc.has(t)?Tc.get(t):fc;e=ci(new r(s))}t.push(e)}return this.lightNodes=t,this._hash=null,this}}const yc=e=>ci((new xc).fromLights(e)),bc=pi(xc);function Nc(e,t){if(!Tc.has(e)){if("function"!=typeof e)throw new Error(`Light ${e.name} is not a class`);if("function"!=typeof t||!t.type)throw new Error(`Light node ${t.type} is not a class`);Tc.set(e,t)}}class _c extends gc{constructor(e=null){super(),this.aoNode=e}setup(e){const t=this.aoNode.x.sub(1).mul(1).add(1);e.context.ambientOcclusion.mulAssign(t)}}Rr("AONode",_c);class vc extends gn{constructor(e,t=null,s=null,r=null){super(e),this.lightingModel=t,this.backdropNode=s,this.backdropAlphaNode=r,this._context=null}getContext(){const{backdropNode:e,backdropAlphaNode:t}=this,s={directDiffuse:Mi().temp("directDiffuse"),directSpecular:Mi().temp("directSpecular"),indirectDiffuse:Mi().temp("indirectDiffuse"),indirectSpecular:Mi().temp("indirectSpecular")};return{radiance:Mi().temp("radiance"),irradiance:Mi().temp("irradiance"),iblIrradiance:Mi().temp("iblIrradiance"),ambientOcclusion:_i(1).temp("ambientOcclusion"),reflectedLight:s,backdrop:e,backdropAlpha:t}}setup(e){return this.context=this._context||(this._context=this.getContext()),this.context.lightingModel=this.lightingModel||e.context.lightingModel,super.setup(e)}}const Sc=pi(vc);Vr("lightingContext",Sc),Rr("LightingContextNode",vc);class Ac extends Er{constructor(e=Ul){super("vec2"),this.dirNode=e}setup(){const e=this.dirNode,t=e.z.atan2(e.x).mul(1/(2*Math.PI)).add(.5),s=e.y.negate().clamp(-1,1).asin().mul(1/Math.PI).add(.5);return Ri(t,s)}}const Rc=pi(Ac);Rr("EquirectUVNode",Ac);class Cc extends Ar{constructor(e,t=null){super("float"),this.textureNode=e,this.roughnessNode=t}setup(){const{textureNode:e,roughnessNode:t}=this,s=ou(e),r=t.mul(t).mul(Math.PI).div(t.add(1));return s.add(r.log2()).clamp(0,s)}}const Ec=pi(Cc);Rr("SpecularMIPLevelNode",Cc);const wc=new WeakMap;class Mc extends gc{constructor(e=null){super(),this.envNode=e}setup(e){let t=this.envNode;if(t.isTextureNode&&!0!==t.value.isCubeTexture){let s=wc.get(t.value);if(void 0===s){const r=t.value,i=e.renderer,n=e.getCubeRenderTarget(512).fromEquirectangularTexture(i,r);s=pc(n.texture),wc.set(t.value,s)}t=s}const s=xu("envMapIntensity","float",e.material),r=mn(t,Fc(On,Ju)).mul(s),i=mn(t,Bc(el)).mul(Math.PI).mul(s),n=pn(r);e.context.radiance.addAssign(n),e.context.iblIrradiance.addAssign(i);const o=e.context.lightingModel.clearcoatRadiance;if(o){const e=mn(t,Fc(In,tl)).mul(s),r=pn(e);o.addAssign(r)}}}const Fc=(e,t)=>{let s=null,r=null;return{getUV:i=>{let n=null;return null===s&&(s=Il.negate().reflect(t),s=e.mul(e).mix(s,t).normalize(),s=s.transformDirection(Iu)),i.isCubeTextureNode?n=s:i.isTextureNode&&(null===r&&(r=Rc(s)),n=r),n},getTextureLevel:()=>e,getTextureLevelAlgorithm:(e,t)=>Ec(e,t)}},Bc=e=>{let t=null;return{getUV:s=>{let r=null;return s.isCubeTextureNode?r=e:s.isTextureNode&&(null===t&&(t=Rc(e),t=Ri(t.x,t.y.oneMinus())),r=t),r},getTextureLevel:e=>ou(e)}};let Oc,Uc;Rr("EnvironmentNode",Mc);class Lc extends Ar{constructor(e){super(),this.scope=e,this.isViewportNode=!0}getNodeType(){return this.scope===Lc.VIEWPORT?"vec4":"vec2"}getUpdateType(){let e=cr.NONE;return this.scope!==Lc.RESOLUTION&&this.scope!==Lc.VIEWPORT||(e=cr.FRAME),this.updateType=e,e}update({renderer:e}){this.scope===Lc.VIEWPORT?e.getViewport(Uc):e.getDrawingBufferSize(Oc)}setup(){const e=this.scope;let t=null;if(e===Lc.RESOLUTION)t=po(Oc||(Oc=new a));else if(e===Lc.VIEWPORT)t=po(Uc||(Uc=new s));else{t=Ic.div(Pc);let s=t.x,r=t.y;/bottom/i.test(e)&&(r=r.oneMinus()),/right/i.test(e)&&(s=s.oneMinus()),t=Ri(s,r)}return t}generate(e){if(this.scope===Lc.COORDINATE){let t=e.getFragCoord();if(e.isFlipY()){const s=e.getNodeProperties(Pc).outputNode.build(e);t=`${e.getType("vec2")}( ${t}.x, ${s}.y - ${t}.y )`}return t}return super.generate(e)}}Lc.COORDINATE="coordinate",Lc.RESOLUTION="resolution",Lc.VIEWPORT="viewport",Lc.TOP_LEFT="topLeft",Lc.BOTTOM_LEFT="bottomLeft",Lc.TOP_RIGHT="topRight",Lc.BOTTOM_RIGHT="bottomRight";const Ic=gi(Lc,Lc.COORDINATE),Pc=gi(Lc,Lc.RESOLUTION),Dc=gi(Lc,Lc.VIEWPORT),Vc=gi(Lc,Lc.TOP_LEFT),Gc=gi(Lc,Lc.BOTTOM_LEFT),kc=gi(Lc,Lc.TOP_RIGHT),zc=gi(Lc,Lc.BOTTOM_RIGHT);Rr("ViewportNode",Lc);const $c=new a;class Hc extends au{constructor(e=Vc,t=null,s=null){null===s&&((s=new S).minFilter=A),super(s,e,t),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=cr.FRAME}updateBefore(e){const t=e.renderer;t.getDrawingBufferSize($c);const s=this.value;s.image.width===$c.width&&s.image.height===$c.height||(s.image.width=$c.width,s.image.height=$c.height,s.needsUpdate=!0);const r=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,t.copyFramebufferToTexture(s),s.generateMipmaps=r}clone(){return new this.constructor(this.uvNode,this.levelNode,this.value)}}const Wc=pi(Hc),jc=pi(Hc,null,null,{generateMipmaps:!0});Vr("viewportTexture",Wc),Vr("viewportMipTexture",jc),Rr("ViewportTextureNode",Hc);let qc=null;class Xc extends Hc{constructor(e=Vc,t=null){null===qc&&(qc=new N),super(e,t,qc)}}const Yc=pi(Xc);Vr("viewportDepthTexture",Yc),Rr("ViewportDepthTextureNode",Xc);class Kc extends Ar{constructor(e,t=null){super("float"),this.scope=e,this.valueNode=t,this.isViewportDepthNode=!0}generate(e){const{scope:t}=this;return t===Kc.DEPTH_PIXEL?e.getFragDepth():super.generate(e)}setup(){const{scope:e}=this;let t=null;if(e===Kc.DEPTH)t=Qc(Ll.z,Ou,Uu);else if(e===Kc.DEPTH_TEXTURE){const e=this.valueNode||Yc(),s=ed(e,Ou,Uu);t=Qc(s,Ou,Uu)}else e===Kc.DEPTH_PIXEL&&null!==this.valueNode&&(t=td().assign(this.valueNode));return t}}const Qc=(e,t,s)=>e.add(t).div(t.sub(s)),Zc=(e,t,s)=>t.sub(s).mul(e).sub(t),Jc=(e,t,s)=>t.add(e).mul(s).div(t.sub(s).mul(e)),ed=(e,t,s)=>t.mul(s).div(s.sub(t).mul(e).sub(s));Kc.DEPTH="depth",Kc.DEPTH_TEXTURE="depthTexture",Kc.DEPTH_PIXEL="depthPixel";const td=pi(Kc,Kc.DEPTH_PIXEL),sd=gi(Kc,Kc.DEPTH),rd=pi(Kc,Kc.DEPTH_TEXTURE),id=gi(Kc,Kc.DEPTH_PIXEL);id.assign=e=>td(e),Rr("ViewportDepthNode",Kc);class nd extends Ar{constructor(e=nd.DEFAULT){super(),this.scope=e}setup(e){super.setup(e);const t=e.clippingContext,{localClipIntersection:s,localClippingCount:r,globalClippingCount:i}=t,n=i+r,o=s?n-r:n;return this.scope===nd.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(t.planes,n,o):this.setupDefault(t.planes,n,o)}setupAlphaToCoverage(e,t,s){return fi((()=>{const r=mu(e),i=Mn("float","distanceToPlane"),n=Mn("float","distanceToGradient"),o=Mn("float","clipOpacity");let a;if(o.assign(1),sc(s,(({i:e})=>{a=r.element(e),i.assign(Ll.dot(a.xyz).negate().add(a.w)),n.assign(i.fwidth().div(2)),o.mulAssign(Wa(n.negate(),n,i)),o.equal(0).discard()})),s<t){const e=Mn("float","unionclipOpacity");e.assign(1),sc({start:s,end:t},(({i:t})=>{a=r.element(t),i.assign(Ll.dot(a.xyz).negate().add(a.w)),n.assign(i.fwidth().div(2)),e.mulAssign(Wa(n.negate(),n,i).oneMinus())})),o.mulAssign(e.oneMinus())}Bn.a.mulAssign(o),Bn.a.equal(0).discard()}))()}setupDefault(e,t,s){return fi((()=>{const r=mu(e);let i;if(sc(s,(({i:e})=>{i=r.element(e),Ll.dot(i.xyz).greaterThan(i.w).discard()})),s<t){const e=Mn("bool","clipped");e.assign(!0),sc({start:s,end:t},(({i:t})=>{i=r.element(t),e.assign(Ll.dot(i.xyz).greaterThan(i.w).and(e))})),e.discard()}}))()}}nd.ALPHA_TO_COVERAGE="alphaToCoverage",nd.DEFAULT="default";class od extends Ar{constructor(){super("bool"),this.isFrontFacingNode=!0}generate(e){return e.getFrontFacing()}}const ad=gi(od),ud=_i(ad).mul(2).sub(1);Rr("FrontFacingNode",od);const ld=new Map;class cd extends R{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.type,this.forceSinglePass=!1,this.fog=!0,this.lights=!0,this.normals=!0,this.colorSpaced=!0,this.lightsNode=null,this.envNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.depthNode=null,this.shadowNode=null,this.outputNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+fr(this)}build(e){this.setup(e)}setup(e){let t;e.addStack(),e.stack.outputNode=this.vertexNode||this.setupPosition(e),e.addFlow("vertex",e.removeStack()),e.addStack();const s=this.setupClipping(e);if(null===this.fragmentNode){!0===this.depthWrite&&this.setupDepth(e),!0===this.normals&&this.setupNormal(e),this.setupDiffuseColor(e),this.setupVariants(e);const r=this.setupLighting(e);null!==s&&e.stack.add(s),t=this.setupOutput(e,Ui(r,Bn.a)),Hn.assign(t),null!==this.outputNode&&(t=this.outputNode)}else t=this.setupOutput(e,this.fragmentNode);e.stack.outputNode=t,e.addFlow("fragment",e.removeStack())}setupClipping(e){const{globalClippingCount:t,localClippingCount:s}=e.clippingContext;let r=null;return(t||s)&&(this.alphaToCoverage?r=ci(new nd(nd.ALPHA_TO_COVERAGE)):e.stack.add(ci(new nd))),r}setupDepth(e){const{renderer:t}=e;let s=this.depthNode;if(null===s&&!0===t.logarithmicDepthBuffer){s=Dl().w.add(1).log2().mul(Lu).mul(.5)}null!==s&&id.assign(s).append()}setupPosition(e){const{object:t}=e,s=t.geometry;var r;e.addStack(),(s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color)&&lc(t).append(),!0===t.isSkinnedMesh&&(r=t,ci(new Jl(r,!0))).append(),t.instanceMatrix&&!0===t.instanceMatrix.isInstancedBufferAttribute&&!0===e.isAvailable("instance")&&Wl(t).append(),null!==this.positionNode&&Bl.assign(this.positionNode);const i=Dl();return e.context.vertex=e.removeStack(),e.context.mvp=i,i}setupDiffuseColor({geometry:e}){let t=this.colorNode?Ui(this.colorNode):nl;!0===this.vertexColors&&e.hasAttribute("color")&&(t=Ui(t.xyz.mul(an("color","vec3")),t.a)),Bn.assign(t);const s=this.opacityNode?_i(this.opacityNode):ul;if(Bn.a.assign(Bn.a.mul(s)),null!==this.alphaTestNode||this.alphaTest>0){const e=null!==this.alphaTestNode?_i(this.alphaTestNode):il;Bn.a.lessThanEqual(e).discard()}}setupVariants(){}setupNormal(){if(!0===this.flatShading){const e=Ll.dFdx().cross(Ll.dFdy()).normalize();Ju.assign(e.mul(ud))}else{const e=this.normalNode?Mi(this.normalNode):gl;Ju.assign(e.mul(ud))}}getEnvNode(e){let t=null;return this.envNode?t=this.envNode:this.envMap?t=this.envMap.isCubeTexture?pc(this.envMap):uu(this.envMap):e.environmentNode&&(t=e.environmentNode),t}setupLights(e){const t=this.getEnvNode(e),s=[];t&&s.push(new Mc(t)),e.material.aoMap&&s.push(new _c(uu(e.material.aoMap)));let r=this.lightsNode||e.lightsNode;return s.length>0&&(r=bc([...r.lightNodes,...s])),r}setupLightingModel(){}setupLighting(e){const{material:t}=e,{backdropNode:s,backdropAlphaNode:r,emissiveNode:i}=this,n=!0===this.lights||null!==this.lightsNode?this.setupLights(e):null;let o=Bn.rgb;if(n&&!1!==n.hasLight){const t=this.setupLightingModel(e);o=Sc(n,t,s,r)}else null!==s&&(o=Mi(null!==r?ka(o,s,r):s));return(i&&!0===i.isNode||t.emissive&&!0===t.emissive.isColor)&&(o=o.add(Mi(i||al))),o}setupOutput(e,t){const s=e.renderer,r=e.toneMappingNode;if(!0===this.toneMapped&&r&&(t=Ui(r.context({color:t.rgb}),t.a)),!0===this.fog){const s=e.fogNode;s&&(t=Ui(s.mixAssign(t.rgb),t.a))}if(!0===this.colorSpaced){const e=s.currentColorSpace;e!==h&&e!==C&&(t=t.linearToColorSpace(e))}return t}setDefaultValues(e){for(const t in e){const s=e[t];void 0===this[t]&&(this[t]=s,s&&s.clone&&(this[t]=s.clone()))}Object.assign(this.defines,e.defines);const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const e in t)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,e)&&void 0!==t[e].get&&Object.defineProperty(this.constructor.prototype,e,t[e])}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{},nodes:{}});const s=E.prototype.toJSON.call(this,e),r=Tr(this);s.inputNodes={};for(const{property:t,childNode:i}of r)s.inputNodes[t]=i.toJSON(e).uuid;function i(e){const t=[];for(const s in e){const r=e[s];delete r.metadata,t.push(r)}return t}if(t){const t=i(e.textures),r=i(e.images),n=i(e.nodes);t.length>0&&(s.textures=t),r.length>0&&(s.images=r),n.length>0&&(s.nodes=n)}return s}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.positionNode=e.positionNode,this.depthNode=e.depthNode,this.shadowNode=e.shadowNode,this.outputNode=e.outputNode,this.fragmentNode=e.fragmentNode,this.vertexNode=e.vertexNode,super.copy(e)}static fromMaterial(e){if(!0===e.isNodeMaterial)return e;const t=hd(e.type.replace("Material","NodeMaterial"));if(void 0===t)throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);for(const s in e)t[s]=e[s];return t}}function dd(e,t){if("function"!=typeof t||!e)throw new Error(`Node material ${e} is not a class`);ld.has(e)||(ld.set(e,t),t.type=e)}function hd(e){const t=ld.get(e);if(void 0!==t)return new t}dd("NodeMaterial",cd);class pd{constructor(e,t=null){this.name=e,this.value=t,this.boundary=0,this.itemSize=0,this.offset=0}setValue(e){this.value=e}getValue(){return this.value}}class gd extends pd{constructor(e,t=0){super(e,t),this.isFloatUniform=!0,this.boundary=4,this.itemSize=1}}class md extends pd{constructor(e,t=new a){super(e,t),this.isVector2Uniform=!0,this.boundary=8,this.itemSize=2}}class fd extends pd{constructor(e,t=new u){super(e,t),this.isVector3Uniform=!0,this.boundary=16,this.itemSize=3}}class Td extends pd{constructor(e,t=new s){super(e,t),this.isVector4Uniform=!0,this.boundary=16,this.itemSize=4}}class xd extends pd{constructor(e,t=new o){super(e,t),this.isColorUniform=!0,this.boundary=16,this.itemSize=3}}class yd extends pd{constructor(e,s=new t){super(e,s),this.isMatrix3Uniform=!0,this.boundary=48,this.itemSize=12}}class bd extends pd{constructor(e,t=new l){super(e,t),this.isMatrix4Uniform=!0,this.boundary=64,this.itemSize=16}}class Nd extends gd{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class _d extends md{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class vd extends fd{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Sd extends Td{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Ad extends xd{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Rd extends yd{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Cd extends bd{constructor(e){super(e.name,e.value),this.nodeUniform=e}getValue(){return this.nodeUniform.value}}class Ed extends Ar{constructor(e,t,s=null){super(),this.condNode=e,this.ifNode=t,this.elseNode=s}getNodeType(e){const t=this.ifNode.getNodeType(e);if(null!==this.elseNode){const s=this.elseNode.getNodeType(e);if(e.getTypeLength(s)>e.getTypeLength(t))return s}return t}generate(e,t){const s=this.getNodeType(e),r={tempWrite:!1},i=e.getDataFromNode(this);if(void 0!==i.nodeProperty)return i.nodeProperty;const{ifNode:n,elseNode:o}=this,a="void"!==t,u=a?Mn(s).build(e):"";i.nodeProperty=u;const l=mn(this.condNode).build(e,"bool");e.addFlowCode(`\n${e.tab}if ( ${l} ) {\n\n`).addFlowTab();let c=mn(n,r).build(e,s);if(c&&(c=a?u+" = "+c+";":"return "+c+";"),e.removeFlowTab().addFlowCode(e.tab+"\t"+c+"\n\n"+e.tab+"}"),null!==o){e.addFlowCode(" else {\n\n").addFlowTab();let t=mn(o,r).build(e,s);t&&(t=a?u+" = "+t+";":"return "+t+";"),e.removeFlowTab().addFlowCode(e.tab+"\t"+t+"\n\n"+e.tab+"}\n\n")}else e.addFlowCode("\n\n");return e.format(u,s,t)}}const wd=pi(Ed);Vr("cond",wd),Rr("CondNode",Ed);class Md extends Ar{constructor(e=null){super(),this.nodes=[],this.outputNode=null,this.parent=e,this._currentCond=null,this.isStackNode=!0}getNodeType(e){return this.outputNode?this.outputNode.getNodeType(e):"void"}add(e){return this.nodes.push(e),this}if(e,t){const s=new li(t);return this._currentCond=wd(e,s),this.add(this._currentCond)}elseif(e,t){const s=new li(t),r=wd(e,s);return this._currentCond.elseNode=r,this._currentCond=r,this}else(e){return this._currentCond.elseNode=new li(e),this}build(e,...t){const s=xi();Ti(this);for(const t of this.nodes)t.build(e,"void");return Ti(s),this.outputNode?this.outputNode.build(e,...t):super.build(e,...t)}}const Fd=pi(Md);Rr("StackNode",Md);class Bd extends w{constructor(e=1,t={}){super(e,t),this.isCubeRenderTarget=!0}fromEquirectangularTexture(e,t){const s=t.minFilter,r=t.generateMipmaps;t.generateMipmaps=!0,this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i=new M(5,5,5),n=Rc(Ul),o=hd("MeshBasicNodeMaterial");o.colorNode=uu(t,n,0),o.side=F,o.blending=B;const a=new O(i,o),u=new U;u.add(a),t.minFilter===A&&(t.minFilter=L);return new I(1,10,this).update(e,u),t.minFilter=s,t.currentGenerateMipmaps=r,a.geometry.dispose(),a.material.dispose(),this}}const Od=new Ds,Ud=new Map([[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),Ld=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),Id=e=>(e=Number(e))+(e%1?"":".0");class Pd{constructor(e,t,s,r=null,i=null){this.object=e,this.material=i||e&&e.material||null,this.geometry=e&&e.geometry||null,this.renderer=t,this.parser=s,this.scene=r,this.nodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.hashNodes={},this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.toneMappingNode=null,this.clippingContext=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:[]},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.structs={vertex:[],fragment:[],compute:[],index:0},this.bindings={vertex:[],fragment:[],compute:[]},this.bindingsOffset={vertex:0,fragment:0,compute:0},this.bindingsArray=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.codes={},this.vars={},this.flow={code:""},this.chaining=[],this.stack=Fd(),this.stacks=[],this.tab="\t",this.currentFunctionNode=null,this.context={keywords:new En,material:this.material},this.cache=new dn,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null}getRenderTarget(e,t,s){return new P(e,t,s)}getCubeRenderTarget(e,t){return new Bd(e,t)}includes(e){return this.nodes.includes(e)}_getSharedBindings(e){const t=[];for(const s of e)if(!0===s.shared){const e=s.getNodes();let r=Od.get(e);void 0===r&&(Od.set(e,s),r=s),t.push(r)}else t.push(s);return t}getBindings(){let e=this.bindingsArray;if(null===e){const t=this.bindings;this.bindingsArray=e=this._getSharedBindings(null!==this.material?[...t.vertex,...t.fragment]:t.compute)}return e}setHashNode(e,t){this.hashNodes[t]=e}addNode(e){!1===this.nodes.includes(e)&&(this.nodes.push(e),this.setHashNode(e,e.getHash(this)))}buildUpdateNodes(){for(const e of this.nodes){const t=e.getUpdateType(),s=e.getUpdateBeforeType();t!==cr.NONE&&this.updateNodes.push(e.getSelf()),s!==cr.NONE&&this.updateBeforeNodes.push(e)}}get currentNode(){return this.chaining[this.chaining.length-1]}addChain(e){this.chaining.push(e)}removeChain(e){if(this.chaining.pop()!==e)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(e){return e}getNodeFromHash(e){return this.hashNodes[e]}addFlow(e,t){return this.flowNodes[e].push(t),t}setContext(e){this.context=e}getContext(){return this.context}setCache(e){this.cache=e}getCache(){return this.cache}isAvailable(){return!1}getVertexIndex(){}getInstanceIndex(){}getFrontFacing(){}getFragCoord(){}isFlipY(){return!1}generateTexture(){}generateTextureLod(){}generateConst(e,t=null){if(null===t&&("float"===e||"int"===e||"uint"===e?t=0:"bool"===e?t=!1:"color"===e?t=new o:"vec2"===e?t=new a:"vec3"===e?t=new u:"vec4"===e&&(t=new s)),"float"===e)return Id(t);if("int"===e)return`${Math.round(t)}`;if("uint"===e)return t>=0?`${Math.round(t)}u`:"0u";if("bool"===e)return t?"true":"false";if("color"===e)return`${this.getType("vec3")}( ${Id(t.r)}, ${Id(t.g)}, ${Id(t.b)} )`;const r=this.getTypeLength(e),i=this.getComponentType(e),n=e=>this.generateConst(i,e);if(2===r)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)} )`;if(3===r)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)}, ${n(t.z)} )`;if(4===r)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)}, ${n(t.z)}, ${n(t.w)} )`;if(r>4&&t&&(t.isMatrix3||t.isMatrix4))return`${this.getType(e)}( ${t.elements.map(n).join(", ")} )`;if(r>4)return`${this.getType(e)}()`;throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`)}getType(e){return"color"===e?"vec3":e}generateMethod(e){return e}hasGeometryAttribute(e){return this.geometry&&void 0!==this.geometry.getAttribute(e)}getAttribute(e,t){const s=this.attributes;for(const t of s)if(t.name===e)return t;const r=new vn(e,t);return s.push(r),r}getPropertyName(e){return e.name}isVector(e){return/vec\d/.test(e)}isMatrix(e){return/mat\d/.test(e)}isReference(e){return"void"===e||"property"===e||"sampler"===e||"texture"===e||"cubeTexture"===e||"storageTexture"===e}needsColorSpaceToLinear(){return!1}getTextureColorSpaceFromMap(e){let t;return t=e&&e.isTexture?e.colorSpace:e&&e.isWebGLRenderTarget?e.texture.colorSpace:C,t}getComponentType(e){if("float"===(e=this.getVectorType(e))||"bool"===e||"int"===e||"uint"===e)return e;const t=/(b|i|u|)(vec|mat)([2-4])/.exec(e);return null===t?null:"b"===t[1]?"bool":"i"===t[1]?"int":"u"===t[1]?"uint":"float"}getVectorType(e){return"color"===e?"vec3":"texture"===e||"cubeTexture"===e||"storageTexture"===e?"vec4":e}getTypeFromLength(e,t="float"){if(1===e)return t;const s=Ud.get(e);return("float"===t?"":t[0])+s}getTypeFromArray(e){return Ld.get(e.constructor)}getTypeFromAttribute(e){let t=e;e.isInterleavedBufferAttribute&&(t=e.data);const s=t.array,r=e.itemSize,i=e.normalized;let n;return e instanceof D||!0===i||(n=this.getTypeFromArray(s)),this.getTypeFromLength(r,n)}getTypeLength(e){const t=this.getVectorType(e),s=/vec([2-4])/.exec(t);return null!==s?Number(s[1]):"float"===t||"bool"===t||"int"===t||"uint"===t?1:!0===/mat2/.test(e)?4:!0===/mat3/.test(e)?9:!0===/mat4/.test(e)?16:0}getVectorFromMatrix(e){return e.replace("mat","vec")}changeComponentType(e,t){return this.getTypeFromLength(this.getTypeLength(e),t)}getIntegerType(e){const t=this.getComponentType(e);return"int"===t||"uint"===t?e:this.changeComponentType(e,"int")}addStack(){return this.stack=Fd(this.stack),this.stacks.push(xi()||this.stack),Ti(this.stack),this.stack}removeStack(){const e=this.stack;return this.stack=e.parent,Ti(this.stacks.pop()),e}getDataFromNode(e,t=this.shaderStage,s=null){let r=(s=null===s?e.isGlobal(this)?this.globalCache:this.cache:s).getNodeData(e);return void 0===r&&(r={},s.setNodeData(e,r)),void 0===r[t]&&(r[t]={}),r[t]}getNodeProperties(e,t="any"){const s=this.getDataFromNode(e,t);return s.properties||(s.properties={outputNode:null})}getBufferAttributeFromNode(e,t){const s=this.getDataFromNode(e);let r=s.bufferAttribute;if(void 0===r){const i=this.uniforms.index++;r=new vn("nodeAttribute"+i,t,e),this.bufferAttributes.push(r),s.bufferAttribute=r}return r}getStructTypeFromNode(e,t=this.shaderStage){const s=this.getDataFromNode(e,t);if(void 0===s.structType){const r=this.structs.index++;e.name=`StructType${r}`,this.structs[t].push(e),s.structType=e}return e}getUniformFromNode(e,t,s=this.shaderStage,r=null){const i=this.getDataFromNode(e,s,this.globalCache);let n=i.uniform;if(void 0===n){const o=this.uniforms.index++;n=new Sn(r||"nodeUniform"+o,t,e),this.uniforms[s].push(n),i.uniform=n}return n}getVarFromNode(e,t=null,s=e.getNodeType(this),r=this.shaderStage){const i=this.getDataFromNode(e,r);let n=i.variable;if(void 0===n){const e=this.vars[r]||(this.vars[r]=[]);null===t&&(t="nodeVar"+e.length),n=new An(t,s),e.push(n),i.variable=n}return n}getVaryingFromNode(e,t=null,s=e.getNodeType(this)){const r=this.getDataFromNode(e,"any");let i=r.varying;if(void 0===i){const e=this.varyings,n=e.length;null===t&&(t="nodeVarying"+n),i=new Rn(t,s),e.push(i),r.varying=i}return i}getCodeFromNode(e,t,s=this.shaderStage){const r=this.getDataFromNode(e);let i=r.code;if(void 0===i){const e=this.codes[s]||(this.codes[s]=[]),n=e.length;i=new Cn("nodeCode"+n,t),e.push(i),r.code=i}return i}addLineFlowCode(e){return""===e||(e=this.tab+e,/;\s*$/.test(e)||(e+=";\n"),this.flow.code+=e),this}addFlowCode(e){return this.flow.code+=e,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(e){return this.flowsData.get(e)}flowNode(e){const t=e.getNodeType(this),s=this.flowChildNode(e,t);return this.flowsData.set(e,s),s}buildFunctionNode(e){const t=new to,s=this.currentFunctionNode;return this.currentFunctionNode=t,t.code=this.buildFunctionCode(e),this.currentFunctionNode=s,t}flowShaderNode(e){const t=e.layout;let s;if(e.isArrayInput){s=[];for(const e of t.inputs)s.push(new Xn(e.type,e.name))}else{s={};for(const e of t.inputs)s[e.name]=new Xn(e.type,e.name)}e.layout=null;const r=e.call(s),i=this.flowStagesNode(r,t.type);return e.layout=t,i}flowStagesNode(e,t=null){const s=this.flow,r=this.vars,i=this.buildStage,n={code:""};this.flow=n,this.vars={};for(const s of pr)this.setBuildStage(s),n.result=e.build(this,t);return n.vars=this.getVars(this.shaderStage),this.flow=s,this.vars=r,this.setBuildStage(i),n}getFunctionOperator(){return null}flowChildNode(e,t=null){const s=this.flow,r={code:""};return this.flow=r,r.result=e.build(this,t),this.flow=s,r}flowNodeFromShaderStage(e,t,s=null,r=null){const i=this.shaderStage;this.setShaderStage(e);const n=this.flowChildNode(t,s);return null!==r&&(n.code+=`${this.tab+r} = ${n.result};\n`),this.flowCode[e]=this.flowCode[e]+n.code,this.setShaderStage(i),n}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){}getVaryings(){}getVar(e,t){return`${this.getType(e)} ${t}`}getVars(e){let t="";const s=this.vars[e];if(void 0!==s)for(const e of s)t+=`${this.getVar(e.type,e.name)}; `;return t}getUniforms(){}getCodes(e){const t=this.codes[e];let s="";if(void 0!==t)for(const e of t)s+=e.code+"\n";return s}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(e){this.shaderStage=e}getShaderStage(){return this.shaderStage}setBuildStage(e){this.buildStage=e}getBuildStage(){return this.buildStage}buildCode(){}build(e=!0){const{object:t,material:s}=this;e&&(null!==s?cd.fromMaterial(s).build(this):this.addFlow("compute",t));for(const e of pr){this.setBuildStage(e),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const t of gr){this.setShaderStage(t);const s=this.flowNodes[t];for(const t of s)"generate"===e?this.flowNode(t):t.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this.buildUpdateNodes(),this}getNodeUniform(e,t){if("float"===t)return new Nd(e);if("vec2"===t)return new _d(e);if("vec3"===t)return new vd(e);if("vec4"===t)return new Sd(e);if("color"===t)return new Ad(e);if("mat3"===t)return new Rd(e);if("mat4"===t)return new Cd(e);throw new Error(`Uniform "${t}" not declared.`)}createNodeMaterial(e="NodeMaterial"){return hd(e)}format(e,t,s){if((t=this.getVectorType(t))===(s=this.getVectorType(s))||null===s||this.isReference(s))return e;const r=this.getTypeLength(t),i=this.getTypeLength(s);return r>4||i>4||0===i?e:r===i?`${this.getType(s)}( ${e} )`:r>i?this.format(`${e}.${"xyz".slice(0,i)}`,this.getTypeFromLength(i,this.getComponentType(t)),s):4===i&&r>1?`${this.getType(s)}( ${this.format(e,t,"vec3")}, 1.0 )`:2===r?`${this.getType(s)}( ${this.format(e,t,"vec2")}, 0.0 )`:(1===r&&i>1&&t[0]!==s[0]&&(e=`${this.getType(this.getComponentType(s))}( ${e} )`),`${this.getType(s)}( ${e} )`)}getSignature(){return`// Three.js r${V} - NodeMaterial System\n`}}class Dd{constructor(){this.time=0,this.deltaTime=0,this.frameId=0,this.renderId=0,this.startTime=null,this.updateMap=new WeakMap,this.updateBeforeMap=new WeakMap,this.renderer=null,this.material=null,this.camera=null,this.object=null,this.scene=null}_getMaps(e,t){let s=e.get(t);return void 0===s&&(s={renderMap:new WeakMap,frameMap:new WeakMap},e.set(t,s)),s}updateBeforeNode(e){const t=e.getUpdateBeforeType(),s=e.setReference(this);if(t===cr.FRAME){const{frameMap:t}=this._getMaps(this.updateBeforeMap,s);t.get(e)!==this.frameId&&!1!==e.updateBefore(this)&&t.set(e,this.frameId)}else if(t===cr.RENDER){const{renderMap:t}=this._getMaps(this.updateBeforeMap,s);t.get(e)!==this.renderId&&!1!==e.updateBefore(this)&&t.set(e,this.renderId)}else t===cr.OBJECT&&e.updateBefore(this)}updateNode(e){const t=e.getUpdateType(),s=e.setReference(this);if(t===cr.FRAME){const{frameMap:t}=this._getMaps(this.updateMap,s);t.get(e)!==this.frameId&&!1!==e.update(this)&&t.set(e,this.frameId)}else if(t===cr.RENDER){const{renderMap:t}=this._getMaps(this.updateMap,s);t.get(e)!==this.renderId&&!1!==e.update(this)&&t.set(e,this.renderId)}else t===cr.OBJECT&&e.update(this)}update(){this.frameId++,void 0===this.lastTime&&(this.lastTime=performance.now()),this.deltaTime=(performance.now()-this.lastTime)/1e3,this.lastTime=performance.now(),this.time+=this.deltaTime}}class Vd{constructor(e,t,s=null,r="",i=!1){this.type=e,this.name=t,this.count=s,this.qualifier=r,this.isConst=i}}Vd.isNodeFunctionInput=!0;class Gd extends Ar{constructor(e){super(),this.types=e,this.isStructTypeNode=!0}getMemberTypes(){return this.types}}Rr("StructTypeNode",Gd);class kd extends Ar{constructor(...e){super(),this.isOutputStructNode=!0,this.members=e}setup(e){super.setup(e);const t=this.members,s=[];for(let r=0;r<t.length;r++)s.push(t[r].getNodeType(e));this.nodeType=e.getStructTypeFromNode(new Gd(s)).name}generate(e,t){const s=e.getVarFromNode(this);s.isOutputStructVar=!0;const r=e.getPropertyName(s),i=this.members,n=""!==r?r+".":"";for(let s=0;s<i.length;s++){const r=i[s].build(e,t);e.addLineFlowCode(`${n}m${s} = ${r}`)}return r}}const zd=pi(kd);Rr("OutputStructNode",kd);class $d extends Ar{constructor(e){super(),this.seedNode=e}setup(){const e=this.seedNode.uint().mul(747796405).add(2891336453),t=e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);return t.shiftRight(22).bitXor(t).float().mul(1/2**32)}}const Hd=pi($d);Vr("hash",Hd),Rr("HashNode",$d);const Wd=(e,t)=>Ua(No(4,e.mul(bo(1,e))),t),jd=(e,t)=>e.lessThan(.5)?Wd(e.mul(2),t).div(2):bo(1,Wd(No(bo(1,e),2),t).div(2)),qd=(e,t,s)=>Ua(_o(Ua(e,t),yo(Ua(e,t),Ua(bo(1,e),s))),1/t),Xd=(e,t)=>oa($o.mul(t.mul(e).sub(1))).div($o.mul(t.mul(e).sub(1)));Vr("parabola",Wd),Vr("gain",jd),Vr("pcurve",qd),Vr("sinc",Xd);const Yd=fi((([e])=>e.fract().sub(.5).abs())),Kd=fi((([e])=>Mi(Yd(e.z.add(Yd(e.y.mul(1)))),Yd(e.z.add(Yd(e.x.mul(1)))),Yd(e.y.add(Yd(e.x.mul(1))))))),Qd=fi((([e,t,s])=>{const r=Mi(e).toVar(),i=_i(1.4).toVar(),n=_i(0).toVar(),o=Mi(r).toVar();return sc({start:_i(0),end:_i(3),type:"float",condition:"<="},(()=>{const e=Mi(Kd(o.mul(2))).toVar();r.addAssign(e.add(s.mul(_i(.1).mul(t)))),o.mulAssign(1.8),i.mulAssign(1.5),r.mulAssign(1.2);const a=_i(Yd(r.z.add(Yd(r.x.add(Yd(r.y)))))).toVar();n.addAssign(a.div(i)),o.addAssign(.14)})),n}));let Zd;Yd.setLayout({name:"tri",type:"float",inputs:[{name:"x",type:"float"}]}),Kd.setLayout({name:"tri3",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),Qd.setLayout({name:"triNoise3D",type:"float",inputs:[{name:"p",type:"vec3"},{name:"spd",type:"float"},{name:"time",type:"float"}]});class Jd extends Ed{constructor(e){Zd=Zd||iu("discard"),super(e,Zd)}}const eh=pi(Jd),th=e=>eh(e).append();Vr("discard",th),Rr("DiscardNode",Jd);class sh extends Ar{constructor(e=[],...t){super(),this.functionNodes=e,this.parametersNodes=t,this._candidateFnCall=null}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(e){const t=this.parametersNodes;let s=this._candidateFnCall;if(null===s){let r=null,i=-1;for(const s of this.functionNodes){const n=s.shaderNode.layout;if(null===n)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const o=n.inputs;if(t.length===o.length){let n=0;for(let s=0;s<t.length;s++){const r=t[s],i=o[s];r.getNodeType(e)===i.type?n++:n=0}n>i&&(r=s,i=n)}}this._candidateFnCall=s=r(...t)}return s}}const rh=pi(sh),ih=e=>(...t)=>rh(e,...t);Rr("FunctionOverloadingNode",sh);class nh extends Er{constructor(){super("vec2")}setup(){const e=Mi(Il.z,0,Il.x.negate()).normalize(),t=Il.cross(e);return Ri(e.dot(Ju),t.dot(Ju)).mul(.495).add(.5)}}const oh=gi(nh);Rr("MatcapUVNode",nh);class ah extends ho{constructor(e=ah.LOCAL,t=1,s=0){super(s),this.scope=e,this.scale=t,this.updateType=cr.FRAME}update(e){const t=this.scope,s=this.scale;t===ah.LOCAL?this.value+=e.deltaTime*s:t===ah.DELTA?this.value=e.deltaTime*s:t===ah.FRAME?this.value=e.frameId:this.value=e.time*s}serialize(e){super.serialize(e),e.scope=this.scope,e.scale=this.scale}deserialize(e){super.deserialize(e),this.scope=e.scope,this.scale=e.scale}}ah.LOCAL="local",ah.GLOBAL="global",ah.DELTA="delta",ah.FRAME="frame";const uh=(e,t=0)=>ci(new ah(ah.LOCAL,e,t)),lh=(e,t=0)=>ci(new ah(ah.GLOBAL,e,t)),ch=(e,t=0)=>ci(new ah(ah.DELTA,e,t)),dh=gi(ah,ah.FRAME).uint();Rr("TimerNode",ah);class hh extends Ar{constructor(e=hh.SINE,t=uh()){super(),this.method=e,this.timeNode=t}getNodeType(e){return this.timeNode.getNodeType(e)}setup(){const e=this.method,t=ci(this.timeNode);let s=null;return e===hh.SINE?s=t.add(.75).mul(2*Math.PI).sin().mul(.5).add(.5):e===hh.SQUARE?s=t.fract().round():e===hh.TRIANGLE?s=t.add(.5).fract().mul(2).sub(1).abs():e===hh.SAWTOOTH&&(s=t.fract()),s}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}hh.SINE="sine",hh.SQUARE="square",hh.TRIANGLE="triangle",hh.SAWTOOTH="sawtooth";const ph=pi(hh,hh.SINE),gh=pi(hh,hh.SQUARE),mh=pi(hh,hh.TRIANGLE),fh=pi(hh,hh.SAWTOOTH);Rr("OscNode",hh);class Th extends Er{constructor(e,t){super(),this.scope=e,this.node=t}getNodeType(e){return this.node.getNodeType(e)}setup(){const{scope:e,node:t}=this;let s=null;return e===Th.DIRECTION_TO_COLOR?s=t.mul(.5).add(.5):e===Th.COLOR_TO_DIRECTION&&(s=t.mul(2).sub(1)),s}}Th.DIRECTION_TO_COLOR="directionToColor",Th.COLOR_TO_DIRECTION="colorToDirection";const xh=pi(Th,Th.DIRECTION_TO_COLOR),yh=pi(Th,Th.COLOR_TO_DIRECTION);Vr("directionToColor",xh),Vr("colorToDirection",yh),Rr("PackingNode",Th);class bh extends Ar{constructor(e,t,s,r=_i(0),i=_i(1)){super(),this.node=e,this.inLowNode=t,this.inHighNode=s,this.outLowNode=r,this.outHighNode=i,this.doClamp=!0}setup(){const{node:e,inLowNode:t,inHighNode:s,outLowNode:r,outHighNode:i,doClamp:n}=this;let o=e.sub(t).div(s.sub(t));return!0===n&&(o=o.clamp()),o.mul(i.sub(r)).add(r)}}const Nh=pi(bh,null,null,{doClamp:!1}),_h=pi(bh);Vr("remap",Nh),Vr("remapClamp",_h),Rr("RemapNode",bh);class vh extends Er{constructor(e,t,s=Ri(.5)){super("vec2"),this.uvNode=e,this.rotationNode=t,this.centerNode=s}setup(){const{uvNode:e,rotationNode:t,centerNode:s}=this;return e.sub(s).rotate(t).add(s)}}const Sh=pi(vh);Vr("rotateUV",Sh),Rr("RotateUVNode",vh);class Ah extends Er{constructor(e,t){super(),this.positionNode=e,this.rotationNode=t}getNodeType(e){return this.positionNode.getNodeType(e)}setup(e){const{rotationNode:t,positionNode:s}=this;if("vec2"===this.getNodeType(e)){const e=t.cos(),r=t.sin();return Di(e,r,r.negate(),e).mul(s)}{const e=t,r=ji(Ui(1,0,0,0),Ui(0,aa(e.x),oa(e.x).negate(),0),Ui(0,oa(e.x),aa(e.x),0),Ui(0,0,0,1)),i=ji(Ui(aa(e.y),0,oa(e.y),0),Ui(0,1,0,0),Ui(oa(e.y).negate(),0,aa(e.y),0),Ui(0,0,0,1)),n=ji(Ui(aa(e.z),oa(e.z).negate(),0,0),Ui(oa(e.z),aa(e.z),0,0),Ui(0,0,1,0),Ui(0,0,0,1));return r.mul(i).mul(n).mul(Ui(s,1)).xyz}}}const Rh=pi(Ah);Vr("rotate",Rh),Rr("RotateNode",Ah);class Ch extends Ar{constructor(e,t=mo(),s=_i(0)){super("vec2"),this.countNode=e,this.uvNode=t,this.frameNode=s}setup(){const{frameNode:e,uvNode:t,countNode:s}=this,{width:r,height:i}=s,n=e.mod(r.mul(i)).floor(),o=n.mod(r),a=i.sub(n.add(1).div(r).ceil()),u=s.reciprocal(),l=Ri(o,a);return t.add(l).mul(u)}}const Eh=pi(Ch);Rr("SpriteSheetUVNode",Ch);class wh extends wr{constructor(e,t){super(e,t),this.isStorageArrayElementNode=!0}set storageBufferNode(e){this.node=e}get storageBufferNode(){return this.node}setup(e){return!1===e.isAvailable("storageBuffer")&&(this.node.instanceIndex||!0!==this.node.bufferObject||e.setupPBO(this.node)),super.setup(e)}generate(e,t){let s;const r=e.context.assign;if(!1===e.isAvailable("storageBuffer")){const{node:t}=this;s=t.instanceIndex||!0!==this.node.bufferObject||!0===r?t.build(e):e.generatePBO(this)}else s=super.generate(e);if(!0!==r){const r=this.getNodeType(e);s=e.format(s,r,t)}return s}}const Mh=pi(wh);Vr("storageElement",Mh),Rr("StorageArrayElementNode",wh);class Fh extends Ar{constructor(e,t=null,s=null,r=_i(1),i=Bl,n=Ku){super("vec4"),this.textureXNode=e,this.textureYNode=t,this.textureZNode=s,this.scaleNode=r,this.positionNode=i,this.normalNode=n}setup(){const{textureXNode:e,textureYNode:t,textureZNode:s,scaleNode:r,positionNode:i,normalNode:n}=this;let o=n.abs().normalize();o=o.div(o.dot(Mi(1)));const a=i.yz.mul(r),u=i.zx.mul(r),l=i.xy.mul(r),c=e.value,d=null!==t?t.value:c,h=null!==s?s.value:c,p=uu(c,a).mul(o.x),g=uu(d,u).mul(o.y),m=uu(h,l).mul(o.z);return yo(p,g,m)}}const Bh=pi(Fh),Oh=(...e)=>Bh(...e);Vr("triplanarTexture",Oh),Rr("TriplanarTexturesNode",Fh);const Uh=new e,Lh=new u,Ih=new u,Ph=new u,Dh=new l,Vh=new u(0,0,-1),Gh=new s,kh=new u,zh=new u,$h=new s,Hh=new a,Wh=new P,jh=Ri(Vc.x.oneMinus(),Vc.y);let qh=!1;class Xh extends au{constructor(e={}){super(Wh.texture,jh);const{target:t=new G,resolution:s=1,generateMipmaps:r=!1,bounces:i=!0}=e;this.target=t,this.resolution=s,this.generateMipmaps=r,this.bounces=i,this.updateBeforeType=i?cr.RENDER:cr.FRAME,this.virtualCameras=new WeakMap,this.renderTargets=new WeakMap}_updateResolution(e,t){const s=this.resolution;t.getDrawingBufferSize(Hh),e.setSize(Math.round(Hh.width*s),Math.round(Hh.height*s))}setup(e){return this._updateResolution(Wh,e.renderer),super.setup(e)}getTextureNode(){return this.textureNode}getVirtualCamera(e){let t=this.virtualCameras.get(e);return void 0===t&&(t=e.clone(),this.virtualCameras.set(e,t)),t}getRenderTarget(e){let t=this.renderTargets.get(e);return void 0===t&&(t=new P(0,0,{type:k}),!0===this.generateMipmaps&&(t.texture.minFilter=z,t.texture.generateMipmaps=!0),this.renderTargets.set(e,t)),t}updateBefore(e){if(!1===this.bounces&&qh)return!1;qh=!0;const{scene:t,camera:s,renderer:r,material:i}=e,{target:n}=this,o=this.getVirtualCamera(s),a=this.getRenderTarget(o);if(r.getDrawingBufferSize(Hh),this._updateResolution(a,r),Ih.setFromMatrixPosition(n.matrixWorld),Ph.setFromMatrixPosition(s.matrixWorld),Dh.extractRotation(n.matrixWorld),Lh.set(0,0,1),Lh.applyMatrix4(Dh),kh.subVectors(Ih,Ph),kh.dot(Lh)>0)return;kh.reflect(Lh).negate(),kh.add(Ih),Dh.extractRotation(s.matrixWorld),Vh.set(0,0,-1),Vh.applyMatrix4(Dh),Vh.add(Ph),zh.subVectors(Ih,Vh),zh.reflect(Lh).negate(),zh.add(Ih),o.coordinateSystem=s.coordinateSystem,o.position.copy(kh),o.up.set(0,1,0),o.up.applyMatrix4(Dh),o.up.reflect(Lh),o.lookAt(zh),o.near=s.near,o.far=s.far,o.updateMatrixWorld(),o.projectionMatrix.copy(s.projectionMatrix),Uh.setFromNormalAndCoplanarPoint(Lh,Ih),Uh.applyMatrix4(o.matrixWorldInverse),Gh.set(Uh.normal.x,Uh.normal.y,Uh.normal.z,Uh.constant);const u=o.projectionMatrix;$h.x=(Math.sign(Gh.x)+u.elements[8])/u.elements[0],$h.y=(Math.sign(Gh.y)+u.elements[9])/u.elements[5],$h.z=-1,$h.w=(1+u.elements[10])/u.elements[14],Gh.multiplyScalar(1/Gh.dot($h));u.elements[2]=Gh.x,u.elements[6]=Gh.y,u.elements[10]=Gh.z-0,u.elements[14]=Gh.w,this.value=a.texture,i.visible=!1;const l=r.getRenderTarget();r.setRenderTarget(a),r.render(t,o),r.setRenderTarget(l),i.visible=!0,qh=!1}}const Yh=e=>ci(new Xh(e));class Kh extends Ar{constructor(e=Kh.LOCAL){super("vec3"),this.scope=e}getHash(){return`bitangent-${this.scope}`}generate(e){const t=this.scope;let s;t===Kh.GEOMETRY?s=Yu.cross(ql):t===Kh.LOCAL?s=Ku.cross(Xl):t===Kh.VIEW?s=Qu.cross(Yl):t===Kh.WORLD&&(s=Zu.cross(Kl));const r=s.mul(ql.w).xyz;return ia(nn(r)).build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}Kh.GEOMETRY="geometry",Kh.LOCAL="local",Kh.VIEW="view",Kh.WORLD="world";const Qh=gi(Kh,Kh.GEOMETRY),Zh=gi(Kh,Kh.LOCAL),Jh=gi(Kh,Kh.VIEW),ep=gi(Kh,Kh.WORLD),tp=ia(Ju.cross(Ql).mul(ql.w)),sp=ia(tp.transformDirection(Iu));Rr("BitangentNode",Kh);const rp=zi(Yl,Jh,Qu),ip=Il.mul(rp),np=(e,t)=>e.sub(ip.mul(t));class op extends on{constructor(e=0){super(null,"vec4"),this.isVertexColorNode=!0,this.index=e}getAttributeName(){const e=this.index;return"color"+(e>0?e:"")}generate(e){const t=this.getAttributeName(e);let r;return r=!0===e.hasGeometryAttribute(t)?super.generate(e):e.generateConst(this.nodeType,new s(1,1,1,1)),r}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}const ap=(...e)=>ci(new op(...e));Rr("VertexColorNode",op);const up=1/6,lp=e=>No(up,No(e,No(e,e.negate().add(3)).sub(3)).add(1)),cp=e=>No(up,No(e,No(e,No(3,e).sub(6))).add(4)),dp=e=>No(up,No(e,No(e,No(-3,e).add(3)).add(3)).add(1)),hp=e=>No(up,Ua(e,3)),pp=e=>lp(e).add(cp(e)),gp=e=>dp(e).add(hp(e)),mp=e=>yo(-1,cp(e).div(lp(e).add(cp(e)))),fp=e=>yo(1,hp(e).div(dp(e).add(hp(e)))),Tp=(e,t,s)=>{const r=e.uvNode,i=No(r,t.zw).add(.5),n=sa(i),o=na(i),a=pp(o.x),u=gp(o.x),l=mp(o.x),c=fp(o.x),d=mp(o.y),h=fp(o.y),p=Ri(n.x.add(l),n.y.add(d)).sub(.5).mul(t.xy),g=Ri(n.x.add(c),n.y.add(d)).sub(.5).mul(t.xy),m=Ri(n.x.add(l),n.y.add(h)).sub(.5).mul(t.xy),f=Ri(n.x.add(c),n.y.add(h)).sub(.5).mul(t.xy),T=pp(o.y).mul(yo(a.mul(e.uv(p).level(s)),u.mul(e.uv(g).level(s)))),x=gp(o.y).mul(yo(a.mul(e.uv(m).level(s)),u.mul(e.uv(f).level(s))));return T.add(x)};class xp extends Er{constructor(e,t=_i(3)){super("vec4"),this.textureNode=e,this.blurNode=t}setup(){return((e,t)=>{const s=Ri(e.size(vi(t))),r=Ri(e.size(vi(t.add(1)))),i=_o(1,s),n=_o(1,r),o=Tp(e,Ui(i,s),sa(t)),a=Tp(e,Ui(n,r),ra(t));return na(t).mix(o,a)})(this.textureNode,this.blurNode)}}const yp=pi(xp);Vr("bicubic",yp),Rr("TextureBicubicNode",xp);class bp extends Ar{constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}const Np=gi(bp);Rr("PointUVNode",bp);class _p extends Ar{constructor(e=_p.BACKGROUND_BLURRINESS,t=null){super(),this.scope=e,this.scene=t}setup(e){const t=this.scope,s=null!==this.scene?this.scene:e.scene;let r;return t===_p.BACKGROUND_BLURRINESS?r=xu("backgroundBlurriness","float",s):t===_p.BACKGROUND_INTENSITY&&(r=xu("backgroundIntensity","float",s)),r}}_p.BACKGROUND_BLURRINESS="backgroundBlurriness",_p.BACKGROUND_INTENSITY="backgroundIntensity";const vp=gi(_p,_p.BACKGROUND_BLURRINESS),Sp=gi(_p,_p.BACKGROUND_INTENSITY);Rr("SceneNode",_p);class Ap extends du{constructor(e,t,s=0){super(e,t,s),this.isStorageBufferNode=!0,this.bufferObject=!1,this._attribute=null,this._varying=null}getInputType(){return"storageBuffer"}element(e){return Mh(this,e)}setBufferObject(e){return this.bufferObject=e,this}generate(e){if(e.isAvailable("storageBuffer"))return super.generate(e);const t=this.getNodeType(e);null===this._attribute&&(this._attribute=Gl(this.value),this._varying=nn(this._attribute));const s=this._varying.build(e,t);return e.registerTransform(s,this._attribute),s}}const Rp=(e,t,s)=>ci(new Ap(e,t,s)),Cp=(e,t,s)=>ci(new Ap(e,t,s).setBufferObject(!0));Rr("StorageBufferNode",Ap);class Ep extends au{constructor(e,t,s=null){super(e,t),this.storeNode=s,this.isStoreTextureNode=!0}getInputType(){return"storageTexture"}setup(e){super.setup(e);e.getNodeProperties(this).storeNode=this.storeNode}generate(e,t){let s;return s=null!==this.storeNode?this.generateStore(e):super.generate(e,t),s}generateStore(e){const t=e.getNodeProperties(this),{uvNode:s,storeNode:r}=t,i=super.generate(e,"property"),n=s.build(e,"uvec2"),o=r.build(e,"vec4"),a=e.generateTextureStore(e,i,n,o);e.addLineFlowCode(a)}}const wp=pi(Ep),Mp=(e,t,s)=>{const r=wp(e,t,s);return null!==s&&r.append(),r};Rr("TextureStoreNode",Ep);class Fp extends Tu{constructor(e,t,s=null){super(e,t,s),this.userData=s}update(e){this.reference=null!==this.userData?this.userData:e.object.userData,super.update(e)}}const Bp=(e,t,s)=>ci(new Fp(e,t,s));Rr("UserDataNode",Fp);const Op=fi((({base:e,blend:t})=>{const s=s=>t[s].lessThan(ko).cond(t[s],e[s].oneMinus().div(t[s]).oneMinus().max(0));return Mi(s("x"),s("y"),s("z"))})).setLayout({name:"burnColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),Up=fi((({base:e,blend:t})=>{const s=s=>t[s].equal(1).cond(t[s],e[s].div(t[s].oneMinus()).max(0));return Mi(s("x"),s("y"),s("z"))})).setLayout({name:"dodgeColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),Lp=fi((({base:e,blend:t})=>{const s=s=>e[s].oneMinus().mul(t[s].oneMinus()).oneMinus();return Mi(s("x"),s("y"),s("z"))})).setLayout({name:"screenColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),Ip=fi((({base:e,blend:t})=>{const s=s=>e[s].lessThan(.5).cond(e[s].mul(t[s],2),e[s].oneMinus().mul(t[s].oneMinus()).oneMinus());return Mi(s("x"),s("y"),s("z"))})).setLayout({name:"overlayColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]});class Pp extends Er{constructor(e,t,s){super(),this.blendMode=e,this.baseNode=t,this.blendNode=s}setup(){const{blendMode:e,baseNode:t,blendNode:s}=this,r={base:t,blend:s};let i=null;return e===Pp.BURN?i=Op(r):e===Pp.DODGE?i=Up(r):e===Pp.SCREEN?i=Lp(r):e===Pp.OVERLAY&&(i=Ip(r)),i}}Pp.BURN="burn",Pp.DODGE="dodge",Pp.SCREEN="screen",Pp.OVERLAY="overlay";const Dp=pi(Pp,Pp.BURN),Vp=pi(Pp,Pp.DODGE),Gp=pi(Pp,Pp.OVERLAY),kp=pi(Pp,Pp.SCREEN);Vr("burn",Dp),Vr("dodge",Vp),Vr("overlay",Gp),Vr("screen",kp),Rr("BlendModeNode",Pp);const zp=fi((({textureNode:e,bumpScale:t})=>{let s=e;if(!0!==s.isTextureNode&&s.traverse((e=>{!0===e.isTextureNode&&(s=e)})),!0!==s.isTextureNode)throw new Error("THREE.TSL: dHdxy_fwd() requires a TextureNode.");const r=_i(e),i=s.uvNode||mo(),n=t=>e.cache().context({getUV:()=>t,forceUVContext:!0});return Ri(_i(n(i.add(i.dFdx()))).sub(r),_i(n(i.add(i.dFdy()))).sub(r)).mul(t)})),$p=fi((e=>{const{surf_pos:t,surf_norm:s,dHdxy:r}=e,i=t.dFdx().normalize(),n=s,o=t.dFdy().normalize().cross(n),a=n.cross(i),u=i.dot(o).mul(ud),l=u.sign().mul(r.x.mul(o).add(r.y.mul(a)));return u.abs().mul(s).sub(l).normalize()}));class Hp extends Er{constructor(e,t=null){super("vec3"),this.textureNode=e,this.scaleNode=t}setup(){const e=null!==this.scaleNode?this.scaleNode:1,t=zp({textureNode:this.textureNode,bumpScale:e});return $p({surf_pos:Ll,surf_norm:Qu,dHdxy:t})}}const Wp=pi(Hp);Vr("bumpMap",Wp),Rr("BumpMapNode",Hp);const jp=fi((({color:e,adjustment:t})=>t.mix(eg(e.rgb),e.rgb))),qp=fi((({color:e,adjustment:t})=>{const s=yo(e.r,e.g,e.b).div(3),r=e.r.max(e.g.max(e.b)),i=r.sub(s).mul(t).mul(-3);return ka(e.rgb,r,i)})),Xp=fi((({color:e,adjustment:t})=>{const s=Mi(.57735,.57735,.57735),r=t.cos();return Mi(e.rgb.mul(r).add(s.cross(e.rgb).mul(t.sin()).add(s.mul(Ba(s,e.rgb).mul(r.oneMinus())))))}));class Yp extends Er{constructor(e,t,s=_i(1)){super("vec3"),this.method=e,this.colorNode=t,this.adjustmentNode=s}setup(){const{method:e,colorNode:t,adjustmentNode:s}=this,r={color:t,adjustment:s};let i=null;return e===Yp.SATURATION?i=jp(r):e===Yp.VIBRANCE?i=qp(r):e===Yp.HUE&&(i=Xp(r)),i}}Yp.SATURATION="saturation",Yp.VIBRANCE="vibrance",Yp.HUE="hue";const Kp=pi(Yp,Yp.SATURATION),Qp=pi(Yp,Yp.VIBRANCE),Zp=pi(Yp,Yp.HUE),Jp=Mi(.2125,.7154,.0721),eg=(e,t=Jp)=>Ba(e,t),tg=(e,t)=>ka(Mi(0),e,eg(e).sub(t).max(0));Vr("saturation",Kp),Vr("vibrance",Qp),Vr("hue",Zp),Vr("threshold",tg),Rr("ColorAdjustmentNode",Yp);const sg=fi((e=>{const{eye_pos:t,surf_norm:s,mapN:r,uv:i}=e,n=t.dFdx(),o=t.dFdy(),a=i.dFdx(),u=i.dFdy(),l=s,c=o.cross(l),d=l.cross(n),h=c.mul(a.x).add(d.mul(u.x)),p=c.mul(a.y).add(d.mul(u.y)),g=h.dot(h).max(p.dot(p)),m=ud.mul(g.inverseSqrt());return yo(h.mul(r.x,m),p.mul(r.y,m),l.mul(r.z)).normalize()}));class rg extends Er{constructor(e,t=null){super("vec3"),this.node=e,this.scaleNode=t,this.normalMapType=$}setup(e){const{normalMapType:t,scaleNode:s}=this;let r=this.node.mul(2).sub(1);null!==s&&(r=Mi(r.xy.mul(s),r.z));let i=null;if(t===H)i=$u.mul(r).normalize();else if(t===$){i=!0===e.hasGeometryAttribute("tangent")?rp.mul(r).normalize():sg({eye_pos:Ll,surf_norm:Qu,mapN:r,uv:mo()})}return i}}const ig=pi(rg);Vr("normalMap",ig),Rr("NormalMapNode",rg);class ng extends Er{constructor(e,t){super(),this.sourceNode=e,this.stepsNode=t}setup(){const{sourceNode:e,stepsNode:t}=this;return e.mul(t).floor().div(t)}}const og=pi(ng);Vr("posterize",og),Rr("PosterizeNode",ng);const ag=fi((({color:e,exposure:t})=>e.mul(t).clamp())),ug=fi((({color:e,exposure:t})=>(e=e.mul(t)).div(e.add(1)).clamp())),lg=fi((({color:e,exposure:t})=>{const s=(e=(e=e.mul(t)).sub(.004).max(0)).mul(e.mul(6.2).add(.5)),r=e.mul(e.mul(6.2).add(1.7)).add(.06);return s.div(r).pow(2.2)})),cg=fi((({color:e})=>{const t=e.mul(e.add(.0245786)).sub(90537e-9),s=e.mul(e.add(.432951).mul(.983729)).add(.238081);return t.div(s)})),dg=fi((({color:e,exposure:t})=>{const s=zi(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),r=zi(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return e=e.mul(t).div(.6),e=s.mul(e),e=cg({color:e}),(e=r.mul(e)).clamp()})),hg=zi(Mi(1.6605,-.1246,-.0182),Mi(-.5876,1.1329,-.1006),Mi(-.0728,-.0083,1.1187)),pg=zi(Mi(.6274,.0691,.0164),Mi(.3293,.9195,.088),Mi(.0433,.0113,.8956)),gg=fi((([e])=>{const t=Mi(e).toVar(),s=Mi(t.mul(t)).toVar(),r=Mi(s.mul(s)).toVar();return _i(15.5).mul(r.mul(s)).sub(No(40.14,r.mul(t))).add(No(31.96,r).sub(No(6.868,s.mul(t))).add(No(.4298,s).add(No(.1191,t).sub(.00232))))})),mg=fi((({color:e,exposure:t})=>{const s=Mi(e).toVar(),r=zi(Mi(.856627153315983,.137318972929847,.11189821299995),Mi(.0951212405381588,.761241990602591,.0767994186031903),Mi(.0482516061458583,.101439036467562,.811302368396859)),i=zi(Mi(1.1271005818144368,-.1413297634984383,-.14132976349843826),Mi(-.11060664309660323,1.157823702216272,-.11060664309660294),Mi(-.016493938717834573,-.016493938717834257,1.2519364065950405)),n=_i(-12.47393),o=_i(4.026069);return s.mulAssign(t),s.assign(pg.mul(s)),s.assign(r.mul(s)),s.assign(Ra(s,1e-10)),s.assign(Jo(s)),s.assign(s.sub(n).div(o.sub(n))),s.assign(za(s,0,1)),s.assign(gg(s)),s.assign(i.mul(s)),s.assign(Ua(Ra(Mi(0),s),Mi(2.2))),s.assign(hg.mul(s)),s.assign(za(s,0,1)),s})),fg={[j]:ag,[q]:ug,[X]:lg,[Y]:dg,[K]:mg};class Tg extends Er{constructor(e=W,t=_i(1),s=null){super("vec3"),this.toneMapping=e,this.exposureNode=t,this.colorNode=s}getCacheKey(){let e=super.getCacheKey();return e="{toneMapping:"+this.toneMapping+",nodes:"+e+"}",e}setup(e){const t=this.colorNode||e.context.color,s=this.toneMapping;if(s===W)return t;const r={exposure:this.exposureNode,color:t},i=fg[s];let n=null;return n=i?i(r):t,n}}const xg=(e,t,s)=>ci(new Tg(e,ci(t),ci(s)));Rr("ToneMappingNode",Tg);let yg=null;class bg extends Hc{constructor(e=Vc,t=null){null===yg&&(yg=new S),super(e,t,yg)}}const Ng=pi(bg);Vr("viewportSharedTexture",Ng),Rr("ViewportSharedTextureNode",bg);class _g extends au{constructor(e,t){super(t),this.passNode=e,this.setUpdateMatrix(!1)}setup(e){return this.passNode.build(e),super.setup(e)}clone(){return new this.constructor(this.passNode,this.value)}}class vg extends Er{constructor(e,t,s){super("vec4"),this.scope=e,this.scene=t,this.camera=s,this._pixelRatio=1,this._width=1,this._height=1;const r=new N;r.isRenderTargetTexture=!0,r.name="PostProcessingDepth";const i=new P(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:k});i.texture.name="PostProcessing",i.depthTexture=r,this.renderTarget=i,this.updateBeforeType=cr.FRAME,this._textureNode=ci(new _g(this,i.texture)),this._depthTextureNode=ci(new _g(this,r)),this._depthNode=null,this._cameraNear=po(0),this._cameraFar=po(0),this.isPassNode=!0}isGlobal(){return!0}getTextureNode(){return this._textureNode}getTextureDepthNode(){return this._depthTextureNode}getDepthNode(){if(null===this._depthNode){const e=this._cameraNear,t=this._cameraFar;this._depthNode=Qc(ed(this._depthTextureNode,e,t),e,t)}return this._depthNode}setup(){return this.scope===vg.COLOR?this.getTextureNode():this.getDepthNode()}updateBefore(e){const{renderer:t}=e,{scene:s,camera:r}=this;this._pixelRatio=t.getPixelRatio();const i=t.getSize(new a);this.setSize(i.width,i.height);const n=t.toneMapping,o=t.toneMappingNode,u=t.getRenderTarget();this._cameraNear.value=r.near,this._cameraFar.value=r.far,t.toneMapping=W,t.toneMappingNode=null,t.setRenderTarget(this.renderTarget),t.render(s,r),t.toneMapping=n,t.toneMappingNode=o,t.setRenderTarget(u)}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget.setSize(s,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}vg.COLOR="color",vg.DEPTH="depth";const Sg=(e,t)=>ci(new vg(vg.COLOR,e,t)),Ag=(e,t)=>ci(new _g(e,t)),Rg=(e,t)=>ci(new vg(vg.DEPTH,e,t));Rr("PassNode",vg);const Cg=new Q(-1,1,1,-1,0,1);const Eg=new class extends Z{constructor(e=!1){super();const t=!1===e?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new J([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new J(t,2))}};class wg{constructor(e=null){this._mesh=new O(Eg,e)}dispose(){this._mesh.geometry.dispose()}async renderAsync(e){await e.renderAsync(this._mesh,Cg)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}get render(){return this.renderAsync}}const Mg=new wg,Fg=new wg;class Bg extends Er{constructor(e,t=2){super("vec4"),this.textureNode=e,this.sigma=t,this.directionNode=Ri(1),this._invSize=po(new a),this._passDirection=po(new a),this._horizontalRT=new P,this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new P,this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=Ag(this,this._verticalRT.texture),this.updateBeforeType=cr.RENDER,this.resolution=new a(1,1)}setSize(e,t){e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,r=s.value,i=t.getRenderTarget(),n=s.value;Mg.material=this._material,Fg.material=this._material,this.setSize(r.image.width,r.image.height);const o=r.type;this._horizontalRT.texture.type=o,this._verticalRT.texture.type=o,t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),Mg.render(t),s.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),Fg.render(t),t.setRenderTarget(i),s.value=n}getTextureNode(){return this._textureNode}setup(e){const t=this.textureNode;if(!0!==t.isTextureNode)return Ui();const s=t.uvNode||mo(),r=e=>t.cache().context({getUV:()=>e,forceUVContext:!0}),i=fi((()=>{const e=3+2*this.sigma,t=this._getCoefficients(e),i=this._invSize,n=Ri(this.directionNode).mul(this._passDirection),o=_i(t[0]).toVar(),a=Ui(r(s).mul(o)).toVar();for(let u=1;u<e;u++){const e=_i(u),l=_i(t[u]),c=Ri(n.mul(i.mul(e))).toVar(),d=Ui(r(s.add(c))),h=Ui(r(s.sub(c)));a.addAssign(d.add(h).mul(l)),o.addAssign(No(2,l))}return a.div(o)}));(this._material||(this._material=e.createNodeMaterial())).fragmentNode=i();return e.getNodeProperties(this).textureNode=t,this._textureNode}_getCoefficients(e){const t=[];for(let s=0;s<e;s++)t.push(.39894*Math.exp(-.5*s*s/(e*e))/e);return t}}const Og=(e,t)=>ci(new Bg(ci(e),t));Vr("gaussianBlur",Og);const Ug=new wg;class Lg extends Er{constructor(e,t=.96){super(e),this.textureNode=e,this.textureNodeOld=uu(),this.damp=po(t),this._compRT=new P,this._compRT.texture.name="AfterImageNode.comp",this._oldRT=new P,this._oldRT.texture.name="AfterImageNode.old",this._textureNode=Ag(this,this._compRT.texture),this.updateBeforeType=cr.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._compRT.setSize(e,t),this._oldRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,r=s.value,i=r.type;this._compRT.texture.type=i,this._oldRT.texture.type=i;const n=t.getRenderTarget(),o=s.value;this.textureNodeOld.value=this._oldRT.texture,t.setRenderTarget(this._compRT),Ug.render(t);const a=this._oldRT;this._oldRT=this._compRT,this._compRT=a,this.setSize(r.image.width,r.image.height),t.setRenderTarget(n),s.value=o}setup(e){const t=this.textureNode,s=this.textureNodeOld;if(!0!==t.isTextureNode)return Ui();const r=t.uvNode||mo();s.uvNode=r;const i=fi((([e,t])=>{const s=_i(t).toVar(),r=Ui(e).toVar();return Ra(pa(r.sub(s)),0)})),n=fi((()=>{const e=Ui(s),n=Ui((e=>t.cache().context({getUV:()=>e,forceUVContext:!0}))(r));return e.mulAssign(this.damp.mul(i(e,.1))),Ra(n,e)})),o=this._materialComposed||(this._materialComposed=e.createNodeMaterial());o.fragmentNode=n(),Ug.material=o;return e.getNodeProperties(this).textureNode=t,this._textureNode}}const Ig=(e,t)=>ci(new Lg(ci(e),t));Vr("afterImage",Ig);const Pg=new wg;class Dg extends Er{constructor(e,t,s,r){super("vec4"),this.textureNode=e,this.tresholdNode=t,this.scaleNode=s,this.colorNode=Mi(.1,0,1),this.samples=r,this.resolution=new a(1,1),this._renderTarget=new P,this._renderTarget.texture.name="anamorphic",this._invSize=po(new a),this._textureNode=Ag(this,this._renderTarget.texture),this.updateBeforeType=cr.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._invSize.value.set(1/e,1/t),e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._renderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,r=s.value;this._renderTarget.texture.type=r.type;const i=t.getRenderTarget(),n=s.value;Pg.material=this._material,this.setSize(r.image.width,r.image.height),t.setRenderTarget(this._renderTarget),Pg.render(t),t.setRenderTarget(i),s.value=n}setup(e){const t=this.textureNode;if(!0!==t.isTextureNode)return Ui();const s=t.uvNode||mo(),r=fi((()=>{const e=this.samples,r=Math.floor(e/2),i=Mi(0).toVar();return sc({start:-r,end:r},(({i:e})=>{const n=_i(e).abs().div(r).oneMinus(),o=(e=>t.cache().context({getUV:()=>e,forceUVContext:!0}))(Ri(s.x.add(this._invSize.x.mul(e).mul(this.scaleNode)),s.y)),a=tg(o,this.tresholdNode).mul(n);i.addAssign(a)})),i.mul(this.colorNode)}));(this._material||(this._material=e.createNodeMaterial())).fragmentNode=r();return e.getNodeProperties(this).textureNode=t,this._textureNode}}const Vg=(e,t=.9,s=3,r=32)=>ci(new Dg(ci(e),ci(t),ci(s),r));Vr("anamorphic",Vg);class Gg extends Er{constructor(e=null,t={}){super(),this.functionNode=e,this.parameters=t}setParameters(e){return this.parameters=e,this}getParameters(){return this.parameters}getNodeType(e){return this.functionNode.getNodeType(e)}generate(e){const t=[],s=this.functionNode,r=s.getInputs(e),i=this.parameters;if(Array.isArray(i))for(let s=0;s<i.length;s++){const n=r[s],o=i[s];t.push(o.build(e,n.type))}else for(const s of r){const r=i[s.name];if(void 0===r)throw new Error(`FunctionCallNode: Input '${s.name}' not found in FunctionNode.`);t.push(r.build(e,s.type))}return`${s.build(e,"property")}( ${t.join(", ")} )`}}const kg=(e,...t)=>(t=t.length>1||t[0]&&!0===t[0].isNode?hi(t):di(t[0]),ci(new Gg(ci(e),t)));Vr("call",kg),Rr("FunctionCallNode",Gg);class zg extends Ar{constructor(e=null){super(),this._value=e,this._cache=null,this.inputType=null,this.outpuType=null,this.events=new c,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return null!==this.outputType}set value(e){this._value!==e&&(this._cache&&"URL"===this.inputType&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=e,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const e=this.value;if(e&&null===this._cache&&"URL"===this.inputType&&e.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([e.value]));else if(e&&null!==e.value&&void 0!==e.value&&(("URL"===this.inputType||"String"===this.inputType)&&"string"==typeof e.value||"Number"===this.inputType&&"number"==typeof e.value||"Vector2"===this.inputType&&e.value.isVector2||"Vector3"===this.inputType&&e.value.isVector3||"Vector4"===this.inputType&&e.value.isVector4||"Color"===this.inputType&&e.value.isColor||"Matrix3"===this.inputType&&e.value.isMatrix3||"Matrix4"===this.inputType&&e.value.isMatrix4))return e.value;return this._cache||e}getNodeType(e){return this.value&&this.value.isNode?this.value.getNodeType(e):"float"}setup(){return this.value&&this.value.isNode?this.value:_i()}serialize(e){super.serialize(e),null!==this.value?"ArrayBuffer"===this.inputType?e.value=br(this.value):e.value=this.value?this.value.toJSON(e.meta).uuid:null:e.value=null,e.inputType=this.inputType,e.outputType=this.outputType}deserialize(e){super.deserialize(e);let t=null;null!==e.value&&(t="ArrayBuffer"===e.inputType?Nr(e.value):"Texture"===e.inputType?e.meta.textures[e.value]:e.meta.nodes[e.value]||null),this.value=t,this.inputType=e.inputType,this.outputType=e.outputType}}const $g=pi(zg);Vr("scriptableValue",$g),Rr("ScriptableValueNode",zg);class Hg extends Map{get(e,t=null,...s){if(this.has(e))return super.get(e);if(null!==t){const r=t(...s);return this.set(e,r),r}}}class Wg{constructor(e){this.scriptableNode=e}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(e){return this.scriptableNode.getInputLayout(e)}get(e){const t=this.parameters[e];return t?t.getValue():null}}const jg=new Hg;class qg extends Ar{constructor(e=null,t={}){super(),this.codeNode=e,this.parameters=t,this._local=new Hg,this._output=$g(),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(e,t){return this._local.set(e,t)}getLocal(e){return this._local.get(e)}onRefresh(){this._refresh()}getInputLayout(e){for(const t of this.getLayout())if(t.inputType&&(t.id===e||t.name===e))return t}getOutputLayout(e){for(const t of this.getLayout())if(t.outputType&&(t.id===e||t.name===e))return t}setOutput(e,t){const s=this._outputs;return void 0===s[e]?s[e]=$g(t):s[e].value=t,this}getOutput(e){return this._outputs[e]}getParameter(e){return this.parameters[e]}setParameter(e,t){const s=this.parameters;return t&&t.isScriptableNode?(this.deleteParameter(e),s[e]=t,s[e].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):t&&t.isScriptableValueNode?(this.deleteParameter(e),s[e]=t,s[e].events.addEventListener("refresh",this.onRefresh)):void 0===s[e]?(s[e]=$g(t),s[e].events.addEventListener("refresh",this.onRefresh)):s[e].value=t,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(e){let t=this.parameters[e];return t&&(t.isScriptableNode&&(t=t.getDefaultOutput()),t.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const e of Object.keys(this.parameters))this.deleteParameter(e);return this.needsUpdate=!0,this}call(e,...t){const s=this.getObject()[e];if("function"==typeof s)return s(...t)}async callAsync(e,...t){const s=this.getObject()[e];if("function"==typeof s)return"AsyncFunction"===s.constructor.name?await s(...t):s(...t)}getNodeType(e){return this.getDefaultOutputNode().getNodeType(e)}refresh(e=null){null!==e?this.getOutput(e).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),null!==this._object)return this._object;const e=new Wg(this),t=jg.get("THREE"),s=jg.get("TSL"),r=this.getMethod(this.codeNode),i=[e,this._local,jg,()=>this.refresh(),(e,t)=>this.setOutput(e,t),t,s];this._object=r(...i);const n=this._object.layout;if(n&&(!1===n.cache&&this._local.clear(),this._output.outputType=n.outputType||null,Array.isArray(n.elements)))for(const e of n.elements){const t=e.id||e.name;e.inputType&&(void 0===this.getParameter(t)&&this.setParameter(t,null),this.getParameter(t).inputType=e.inputType),e.outputType&&(void 0===this.getOutput(t)&&this.setOutput(t,null),this.getOutput(t).outputType=e.outputType)}return this._object}deserialize(e){super.deserialize(e);for(const e in this.parameters){let t=this.parameters[e];t.isScriptableNode&&(t=t.getDefaultOutput()),t.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const e=this.getDefaultOutput().value;return e&&e.isNode?e:_i()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),null!==this._method)return this._method;const e=["layout","init","main","dispose"].join(", "),t="\nreturn { ...output, "+e+" };",s="var "+e+"; var output = {};\n"+this.codeNode.code+t;return this._method=new Function(...["parameters","local","global","refresh","setOutput","THREE","TSL"],s),this._method}dispose(){null!==this._method&&(this._object&&"function"==typeof this._object.dispose&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}setup(){return this.getDefaultOutputNode()}set needsUpdate(e){!0===e&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return null===this.codeNode||(!0===this._needsOutputUpdate&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value),this}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}const Xg=pi(qg);Vr("scriptable",Xg),Rr("ScriptableNode",qg);class Yg extends Ar{constructor(e,t){super("float"),this.isFogNode=!0,this.colorNode=e,this.factorNode=t}mixAssign(e){return ka(e,this.colorNode,this)}setup(){return this.factorNode}}const Kg=pi(Yg);Vr("fog",Kg),Rr("FogNode",Yg);class Qg extends Yg{constructor(e,t,s){super(e),this.isFogRangeNode=!0,this.nearNode=t,this.farNode=s}setup(){return Wa(this.nearNode,this.farNode,Ll.z.negate())}}const Zg=pi(Qg);Vr("rangeFog",Zg),Rr("FogRangeNode",Qg);class Jg extends Yg{constructor(e,t){super(e),this.isFogExp2Node=!0,this.densityNode=t}setup(){const e=Ll.z.negate(),t=this.densityNode;return t.mul(t,e,e).negate().exp().oneMinus()}}const em=pi(Jg);Vr("densityFog",em),Rr("FogExp2Node",Jg);let tm=null,sm=null;class rm extends Ar{constructor(e=_i(),t=_i()){super(),this.minNode=e,this.maxNode=t}getVectorLength(e){const t=e.getTypeLength(xr(this.minNode.value)),s=e.getTypeLength(xr(this.maxNode.value));return t>s?t:s}getNodeType(e){return!0===e.object.isInstancedMesh?e.getTypeFromLength(this.getVectorLength(e)):"float"}setup(e){const t=e.object;let r=null;if(!0===t.isInstancedMesh){const i=this.minNode.value,n=this.maxNode.value,o=e.getTypeLength(xr(i)),a=e.getTypeLength(xr(n));tm=tm||new s,sm=sm||new s,tm.setScalar(0),sm.setScalar(0),1===o?tm.setScalar(i):i.isColor?tm.set(i.r,i.g,i.b):tm.set(i.x,i.y,i.z||0,i.w||0),1===a?sm.setScalar(n):n.isColor?sm.set(n.r,n.g,n.b):sm.set(n.x,n.y,n.z||0,n.w||0);const u=4,l=u*t.count,c=new Float32Array(l);for(let e=0;e<l;e++){const t=e%u,s=tm.getComponent(t),r=sm.getComponent(t);c[e]=d.lerp(s,r,Math.random())}const h=this.getNodeType(e);r=hu(c,"vec4",t.count).element(yn).convert(h)}else r=_i(0);return r}}const im=pi(rm);Rr("RangeNode",rm);class nm extends Ar{constructor(e,t,s=[64]){super("void"),this.isComputeNode=!0,this.computeNode=e,this.count=t,this.workgroupSize=s,this.dispatchCount=0,this.version=1,this.updateBeforeType=cr.OBJECT,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}updateDispatchCount(){const{count:e,workgroupSize:t}=this;let s=t[0];for(let e=1;e<t.length;e++)s*=t[e];this.dispatchCount=Math.ceil(e/s)}onInit(){}updateBefore({renderer:e}){e.compute(this)}generate(e){const{shaderStage:t}=e;if("compute"===t){const t=this.computeNode.build(e,"void");""!==t&&e.addLineFlowCode(t)}}}const om=(e,t,s)=>ci(new nm(ci(e),t,s));Vr("compute",om),Rr("ComputeNode",nm);class am extends Ar{constructor(e=am.TARGET_DIRECTION,t=null){super(),this.scope=e,this.light=t}setup(){const{scope:e,light:t}=this;let s=null;return e===am.TARGET_DIRECTION&&(s=Iu.transformDirection(Cu(t).sub(Cu(t.target)))),s}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}am.TARGET_DIRECTION="targetDirection";const um=pi(am,am.TARGET_DIRECTION);Rr("LightNode",am);const lm=fi((e=>{const{lightDistance:t,cutoffDistance:s,decayExponent:r}=e,i=t.pow(r).max(.01).reciprocal();return s.greaterThan(0).cond(i.mul(t.div(s).pow4().oneMinus().clamp().pow2()),i)}));class cm extends fc{constructor(e=null){super(e),this.cutoffDistanceNode=po(0),this.decayExponentNode=po(0)}update(e){const{light:t}=this;super.update(e),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}setup(e){const{colorNode:t,cutoffDistanceNode:s,decayExponentNode:r,light:i}=this,n=e.context.lightingModel,o=wu(i).sub(Ll),a=o.normalize(),u=o.length(),l=lm({lightDistance:u,cutoffDistance:s,decayExponent:r}),c=t.mul(l),d=e.context.reflectedLight;n.direct({lightDirection:a,lightColor:c,reflectedLight:d},e.stack,e)}}Rr("PointLightNode",cm),Nc(ee,cm);class dm extends fc{constructor(e=null){super(e)}setup(e){super.setup(e);const t=e.context.lightingModel,s=this.colorNode,r=um(this.light),i=e.context.reflectedLight;t.direct({lightDirection:r,lightColor:s,reflectedLight:i},e.stack,e)}}Rr("DirectionalLightNode",dm),Nc(te,dm);class hm extends fc{constructor(e=null){super(e),this.coneCosNode=po(0),this.penumbraCosNode=po(0),this.cutoffDistanceNode=po(0),this.decayExponentNode=po(0)}update(e){super.update(e);const{light:t}=this;this.coneCosNode.value=Math.cos(t.angle),this.penumbraCosNode.value=Math.cos(t.angle*(1-t.penumbra)),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}getSpotAttenuation(e){const{coneCosNode:t,penumbraCosNode:s}=this;return Wa(t,s,e)}setup(e){super.setup(e);const t=e.context.lightingModel,{colorNode:s,cutoffDistanceNode:r,decayExponentNode:i,light:n}=this,o=wu(n).sub(Ll),a=o.normalize(),u=a.dot(um(n)),l=this.getSpotAttenuation(u),c=o.length(),d=lm({lightDistance:c,cutoffDistance:r,decayExponent:i}),h=s.mul(l).mul(d),p=e.context.reflectedLight;t.direct({lightDirection:a,lightColor:h,reflectedLight:p},e.stack,e)}}Rr("SpotLightNode",hm),Nc(se,hm);class pm extends hm{getSpotAttenuation(e){const t=this.light.iesMap;let s=null;if(t&&!0===t.isTexture){const r=e.acos().mul(1/Math.PI);s=uu(t,Ri(r,0),0).r}else s=super.getSpotAttenuation(e);return s}}Rr("IESSpotLightNode",pm),Nc(class extends se{constructor(e,t,s,r,i,n){super(e,t,s,r,i,n),this.iesMap=null}copy(e,t){return super.copy(e,t),this.iesMap=e.iesMap,this}},pm);class gm extends fc{constructor(e=null){super(e)}setup({context:e}){e.irradiance.addAssign(this.colorNode)}}Rr("AmbientLightNode",gm),Nc(re,gm);class mm extends fc{constructor(e=null){super(e),this.lightPositionNode=Cu(e),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=po(new o)}update(e){const{light:t}=this;super.update(e),this.lightPositionNode.object3d=t,this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity)}setup(e){const{colorNode:t,groundColorNode:s,lightDirectionNode:r}=this,i=Qu.dot(r).mul(.5).add(.5),n=ka(s,t,i);e.context.irradiance.addAssign(n)}}Rr("HemisphereLightNode",mm),Nc(ie,mm);const fm=fi((e=>{const t=e.uv.mul(2),s=t.x.floor(),r=t.y.floor();return s.add(r).mod(2).sign()}));class Tm extends Er{constructor(e=mo()){super("float"),this.uvNode=e}setup(){return fm({uv:this.uvNode})}}const xm=pi(Tm);Vr("checker",xm),Rr("CheckerNode",Tm);class ym extends ne{constructor(e){super(e),this.textures={}}load(e,t,s,r){const i=new oe(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,(s=>{try{t(this.parse(JSON.parse(s)))}catch(t){r&&r(t),this.manager.itemError(e)}}),s,r)}parseNodes(e){const t={};if(void 0!==e){for(const s of e){const{uuid:e,type:r}=s;t[e]=ci(Cr(r)),t[e].uuid=e}const s={nodes:t,textures:this.textures};for(const r of e){r.meta=s;t[r.uuid].deserialize(r),delete r.meta}}return t}parse(e){const t=ci(Cr(e.type));t.uuid=e.uuid;const s={nodes:this.parseNodes(e.nodes),textures:this.textures};return e.meta=s,t.deserialize(e),delete e.meta,t}setTextures(e){return this.textures=e,this}}const bm=new ae;class Nm extends cd{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.pointWidth=1,this.pointColorNode=null,this.setDefaultValues(bm),this.setupShaders(),this.setValues(e)}setupShaders(){const e=this.alphaToCoverage,t=this.useColor;this.vertexNode=fi((()=>{nn(Ri(),"vUv").assign(mo());const e=an("instancePosition"),t=Mn("vec4","mvPos");t.assign(zu.mul(Ui(e,1)));const s=Dc.z.div(Dc.w),r=Fu.mul(t),i=Mn("vec2","offset");return i.assign(Fl.xy),i.assign(i.mul(wl)),i.assign(i.div(Dc.z)),i.y.assign(i.y.mul(s)),i.assign(i.mul(r.w)),r.assign(r.add(Ui(i,0,0))),r}))(),this.fragmentNode=fi((()=>{const s=nn(Ri(),"vUv"),r=Mn("float","alpha");r.assign(1);const i=s.x,n=s.y,o=i.mul(i).add(n.mul(n));if(e){const e=Mn("float","dlen");e.assign(o.fwidth()),r.assign(Wa(e.oneMinus(),e.add(1),o).oneMinus())}else o.greaterThan(1).discard();let a;if(this.pointColorNode)a=this.pointColorNode;else if(t){a=an("instanceColor").mul(nl)}else a=nl;return Ui(a,r)}))(),this.needsUpdate=!0}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.setupShaders())}}dd("InstancedPointsNodeMaterial",Nm);const _m=new ue;class vm extends cd{constructor(e){super(),this.isLineBasicNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(_m),this.setValues(e)}}dd("LineBasicNodeMaterial",vm);const Sm=new le;class Am extends cd{constructor(e){super(),this.isLineDashedNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(Sm),this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setupVariants(){const e=this.offsetNode,t=this.dashScaleNode?_i(this.dashScaleNode):Sl,s=this.dashSizeNode?_i(this.dashSizeNode):Al,r=this.dashSizeNode?_i(this.dashGapNode):Rl;Wn.assign(s),jn.assign(r);const i=nn(an("lineDistance").mul(t));(e?i.add(e):i).mod(Wn.add(jn)).greaterThan(Wn).discard()}}dd("LineDashedNodeMaterial",Am);const Rm=new le;class Cm extends cd{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.setDefaultValues(Rm),this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.useDash=e.dashed,this.useWorldUnits=!1,this.dashOffset=0,this.lineWidth=1,this.lineColorNode=null,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setupShaders(),this.setValues(e)}setupShaders(){const e=this.alphaToCoverage,t=this.useColor,s=this.dashed,r=this.worldUnits,i=fi((({start:e,end:t})=>{const s=Fu.element(2).element(2),r=Fu.element(3).element(2).mul(-.5).div(s).sub(e.z).div(t.z.sub(e.z));return Ui(ka(e.xyz,t.xyz,r),t.w)}));this.vertexNode=fi((()=>{Fn("vec2","vUv").assign(mo());const e=an("instanceStart"),t=an("instanceEnd"),n=Mn("vec4","start"),o=Mn("vec4","end");n.assign(zu.mul(Ui(e,1))),o.assign(zu.mul(Ui(t,1))),r&&(Fn("vec3","worldStart").assign(n.xyz),Fn("vec3","worldEnd").assign(o.xyz));const a=Dc.z.div(Dc.w),u=Fu.element(2).element(3).equal(-1);yi(u,(()=>{yi(n.z.lessThan(0).and(o.z.greaterThan(0)),(()=>{o.assign(i({start:n,end:o}))})).elseif(o.z.lessThan(0).and(n.z.greaterThanEqual(0)),(()=>{n.assign(i({start:o,end:n}))}))}));const l=Fu.mul(n),c=Fu.mul(o),d=l.xyz.div(l.w),h=c.xyz.div(c.w),p=h.xy.sub(d.xy).temp();p.x.assign(p.x.mul(a)),p.assign(p.normalize());const g=_n(Ui());if(r){const e=o.xyz.sub(n.xyz).normalize(),t=ka(n.xyz,o.xyz,.5).normalize(),r=e.cross(t).normalize(),i=e.cross(r),a=Fn("vec4","worldPos");a.assign(Fl.y.lessThan(.5).cond(n,o));const u=Cl.mul(.5);a.addAssign(Ui(Fl.x.lessThan(0).cond(r.mul(u),r.mul(u).negate()),0)),s||(a.addAssign(Ui(Fl.y.lessThan(.5).cond(e.mul(u).negate(),e.mul(u)),0)),a.addAssign(Ui(i.mul(u),0)),yi(Fl.y.greaterThan(1).or(Fl.y.lessThan(0)),(()=>{a.subAssign(Ui(i.mul(2).mul(u),0))}))),g.assign(Fu.mul(a));const l=_n(Mi());l.assign(Fl.y.lessThan(.5).cond(d,h)),g.z.assign(l.z.mul(g.w))}else{const e=Mn("vec2","offset");e.assign(Ri(p.y,p.x.negate())),p.x.assign(p.x.div(a)),e.x.assign(e.x.div(a)),e.assign(Fl.x.lessThan(0).cond(e.negate(),e)),yi(Fl.y.lessThan(0),(()=>{e.assign(e.sub(p))})).elseif(Fl.y.greaterThan(1),(()=>{e.assign(e.add(p))})),e.assign(e.mul(Cl)),e.assign(e.div(Dc.w)),g.assign(Fl.y.lessThan(.5).cond(l,c)),e.assign(e.mul(g.w)),g.assign(g.add(Ui(e,0,0)))}return g}))();const n=fi((({p1:e,p2:t,p3:s,p4:r})=>{const i=e.sub(s),n=r.sub(s),o=t.sub(e),a=i.dot(n),u=n.dot(o),l=i.dot(o),c=n.dot(n),d=o.dot(o).mul(c).sub(u.mul(u)),h=a.mul(u).sub(l.mul(c)).div(d).clamp(),p=a.add(u.mul(h)).div(c).clamp();return Ri(h,p)}));this.fragmentNode=fi((()=>{const i=Fn("vec2","vUv");if(s){const e=this.offsetNode?_i(this.offsetNodeNode):El,t=this.dashScaleNode?_i(this.dashScaleNode):Sl,s=this.dashSizeNode?_i(this.dashSizeNode):Al,r=this.dashSizeNode?_i(this.dashGapNode):Rl;Wn.assign(s),jn.assign(r);const n=an("instanceDistanceStart"),o=an("instanceDistanceEnd"),a=Fl.y.lessThan(.5).cond(t.mul(n),Sl.mul(o)),u=nn(a.add(El)),l=e?u.add(e):u;i.y.lessThan(-1).or(i.y.greaterThan(1)).discard(),l.mod(Wn.add(jn)).greaterThan(Wn).discard()}const o=Mn("float","alpha");if(o.assign(1),r){const t=Fn("vec3","worldStart"),r=Fn("vec3","worldEnd"),i=Fn("vec4","worldPos").xyz.normalize().mul(1e5),a=r.sub(t),u=n({p1:t,p2:r,p3:Mi(0,0,0),p4:i}),l=t.add(a.mul(u.x)),c=i.mul(u.y),d=l.sub(c).length().div(Cl);if(!s)if(e){const e=d.fwidth();o.assign(Wa(e.negate().add(.5),e.add(.5),d).oneMinus())}else d.greaterThan(.5).discard()}else if(e){const e=i.x,t=i.y.greaterThan(0).cond(i.y.sub(1),i.y.add(1)),s=e.mul(e).add(t.mul(t)),r=Mn("float","dlen");r.assign(s.fwidth()),yi(i.y.abs().greaterThan(1),(()=>{o.assign(Wa(r.oneMinus(),r.add(1),s).oneMinus())}))}else yi(i.y.abs().greaterThan(1),(()=>{const e=i.x,t=i.y.greaterThan(0).cond(i.y.sub(1),i.y.add(1));e.mul(e).add(t.mul(t)).greaterThan(1).discard()}));let a;if(this.lineColorNode)a=this.lineColorNode;else if(t){const e=an("instanceColorStart"),t=an("instanceColorEnd");a=Fl.y.lessThan(.5).cond(e,t).mul(nl)}else a=nl;return Ui(a,o)}))(),this.needsUpdate=!0}get worldUnits(){return this.useWorldUnits}set worldUnits(e){this.useWorldUnits!==e&&(this.useWorldUnits=e,this.setupShaders())}get dashed(){return this.useDash}set dashed(e){this.useDash!==e&&(this.useDash=e,this.setupShaders())}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.setupShaders())}}dd("Line2NodeMaterial",Cm);const Em=new ce;class wm extends cd{constructor(e){super(),this.isMeshNormalNodeMaterial=!0,this.colorSpaced=!1,this.setDefaultValues(Em),this.setValues(e)}setupDiffuseColor(){const e=this.opacityNode?_i(this.opacityNode):ul;Bn.assign(Ui(xh(Ju),e))}}dd("MeshNormalNodeMaterial",wm);const Mm=new de;class Fm extends cd{constructor(e){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!1,this.setDefaultValues(Mm),this.setValues(e)}}dd("MeshBasicNodeMaterial",Fm);const Bm=fi((({f0:e,f90:t,dotVH:s})=>{const r=s.mul(-5.55473).sub(6.98316).mul(s).exp2();return e.mul(r.oneMinus()).add(t.mul(r))})),Om=fi((e=>e.diffuseColor.mul(1/Math.PI))),Um=fi((({dotNH:e})=>$n.mul(.5/Math.PI).add(1).mul(e.pow($n)))),Lm=fi((({lightDirection:e})=>{const t=e.add(Il).normalize(),s=Ju.dot(t).clamp(),r=Il.dot(t).clamp(),i=Bm({f0:zn,f90:1,dotVH:r}),n=_i(.25),o=Um({dotNH:s});return i.mul(n).mul(o)}));class Im extends bn{constructor(e=!0){super(),this.specular=e}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const r=Ju.dot(e).clamp().mul(t);s.directDiffuse.addAssign(r.mul(Om({diffuseColor:Bn.rgb}))),!0===this.specular&&s.directSpecular.addAssign(r.mul(Lm({lightDirection:e})).mul(cl))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Om({diffuseColor:Bn})))}}const Pm=new he;class Dm extends cd{constructor(e){super(),this.isMeshLambertNodeMaterial=!0,this.lights=!0,this.setDefaultValues(Pm),this.setValues(e)}setupLightingModel(){return new Im(!1)}}dd("MeshLambertNodeMaterial",Dm);const Vm=new pe;class Gm extends cd{constructor(e){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(Vm),this.setValues(e)}setupLightingModel(){return new Im}setupVariants(){const e=(this.shininessNode?_i(this.shininessNode):ol).max(1e-4);$n.assign(e);const t=this.specularNode||ll;zn.assign(t)}copy(e){return this.shininessNode=e.shininessNode,this.specularNode=e.specularNode,super.copy(e)}}dd("MeshPhongNodeMaterial",Gm);const km=fi((()=>{const e=Yu.dFdx().abs().max(Yu.dFdy().abs());return e.x.max(e.y).max(e.z)})),zm=fi((e=>{const{roughness:t}=e,s=km();let r=t.max(.0525);return r=r.add(s),r=r.min(1),r})),$m=fi((e=>{const{alpha:t,dotNL:s,dotNV:r}=e,i=t.pow2(),n=s.mul(i.add(i.oneMinus().mul(r.pow2())).sqrt()),o=r.mul(i.add(i.oneMinus().mul(s.pow2())).sqrt());return _o(.5,n.add(o).max(ko))})).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),Hm=fi((({alpha:e,dotNH:t})=>{const s=e.pow2(),r=t.pow2().mul(s.oneMinus()).oneMinus();return s.div(r.pow2()).mul(1/Math.PI)})).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),Wm=fi((e=>{const{lightDirection:t,f0:s,f90:r,roughness:i,iridescenceFresnel:n}=e,o=e.normalView||Ju,a=i.pow2(),u=t.add(Il).normalize(),l=o.dot(t).clamp(),c=o.dot(Il).clamp(),d=o.dot(u).clamp(),h=Il.dot(u).clamp();let p=Bm({f0:s,f90:r,dotVH:h});n&&(p=Vn.mix(p,n));const g=$m({alpha:a,dotNL:l,dotNV:c}),m=Hm({alpha:a,dotNH:d});return p.mul(g).mul(m)})),jm=fi((({roughness:e,dotNV:t})=>{const s=Ui(-1,-.0275,-.572,.022),r=Ui(1,.0425,1.04,-.04),i=e.mul(s).add(r),n=i.x.mul(i.x).min(t.mul(-9.28).exp2()).mul(i.x).add(i.y);return Ri(-1.04,1.04).mul(n).add(i.zw)})).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),qm=fi((e=>{const{dotNV:t,specularColor:s,specularF90:r,roughness:i}=e,n=jm({dotNV:t,roughness:i});return s.mul(n.x).add(r.mul(n.y))})),Xm=fi((({f:e,f90:t,dotVH:s})=>{const r=s.oneMinus().saturate(),i=r.mul(r),n=r.mul(i,i).clamp(0,.9999);return e.sub(Mi(t).mul(n)).div(n.oneMinus())})).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),Ym=fi((({roughness:e,dotNH:t})=>{const s=e.pow2(),r=_i(1).div(s),i=t.pow2().oneMinus().max(.0078125);return _i(2).add(r).mul(i.pow(r.mul(.5))).div(2*Math.PI)})).setLayout({name:"D_Charlie",type:"float",inputs:[{name:"roughness",type:"float"},{name:"dotNH",type:"float"}]}),Km=fi((({dotNV:e,dotNL:t})=>_i(1).div(_i(4).mul(t.add(e).sub(t.mul(e)))))).setLayout({name:"V_Neubelt",type:"float",inputs:[{name:"dotNV",type:"float"},{name:"dotNL",type:"float"}]}),Qm=fi((({lightDirection:e})=>{const t=e.add(Il).normalize(),s=Ju.dot(e).clamp(),r=Ju.dot(Il).clamp(),i=Ju.dot(t).clamp(),n=Ym({roughness:Dn,dotNH:i}),o=Km({dotNV:r,dotNL:s});return Pn.mul(n).mul(o)})),Zm=zi(3.2404542,-.969266,.0556434,-1.5371385,1.8760108,-.2040259,-.4985314,.041556,1.0572252),Jm=(e,t)=>e.sub(t).div(e.add(t)).pow2(),ef=(e,t)=>{const s=e.mul(2*Math.PI*1e-9),r=Mi(54856e-17,44201e-17,52481e-17),i=Mi(1681e3,1795300,2208400),n=Mi(43278e5,93046e5,66121e5),o=_i(9747e-17*Math.sqrt(2*Math.PI*45282e5)).mul(s.mul(2239900).add(t.x).cos()).mul(s.pow2().mul(-45282e5).exp());let a=r.mul(n.mul(2*Math.PI).sqrt()).mul(i.mul(s).add(t).cos()).mul(s.pow2().negate().mul(n).exp());a=Mi(a.x.add(o),a.y,a.z).div(1.0685e-7);return Zm.mul(a)},tf=fi((({outsideIOR:e,eta2:t,cosTheta1:s,thinFilmThickness:r,baseF0:i})=>{const n=ka(e,t,Wa(0,.03,r)),o=e.div(n).pow2().mul(_i(1).sub(s.pow2())),a=_i(1).sub(o).sqrt(),u=Jm(n,e),l=Bm({f0:u,f90:1,dotVH:s}),c=l.oneMinus(),d=n.lessThan(e).cond(Math.PI,0),h=_i(Math.PI).sub(d),p=(e=>{const t=e.sqrt();return Mi(1).add(t).div(Mi(1).sub(t))})(i.clamp(0,.9999)),g=Jm(p,n.vec3()),m=Bm({f0:g,f90:1,dotVH:a}),f=Mi(p.x.lessThan(n).cond(Math.PI,0),p.y.lessThan(n).cond(Math.PI,0),p.z.lessThan(n).cond(Math.PI,0)),T=n.mul(r,a,2),x=Mi(h).add(f),y=l.mul(m).clamp(1e-5,.9999),b=y.sqrt(),N=c.pow2().mul(m).div(Mi(1).sub(y));let _=l.add(N),v=N.sub(c);for(let e=1;e<=2;++e){v=v.mul(b);const t=ef(_i(e).mul(T),_i(e).mul(x)).mul(2);_=_.add(v.mul(t))}return _.max(Mi(0))})).setLayout({name:"evalIridescence",type:"vec3",inputs:[{name:"outsideIOR",type:"float"},{name:"eta2",type:"float"},{name:"cosTheta1",type:"float"},{name:"thinFilmThickness",type:"float"},{name:"baseF0",type:"vec3"}]}),sf=fi((({normal:e,viewDir:t,roughness:s})=>{const r=e.dot(t).saturate(),i=s.pow2(),n=wd(s.lessThan(.25),_i(-339.2).mul(i).add(_i(161.4).mul(s)).sub(25.9),_i(-8.48).mul(i).add(_i(14.3).mul(s)).sub(9.95)),o=wd(s.lessThan(.25),_i(44).mul(i).sub(_i(23.7).mul(s)).add(3.26),_i(1.97).mul(i).sub(_i(3.27).mul(s)).add(.72));return wd(s.lessThan(.25),0,_i(.1).mul(s).sub(.025)).add(n.mul(r).add(o).exp()).mul(1/Math.PI).saturate()})),rf=Mi(.04),nf=Mi(1);class of extends bn{constructor(e=!1,t=!1,s=!1){super(),this.clearcoat=e,this.sheen=t,this.iridescence=s,this.clearcoatRadiance=null,this.clearcoatSpecularDirect=null,this.clearcoatSpecularIndirect=null,this.sheenSpecularDirect=null,this.sheenSpecularIndirect=null,this.iridescenceFresnel=null,this.iridescenceF0=null}start(){if(!0===this.clearcoat&&(this.clearcoatRadiance=Mi().temp("clearcoatRadiance"),this.clearcoatSpecularDirect=Mi().temp("clearcoatSpecularDirect"),this.clearcoatSpecularIndirect=Mi().temp("clearcoatSpecularIndirect")),!0===this.sheen&&(this.sheenSpecularDirect=Mi().temp("sheenSpecularDirect"),this.sheenSpecularIndirect=Mi().temp("sheenSpecularIndirect")),!0===this.iridescence){const e=Ju.dot(Il).clamp();this.iridescenceFresnel=tf({outsideIOR:_i(1),eta2:Gn,cosTheta1:e,thinFilmThickness:kn,baseF0:zn}),this.iridescenceF0=Xm({f:this.iridescenceFresnel,f90:1,dotVH:e})}}computeMultiscattering(e,t,s=_i(1)){const r=Ju.dot(Il).clamp(),i=jm({roughness:On,dotNV:r}),n=(this.iridescenceF0?Vn.mix(zn,this.iridescenceF0):zn).mul(i.x).add(s.mul(i.y)),o=i.x.add(i.y).oneMinus(),a=zn.add(zn.oneMinus().mul(.047619)),u=n.mul(a).div(o.mul(a).oneMinus());e.addAssign(n),t.addAssign(u.mul(o))}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const r=Ju.dot(e).clamp().mul(t);if(!0===this.sheen&&this.sheenSpecularDirect.addAssign(r.mul(Qm({lightDirection:e}))),!0===this.clearcoat){const s=tl.dot(e).clamp().mul(t);this.clearcoatSpecularDirect.addAssign(s.mul(Wm({lightDirection:e,f0:rf,f90:nf,roughness:In,normalView:tl})))}s.directDiffuse.addAssign(r.mul(Om({diffuseColor:Bn.rgb}))),s.directSpecular.addAssign(r.mul(Wm({lightDirection:e,f0:zn,f90:1,roughness:On,iridescence:this.iridescence,iridescenceFresnel:this.iridescenceFresnel})))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Om({diffuseColor:Bn})))}indirectSpecular({radiance:e,iblIrradiance:t,reflectedLight:s}){if(!0===this.sheen&&this.sheenSpecularIndirect.addAssign(t.mul(Pn,sf({normal:Ju,viewDir:Il,roughness:Dn}))),!0===this.clearcoat){const e=tl.dot(Il).clamp(),t=qm({dotNV:e,specularColor:rf,specularF90:nf,roughness:In});this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(t))}const r=Mi().temp("singleScattering"),i=Mi().temp("multiScattering"),n=t.mul(1/Math.PI);this.computeMultiscattering(r,i);const o=r.add(i),a=Bn.mul(o.r.max(o.g).max(o.b).oneMinus());s.indirectSpecular.addAssign(e.mul(r)),s.indirectSpecular.addAssign(i.mul(n)),s.indirectDiffuse.addAssign(a.mul(n))}ambientOcclusion({ambientOcclusion:e,reflectedLight:t}){const s=Ju.dot(Il).clamp().add(e),r=On.mul(-16).oneMinus().negate().exp2(),i=e.sub(s.pow(r).oneMinus()).clamp();!0===this.clearcoat&&this.clearcoatSpecularIndirect.mulAssign(e),!0===this.sheen&&this.sheenSpecularIndirect.mulAssign(e),t.indirectDiffuse.mulAssign(e),t.indirectSpecular.mulAssign(i)}finish(e){const{outgoingLight:t}=e;if(!0===this.clearcoat){const e=tl.dot(Il).clamp(),s=Bm({dotVH:e,f0:rf,f90:nf}),r=t.mul(Ln.mul(s).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(Ln));t.assign(r)}if(!0===this.sheen){const e=Pn.r.max(Pn.g).max(Pn.b).mul(.157).oneMinus(),s=t.mul(e).add(this.sheenSpecularDirect,this.sheenSpecularIndirect);t.assign(s)}}}const af=new ge;class uf extends cd{constructor(e){super(),this.isMeshStandardNodeMaterial=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(af),this.setValues(e)}setupLightingModel(){return new of}setupVariants(){const e=this.metalnessNode?_i(this.metalnessNode):pl;Un.assign(e);let t=this.roughnessNode?_i(this.roughnessNode):hl;t=zm({roughness:t}),On.assign(t);const s=ka(Mi(.04),Bn.rgb,e);zn.assign(s),Bn.assign(Ui(Bn.rgb.mul(e.oneMinus()),Bn.a))}copy(e){return this.emissiveNode=e.emissiveNode,this.metalnessNode=e.metalnessNode,this.roughnessNode=e.roughnessNode,super.copy(e)}}dd("MeshStandardNodeMaterial",uf);const lf=new me;class cf extends uf{constructor(e){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.setDefaultValues(lf),this.setValues(e)}get useClearcoat(){return this.clearcoat>0||null!==this.clearcoatNode}get useIridescence(){return this.iridescence>0||null!==this.iridescenceNode}get useSheen(){return this.sheen>0||null!==this.sheenNode}setupLightingModel(){return new of(this.useClearcoat,this.useSheen,this.useIridescence)}setupVariants(e){if(super.setupVariants(e),this.useClearcoat){const e=this.clearcoatNode?_i(this.clearcoatNode):ml,t=this.clearcoatRoughnessNode?_i(this.clearcoatRoughnessNode):fl;Ln.assign(e),In.assign(t)}if(this.useSheen){const e=this.sheenNode?Mi(this.sheenNode):yl,t=this.sheenRoughnessNode?_i(this.sheenRoughnessNode):bl;Pn.assign(e),Dn.assign(t)}if(this.useIridescence){const e=this.iridescenceNode?_i(this.iridescenceNode):Nl,t=this.iridescenceIORNode?_i(this.iridescenceIORNode):_l,s=this.iridescenceThicknessNode?_i(this.iridescenceThicknessNode):vl;Vn.assign(e),Gn.assign(t),kn.assign(s)}}setupNormal(e){super.setupNormal(e);const t=this.clearcoatNormalNode?Mi(this.clearcoatNormalNode):Tl;tl.assign(t)}copy(e){return this.clearcoatNode=e.clearcoatNode,this.clearcoatRoughnessNode=e.clearcoatRoughnessNode,this.clearcoatNormalNode=e.clearcoatNormalNode,this.sheenNode=e.sheenNode,this.sheenRoughnessNode=e.sheenRoughnessNode,this.iridescenceNode=e.iridescenceNode,this.iridescenceIORNode=e.iridescenceIORNode,this.iridescenceThicknessNode=e.iridescenceThicknessNode,this.specularIntensityNode=e.specularIntensityNode,this.specularColorNode=e.specularColorNode,this.transmissionNode=e.transmissionNode,this.thicknessNode=e.thicknessNode,this.attenuationDistanceNode=e.attenuationDistanceNode,this.attenuationColorNode=e.attenuationColorNode,super.copy(e)}}dd("MeshPhysicalNodeMaterial",cf);class df extends of{constructor(e,t,s,r){super(e,t,s),this.useSSS=r}direct({lightDirection:e,lightColor:t,reflectedLight:s},r,i){if(!0===this.useSSS){const r=i.material,{thicknessColorNode:n,thicknessDistortionNode:o,thicknessAmbientNode:a,thicknessAttenuationNode:u,thicknessPowerNode:l,thicknessScaleNode:c}=r,d=e.add(Ju.mul(o)).normalize(),h=_i(Il.dot(d.negate()).saturate().pow(l).mul(c)),p=Mi(h.add(a).mul(n));s.directDiffuse.addAssign(p.mul(u.mul(t)))}super.direct({lightDirection:e,lightColor:t,reflectedLight:s},r,i)}}class hf extends cf{constructor(e){super(e),this.thicknessColorNode=null,this.thicknessDistortionNode=_i(.1),this.thicknessAmbientNode=_i(0),this.thicknessAttenuationNode=_i(.1),this.thicknessPowerNode=_i(2),this.thicknessScaleNode=_i(10)}get useSSS(){return null!==this.thicknessColorNode}setupLightingModel(){return new df(this.useClearcoat,this.useSheen,this.useIridescence,this.useSSS)}copy(e){return this.thicknessColorNode=e.thicknessColorNode,this.thicknessDistortionNode=e.thicknessDistortionNode,this.thicknessAmbientNode=e.thicknessAmbientNode,this.thicknessAttenuationNode=e.thicknessAttenuationNode,this.thicknessPowerNode=e.thicknessPowerNode,this.thicknessScaleNode=e.thicknessScaleNode,super.copy(e)}}dd("MeshSSSNodeMaterial",hf);const pf=new ae;class gf extends cd{constructor(e){super(),this.isPointsNodeMaterial=!0,this.lights=!1,this.normals=!1,this.transparent=!0,this.sizeNode=null,this.setDefaultValues(pf),this.setValues(e)}copy(e){return this.sizeNode=e.sizeNode,super.copy(e)}}dd("PointsNodeMaterial",gf);const mf=new fe;class ff extends cd{constructor(e){super(),this.isSpriteNodeMaterial=!0,this.lights=!1,this.normals=!1,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.setDefaultValues(mf),this.setValues(e)}setupPosition({object:e,context:t}){const{positionNode:s,rotationNode:r,scaleNode:i}=this,n=Bl;let o=zu.mul(Mi(s||0)),a=Ri(Hu[0].xyz.length(),Hu[1].xyz.length());null!==i&&(a=a.mul(i));let u=n.xy;e.center&&!0===e.center.isVector2&&(u=u.sub(po(e.center).sub(.5))),u=u.mul(a);const l=_i(r||xl),c=u.rotate(l);o=Ui(o.xy.add(c),o.zw);const d=Fu.mul(o);return t.vertex=n,d}copy(e){return this.positionNode=e.positionNode,this.rotationNode=e.rotationNode,this.scaleNode=e.scaleNode,super.copy(e)}}dd("SpriteNodeMaterial",ff);const Tf=Te.createMaterialFromType;Te.createMaterialFromType=function(e){const t=hd(e);return void 0!==t?t:Tf.call(this,e)};class xf extends Te{constructor(e){super(e),this.nodes={}}parse(e){const t=super.parse(e),s=this.nodes,r=e.inputNodes;for(const e in r){const i=r[e];t[e]=s[i]}return t}setNodes(e){return this.nodes=e,this}}class yf extends xe{constructor(e){super(e),this._nodesJSON=null}parse(e,t){this._nodesJSON=e.nodes;const s=super.parse(e,t);return this._nodesJSON=null,s}parseNodes(e,t){if(void 0!==e){const s=new ym;return s.setTextures(t),s.parseNodes(e)}return{}}parseMaterials(e,t){const s={};if(void 0!==e){const r=this.parseNodes(this._nodesJSON,t),i=new xf;i.setTextures(t),i.setNodes(r);for(let t=0,r=e.length;t<r;t++){const r=e[t];s[r.uuid]=i.parse(r)}}return s}}class bf{parseFunction(){}}class Nf{constructor(e,t,s="",r=""){this.type=e,this.inputs=t,this.name=s,this.presicion=r}getCode(){}}Nf.isNodeFunction=!0;const _f=/^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,vf=/[a-z_0-9]+/gi,Sf="#pragma main";class Af extends Nf{constructor(e){const{type:t,inputs:s,name:r,presicion:i,inputsCode:n,blockCode:o,headerCode:a}=(e=>{const t=(e=e.trim()).indexOf(Sf),s=-1!==t?e.slice(t+12):e,r=s.match(_f);if(null!==r&&5===r.length){const i=r[4],n=[];let o=null;for(;null!==(o=vf.exec(i));)n.push(o);const a=[];let u=0;for(;u<n.length;){const e="const"===n[u][0];!0===e&&u++;let t=n[u][0];"in"===t||"out"===t||"inout"===t?u++:t="";const s=n[u++][0];let r=Number.parseInt(n[u][0]);!1===Number.isNaN(r)?u++:r=null;const i=n[u++][0];a.push(new Vd(s,i,r,t,e))}const l=s.substring(r[0].length),c=void 0!==r[3]?r[3]:"";return{type:r[2],inputs:a,name:c,presicion:void 0!==r[1]?r[1]:"",inputsCode:i,blockCode:l,headerCode:-1!==t?e.slice(0,t):""}}throw new Error("FunctionNode: Function is not a GLSL code.")})(e);super(t,s,r,i),this.inputsCode=n,this.blockCode=o,this.headerCode=a}getCode(e=this.name){let t;const s=this.blockCode;if(""!==s){const{type:r,inputsCode:i,headerCode:n,presicion:o}=this;let a=`${r} ${e} ( ${i.trim()} )`;""!==o&&(a=`${o} ${a}`),t=n+a+s}else t="";return t}}class Rf extends bf{parseFunction(e){return new Af(e)}}const Cf=fi((([e,t,s])=>{const r=_i(s).toVar(),i=_i(t).toVar(),n=Ai(e).toVar();return wd(n,i,r)})),Ef=fi((([e,t])=>{const s=Ai(t).toVar(),r=_i(e).toVar();return wd(s,r.negate(),r)})),wf=fi((([e])=>{const t=_i(e).toVar();return vi(sa(t))})),Mf=fi((([e,t])=>{const s=_i(e).toVar();return t.assign(wf(s)),s.sub(_i(t))})),Ff=fi((([e,t,s,r,i,n])=>{const o=_i(n).toVar(),a=_i(i).toVar(),u=_i(r).toVar(),l=_i(s).toVar(),c=_i(t).toVar(),d=_i(e).toVar(),h=_i(bo(1,a)).toVar();return bo(1,o).mul(d.mul(h).add(c.mul(a))).add(o.mul(l.mul(h).add(u.mul(a))))})),Bf=fi((([e,t,s,r,i,n])=>{const o=_i(n).toVar(),a=_i(i).toVar(),u=Mi(r).toVar(),l=Mi(s).toVar(),c=Mi(t).toVar(),d=Mi(e).toVar(),h=_i(bo(1,a)).toVar();return bo(1,o).mul(d.mul(h).add(c.mul(a))).add(o.mul(l.mul(h).add(u.mul(a))))})),Of=ih([Ff,Bf]),Uf=fi((([e,t,s,r,i,n,o,a,u,l,c])=>{const d=_i(c).toVar(),h=_i(l).toVar(),p=_i(u).toVar(),g=_i(a).toVar(),m=_i(o).toVar(),f=_i(n).toVar(),T=_i(i).toVar(),x=_i(r).toVar(),y=_i(s).toVar(),b=_i(t).toVar(),N=_i(e).toVar(),_=_i(bo(1,p)).toVar(),v=_i(bo(1,h)).toVar();return _i(bo(1,d)).toVar().mul(v.mul(N.mul(_).add(b.mul(p))).add(h.mul(y.mul(_).add(x.mul(p))))).add(d.mul(v.mul(T.mul(_).add(f.mul(p))).add(h.mul(m.mul(_).add(g.mul(p))))))})),Lf=fi((([e,t,s,r,i,n,o,a,u,l,c])=>{const d=_i(c).toVar(),h=_i(l).toVar(),p=_i(u).toVar(),g=Mi(a).toVar(),m=Mi(o).toVar(),f=Mi(n).toVar(),T=Mi(i).toVar(),x=Mi(r).toVar(),y=Mi(s).toVar(),b=Mi(t).toVar(),N=Mi(e).toVar(),_=_i(bo(1,p)).toVar(),v=_i(bo(1,h)).toVar();return _i(bo(1,d)).toVar().mul(v.mul(N.mul(_).add(b.mul(p))).add(h.mul(y.mul(_).add(x.mul(p))))).add(d.mul(v.mul(T.mul(_).add(f.mul(p))).add(h.mul(m.mul(_).add(g.mul(p))))))})),If=ih([Uf,Lf]),Pf=fi((([e,t,s])=>{const r=_i(s).toVar(),i=_i(t).toVar(),n=Si(e).toVar(),o=Si(n.bitAnd(Si(7))).toVar(),a=_i(Cf(o.lessThan(Si(4)),i,r)).toVar(),u=_i(No(2,Cf(o.lessThan(Si(4)),r,i))).toVar();return Ef(a,Ai(o.bitAnd(Si(1)))).add(Ef(u,Ai(o.bitAnd(Si(2)))))})),Df=fi((([e,t,s,r])=>{const i=_i(r).toVar(),n=_i(s).toVar(),o=_i(t).toVar(),a=Si(e).toVar(),u=Si(a.bitAnd(Si(15))).toVar(),l=_i(Cf(u.lessThan(Si(8)),o,n)).toVar(),c=_i(Cf(u.lessThan(Si(4)),n,Cf(u.equal(Si(12)).or(u.equal(Si(14))),o,i))).toVar();return Ef(l,Ai(u.bitAnd(Si(1)))).add(Ef(c,Ai(u.bitAnd(Si(2)))))})),Vf=ih([Pf,Df]),Gf=fi((([e,t,s])=>{const r=_i(s).toVar(),i=_i(t).toVar(),n=Bi(e).toVar();return Mi(Vf(n.x,i,r),Vf(n.y,i,r),Vf(n.z,i,r))})),kf=fi((([e,t,s,r])=>{const i=_i(r).toVar(),n=_i(s).toVar(),o=_i(t).toVar(),a=Bi(e).toVar();return Mi(Vf(a.x,o,n,i),Vf(a.y,o,n,i),Vf(a.z,o,n,i))})),zf=ih([Gf,kf]),$f=fi((([e])=>{const t=_i(e).toVar();return No(.6616,t)})),Hf=fi((([e])=>{const t=_i(e).toVar();return No(.982,t)})),Wf=fi((([e])=>{const t=Mi(e).toVar();return No(.6616,t)})),jf=ih([$f,Wf]),qf=fi((([e])=>{const t=Mi(e).toVar();return No(.982,t)})),Xf=ih([Hf,qf]),Yf=fi((([e,t])=>{const s=vi(t).toVar(),r=Si(e).toVar();return r.shiftLeft(s).bitOr(r.shiftRight(vi(32).sub(s)))})),Kf=fi((([e,t,s])=>{e.subAssign(s),e.bitXorAssign(Yf(s,vi(4))),s.addAssign(t),t.subAssign(e),t.bitXorAssign(Yf(e,vi(6))),e.addAssign(s),s.subAssign(t),s.bitXorAssign(Yf(t,vi(8))),t.addAssign(e),e.subAssign(s),e.bitXorAssign(Yf(s,vi(16))),s.addAssign(t),t.subAssign(e),t.bitXorAssign(Yf(e,vi(19))),e.addAssign(s),s.subAssign(t),s.bitXorAssign(Yf(t,vi(4))),t.addAssign(e)})),Qf=fi((([e,t,s])=>{const r=Si(s).toVar(),i=Si(t).toVar(),n=Si(e).toVar();return r.bitXorAssign(i),r.subAssign(Yf(i,vi(14))),n.bitXorAssign(r),n.subAssign(Yf(r,vi(11))),i.bitXorAssign(n),i.subAssign(Yf(n,vi(25))),r.bitXorAssign(i),r.subAssign(Yf(i,vi(16))),n.bitXorAssign(r),n.subAssign(Yf(r,vi(4))),i.bitXorAssign(n),i.subAssign(Yf(n,vi(14))),r.bitXorAssign(i),r.subAssign(Yf(i,vi(24))),r})),Zf=fi((([e])=>{const t=Si(e).toVar();return _i(t).div(_i(Si(vi(4294967295))))})),Jf=fi((([e])=>{const t=_i(e).toVar();return t.mul(t.mul(t.mul(t.mul(t.mul(6).sub(15)).add(10))))})),eT=fi((([e])=>{const t=vi(e).toVar(),s=Si(Si(1)).toVar(),r=Si(Si(vi(3735928559)).add(s.shiftLeft(Si(2)).add(Si(13)))).toVar();return Qf(r.add(Si(t)),r,r)})),tT=fi((([e,t])=>{const s=vi(t).toVar(),r=vi(e).toVar(),i=Si(Si(2)).toVar(),n=Si().toVar(),o=Si().toVar(),a=Si().toVar();return n.assign(o.assign(a.assign(Si(vi(3735928559)).add(i.shiftLeft(Si(2)).add(Si(13)))))),n.addAssign(Si(r)),o.addAssign(Si(s)),Qf(n,o,a)})),sT=fi((([e,t,s])=>{const r=vi(s).toVar(),i=vi(t).toVar(),n=vi(e).toVar(),o=Si(Si(3)).toVar(),a=Si().toVar(),u=Si().toVar(),l=Si().toVar();return a.assign(u.assign(l.assign(Si(vi(3735928559)).add(o.shiftLeft(Si(2)).add(Si(13)))))),a.addAssign(Si(n)),u.addAssign(Si(i)),l.addAssign(Si(r)),Qf(a,u,l)})),rT=fi((([e,t,s,r])=>{const i=vi(r).toVar(),n=vi(s).toVar(),o=vi(t).toVar(),a=vi(e).toVar(),u=Si(Si(4)).toVar(),l=Si().toVar(),c=Si().toVar(),d=Si().toVar();return l.assign(c.assign(d.assign(Si(vi(3735928559)).add(u.shiftLeft(Si(2)).add(Si(13)))))),l.addAssign(Si(a)),c.addAssign(Si(o)),d.addAssign(Si(n)),Kf(l,c,d),l.addAssign(Si(i)),Qf(l,c,d)})),iT=fi((([e,t,s,r,i])=>{const n=vi(i).toVar(),o=vi(r).toVar(),a=vi(s).toVar(),u=vi(t).toVar(),l=vi(e).toVar(),c=Si(Si(5)).toVar(),d=Si().toVar(),h=Si().toVar(),p=Si().toVar();return d.assign(h.assign(p.assign(Si(vi(3735928559)).add(c.shiftLeft(Si(2)).add(Si(13)))))),d.addAssign(Si(l)),h.addAssign(Si(u)),p.addAssign(Si(a)),Kf(d,h,p),d.addAssign(Si(o)),h.addAssign(Si(n)),Qf(d,h,p)})),nT=ih([eT,tT,sT,rT,iT]),oT=fi((([e,t])=>{const s=vi(t).toVar(),r=vi(e).toVar(),i=Si(nT(r,s)).toVar(),n=Bi().toVar();return n.x.assign(i.bitAnd(vi(255))),n.y.assign(i.shiftRight(vi(8)).bitAnd(vi(255))),n.z.assign(i.shiftRight(vi(16)).bitAnd(vi(255))),n})),aT=fi((([e,t,s])=>{const r=vi(s).toVar(),i=vi(t).toVar(),n=vi(e).toVar(),o=Si(nT(n,i,r)).toVar(),a=Bi().toVar();return a.x.assign(o.bitAnd(vi(255))),a.y.assign(o.shiftRight(vi(8)).bitAnd(vi(255))),a.z.assign(o.shiftRight(vi(16)).bitAnd(vi(255))),a})),uT=ih([oT,aT]),lT=fi((([e])=>{const t=Ri(e).toVar(),s=vi().toVar(),r=vi().toVar(),i=_i(Mf(t.x,s)).toVar(),n=_i(Mf(t.y,r)).toVar(),o=_i(Jf(i)).toVar(),a=_i(Jf(n)).toVar(),u=_i(Of(Vf(nT(s,r),i,n),Vf(nT(s.add(vi(1)),r),i.sub(1),n),Vf(nT(s,r.add(vi(1))),i,n.sub(1)),Vf(nT(s.add(vi(1)),r.add(vi(1))),i.sub(1),n.sub(1)),o,a)).toVar();return jf(u)})),cT=fi((([e])=>{const t=Mi(e).toVar(),s=vi().toVar(),r=vi().toVar(),i=vi().toVar(),n=_i(Mf(t.x,s)).toVar(),o=_i(Mf(t.y,r)).toVar(),a=_i(Mf(t.z,i)).toVar(),u=_i(Jf(n)).toVar(),l=_i(Jf(o)).toVar(),c=_i(Jf(a)).toVar(),d=_i(If(Vf(nT(s,r,i),n,o,a),Vf(nT(s.add(vi(1)),r,i),n.sub(1),o,a),Vf(nT(s,r.add(vi(1)),i),n,o.sub(1),a),Vf(nT(s.add(vi(1)),r.add(vi(1)),i),n.sub(1),o.sub(1),a),Vf(nT(s,r,i.add(vi(1))),n,o,a.sub(1)),Vf(nT(s.add(vi(1)),r,i.add(vi(1))),n.sub(1),o,a.sub(1)),Vf(nT(s,r.add(vi(1)),i.add(vi(1))),n,o.sub(1),a.sub(1)),Vf(nT(s.add(vi(1)),r.add(vi(1)),i.add(vi(1))),n.sub(1),o.sub(1),a.sub(1)),u,l,c)).toVar();return Xf(d)})),dT=ih([lT,cT]),hT=fi((([e])=>{const t=Ri(e).toVar(),s=vi().toVar(),r=vi().toVar(),i=_i(Mf(t.x,s)).toVar(),n=_i(Mf(t.y,r)).toVar(),o=_i(Jf(i)).toVar(),a=_i(Jf(n)).toVar(),u=Mi(Of(zf(uT(s,r),i,n),zf(uT(s.add(vi(1)),r),i.sub(1),n),zf(uT(s,r.add(vi(1))),i,n.sub(1)),zf(uT(s.add(vi(1)),r.add(vi(1))),i.sub(1),n.sub(1)),o,a)).toVar();return jf(u)})),pT=fi((([e])=>{const t=Mi(e).toVar(),s=vi().toVar(),r=vi().toVar(),i=vi().toVar(),n=_i(Mf(t.x,s)).toVar(),o=_i(Mf(t.y,r)).toVar(),a=_i(Mf(t.z,i)).toVar(),u=_i(Jf(n)).toVar(),l=_i(Jf(o)).toVar(),c=_i(Jf(a)).toVar(),d=Mi(If(zf(uT(s,r,i),n,o,a),zf(uT(s.add(vi(1)),r,i),n.sub(1),o,a),zf(uT(s,r.add(vi(1)),i),n,o.sub(1),a),zf(uT(s.add(vi(1)),r.add(vi(1)),i),n.sub(1),o.sub(1),a),zf(uT(s,r,i.add(vi(1))),n,o,a.sub(1)),zf(uT(s.add(vi(1)),r,i.add(vi(1))),n.sub(1),o,a.sub(1)),zf(uT(s,r.add(vi(1)),i.add(vi(1))),n,o.sub(1),a.sub(1)),zf(uT(s.add(vi(1)),r.add(vi(1)),i.add(vi(1))),n.sub(1),o.sub(1),a.sub(1)),u,l,c)).toVar();return Xf(d)})),gT=ih([hT,pT]),mT=fi((([e])=>{const t=_i(e).toVar(),s=vi(wf(t)).toVar();return Zf(nT(s))})),fT=fi((([e])=>{const t=Ri(e).toVar(),s=vi(wf(t.x)).toVar(),r=vi(wf(t.y)).toVar();return Zf(nT(s,r))})),TT=fi((([e])=>{const t=Mi(e).toVar(),s=vi(wf(t.x)).toVar(),r=vi(wf(t.y)).toVar(),i=vi(wf(t.z)).toVar();return Zf(nT(s,r,i))})),xT=fi((([e])=>{const t=Ui(e).toVar(),s=vi(wf(t.x)).toVar(),r=vi(wf(t.y)).toVar(),i=vi(wf(t.z)).toVar(),n=vi(wf(t.w)).toVar();return Zf(nT(s,r,i,n))})),yT=ih([mT,fT,TT,xT]),bT=fi((([e])=>{const t=_i(e).toVar(),s=vi(wf(t)).toVar();return Mi(Zf(nT(s,vi(0))),Zf(nT(s,vi(1))),Zf(nT(s,vi(2))))})),NT=fi((([e])=>{const t=Ri(e).toVar(),s=vi(wf(t.x)).toVar(),r=vi(wf(t.y)).toVar();return Mi(Zf(nT(s,r,vi(0))),Zf(nT(s,r,vi(1))),Zf(nT(s,r,vi(2))))})),_T=fi((([e])=>{const t=Mi(e).toVar(),s=vi(wf(t.x)).toVar(),r=vi(wf(t.y)).toVar(),i=vi(wf(t.z)).toVar();return Mi(Zf(nT(s,r,i,vi(0))),Zf(nT(s,r,i,vi(1))),Zf(nT(s,r,i,vi(2))))})),vT=fi((([e])=>{const t=Ui(e).toVar(),s=vi(wf(t.x)).toVar(),r=vi(wf(t.y)).toVar(),i=vi(wf(t.z)).toVar(),n=vi(wf(t.w)).toVar();return Mi(Zf(nT(s,r,i,n,vi(0))),Zf(nT(s,r,i,n,vi(1))),Zf(nT(s,r,i,n,vi(2))))})),ST=ih([bT,NT,_T,vT]),AT=fi((([e,t,s,r])=>{const i=_i(r).toVar(),n=_i(s).toVar(),o=vi(t).toVar(),a=Mi(e).toVar(),u=_i(0).toVar(),l=_i(1).toVar();return sc({start:vi(0),end:o},(({i:e})=>{u.addAssign(l.mul(dT(a))),l.mulAssign(i),a.mulAssign(n)})),u})),RT=fi((([e,t,s,r])=>{const i=_i(r).toVar(),n=_i(s).toVar(),o=vi(t).toVar(),a=Mi(e).toVar(),u=Mi(0).toVar(),l=_i(1).toVar();return sc({start:vi(0),end:o},(({i:e})=>{u.addAssign(l.mul(gT(a))),l.mulAssign(i),a.mulAssign(n)})),u})),CT=fi((([e,t,s,r])=>{const i=_i(r).toVar(),n=_i(s).toVar(),o=vi(t).toVar(),a=Mi(e).toVar();return Ri(AT(a,o,n,i),AT(a.add(Mi(vi(19),vi(193),vi(17))),o,n,i))})),ET=fi((([e,t,s,r])=>{const i=_i(r).toVar(),n=_i(s).toVar(),o=vi(t).toVar(),a=Mi(e).toVar(),u=Mi(RT(a,o,n,i)).toVar(),l=_i(AT(a.add(Mi(vi(19),vi(193),vi(17))),o,n,i)).toVar();return Ui(u,l)})),wT=fi((([e,t,s,r,i,n,o])=>{const a=vi(o).toVar(),u=_i(n).toVar(),l=vi(i).toVar(),c=vi(r).toVar(),d=vi(s).toVar(),h=vi(t).toVar(),p=Ri(e).toVar(),g=Mi(ST(Ri(h.add(c),d.add(l)))).toVar(),m=Ri(g.x,g.y).toVar();m.subAssign(.5),m.mulAssign(u),m.addAssign(.5);const f=Ri(Ri(_i(h),_i(d)).add(m)).toVar(),T=Ri(f.sub(p)).toVar();return yi(a.equal(vi(2)),(()=>ha(T.x).add(ha(T.y)))),yi(a.equal(vi(3)),(()=>Ra(ha(T.x),ha(T.y)))),Ba(T,T)})),MT=fi((([e,t,s,r,i,n,o,a,u])=>{const l=vi(u).toVar(),c=_i(a).toVar(),d=vi(o).toVar(),h=vi(n).toVar(),p=vi(i).toVar(),g=vi(r).toVar(),m=vi(s).toVar(),f=vi(t).toVar(),T=Mi(e).toVar(),x=Mi(ST(Mi(f.add(p),m.add(h),g.add(d)))).toVar();x.subAssign(.5),x.mulAssign(c),x.addAssign(.5);const y=Mi(Mi(_i(f),_i(m),_i(g)).add(x)).toVar(),b=Mi(y.sub(T)).toVar();return yi(l.equal(vi(2)),(()=>ha(b.x).add(ha(b.y).add(ha(b.z))))),yi(l.equal(vi(3)),(()=>Ra(Ra(ha(b.x),ha(b.y)),ha(b.z)))),Ba(b,b)})),FT=ih([wT,MT]),BT=fi((([e,t,s])=>{const r=vi(s).toVar(),i=_i(t).toVar(),n=Ri(e).toVar(),o=vi().toVar(),a=vi().toVar(),u=Ri(Mf(n.x,o),Mf(n.y,a)).toVar(),l=_i(1e6).toVar();return sc({start:-1,end:vi(1),name:"x",condition:"<="},(({x:e})=>{sc({start:-1,end:vi(1),name:"y",condition:"<="},(({y:t})=>{const s=_i(FT(u,e,t,o,a,i,r)).toVar();l.assign(Aa(l,s))}))})),yi(r.equal(vi(0)),(()=>{l.assign(ea(l))})),l})),OT=fi((([e,t,s])=>{const r=vi(s).toVar(),i=_i(t).toVar(),n=Ri(e).toVar(),o=vi().toVar(),a=vi().toVar(),u=Ri(Mf(n.x,o),Mf(n.y,a)).toVar(),l=Ri(1e6,1e6).toVar();return sc({start:-1,end:vi(1),name:"x",condition:"<="},(({x:e})=>{sc({start:-1,end:vi(1),name:"y",condition:"<="},(({y:t})=>{const s=_i(FT(u,e,t,o,a,i,r)).toVar();yi(s.lessThan(l.x),(()=>{l.y.assign(l.x),l.x.assign(s)})).elseif(s.lessThan(l.y),(()=>{l.y.assign(s)}))}))})),yi(r.equal(vi(0)),(()=>{l.assign(ea(l))})),l})),UT=fi((([e,t,s])=>{const r=vi(s).toVar(),i=_i(t).toVar(),n=Ri(e).toVar(),o=vi().toVar(),a=vi().toVar(),u=Ri(Mf(n.x,o),Mf(n.y,a)).toVar(),l=Mi(1e6,1e6,1e6).toVar();return sc({start:-1,end:vi(1),name:"x",condition:"<="},(({x:e})=>{sc({start:-1,end:vi(1),name:"y",condition:"<="},(({y:t})=>{const s=_i(FT(u,e,t,o,a,i,r)).toVar();yi(s.lessThan(l.x),(()=>{l.z.assign(l.y),l.y.assign(l.x),l.x.assign(s)})).elseif(s.lessThan(l.y),(()=>{l.z.assign(l.y),l.y.assign(s)})).elseif(s.lessThan(l.z),(()=>{l.z.assign(s)}))}))})),yi(r.equal(vi(0)),(()=>{l.assign(ea(l))})),l})),LT=fi((([e,t,s])=>{const r=vi(s).toVar(),i=_i(t).toVar(),n=Mi(e).toVar(),o=vi().toVar(),a=vi().toVar(),u=vi().toVar(),l=Mi(Mf(n.x,o),Mf(n.y,a),Mf(n.z,u)).toVar(),c=_i(1e6).toVar();return sc({start:-1,end:vi(1),name:"x",condition:"<="},(({x:e})=>{sc({start:-1,end:vi(1),name:"y",condition:"<="},(({y:t})=>{sc({start:-1,end:vi(1),name:"z",condition:"<="},(({z:s})=>{const n=_i(FT(l,e,t,s,o,a,u,i,r)).toVar();c.assign(Aa(c,n))}))}))})),yi(r.equal(vi(0)),(()=>{c.assign(ea(c))})),c})),IT=ih([BT,LT]),PT=fi((([e,t,s])=>{const r=vi(s).toVar(),i=_i(t).toVar(),n=Mi(e).toVar(),o=vi().toVar(),a=vi().toVar(),u=vi().toVar(),l=Mi(Mf(n.x,o),Mf(n.y,a),Mf(n.z,u)).toVar(),c=Ri(1e6,1e6).toVar();return sc({start:-1,end:vi(1),name:"x",condition:"<="},(({x:e})=>{sc({start:-1,end:vi(1),name:"y",condition:"<="},(({y:t})=>{sc({start:-1,end:vi(1),name:"z",condition:"<="},(({z:s})=>{const n=_i(FT(l,e,t,s,o,a,u,i,r)).toVar();yi(n.lessThan(c.x),(()=>{c.y.assign(c.x),c.x.assign(n)})).elseif(n.lessThan(c.y),(()=>{c.y.assign(n)}))}))}))})),yi(r.equal(vi(0)),(()=>{c.assign(ea(c))})),c})),DT=ih([OT,PT]),VT=fi((([e,t,s])=>{const r=vi(s).toVar(),i=_i(t).toVar(),n=Mi(e).toVar(),o=vi().toVar(),a=vi().toVar(),u=vi().toVar(),l=Mi(Mf(n.x,o),Mf(n.y,a),Mf(n.z,u)).toVar(),c=Mi(1e6,1e6,1e6).toVar();return sc({start:-1,end:vi(1),name:"x",condition:"<="},(({x:e})=>{sc({start:-1,end:vi(1),name:"y",condition:"<="},(({y:t})=>{sc({start:-1,end:vi(1),name:"z",condition:"<="},(({z:s})=>{const n=_i(FT(l,e,t,s,o,a,u,i,r)).toVar();yi(n.lessThan(c.x),(()=>{c.z.assign(c.y),c.y.assign(c.x),c.x.assign(n)})).elseif(n.lessThan(c.y),(()=>{c.z.assign(c.y),c.y.assign(n)})).elseif(n.lessThan(c.z),(()=>{c.z.assign(n)}))}))}))})),yi(r.equal(vi(0)),(()=>{c.assign(ea(c))})),c})),GT=ih([UT,VT]);Cf.setLayout({name:"mx_select",type:"float",inputs:[{name:"b",type:"bool"},{name:"t",type:"float"},{name:"f",type:"float"}]}),Ef.setLayout({name:"mx_negate_if",type:"float",inputs:[{name:"val",type:"float"},{name:"b",type:"bool"}]}),wf.setLayout({name:"mx_floor",type:"int",inputs:[{name:"x",type:"float"}]}),Ff.setLayout({name:"mx_bilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"}]}),Bf.setLayout({name:"mx_bilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"}]}),Uf.setLayout({name:"mx_trilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"v4",type:"float"},{name:"v5",type:"float"},{name:"v6",type:"float"},{name:"v7",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]}),Lf.setLayout({name:"mx_trilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"v4",type:"vec3"},{name:"v5",type:"vec3"},{name:"v6",type:"vec3"},{name:"v7",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]}),Pf.setLayout({name:"mx_gradient_float_0",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"}]}),Df.setLayout({name:"mx_gradient_float_1",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]}),Gf.setLayout({name:"mx_gradient_vec3_0",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"}]}),kf.setLayout({name:"mx_gradient_vec3_1",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]}),$f.setLayout({name:"mx_gradient_scale2d_0",type:"float",inputs:[{name:"v",type:"float"}]}),Hf.setLayout({name:"mx_gradient_scale3d_0",type:"float",inputs:[{name:"v",type:"float"}]}),Wf.setLayout({name:"mx_gradient_scale2d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]}),qf.setLayout({name:"mx_gradient_scale3d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]}),Yf.setLayout({name:"mx_rotl32",type:"uint",inputs:[{name:"x",type:"uint"},{name:"k",type:"int"}]}),Qf.setLayout({name:"mx_bjfinal",type:"uint",inputs:[{name:"a",type:"uint"},{name:"b",type:"uint"},{name:"c",type:"uint"}]}),Zf.setLayout({name:"mx_bits_to_01",type:"float",inputs:[{name:"bits",type:"uint"}]}),Jf.setLayout({name:"mx_fade",type:"float",inputs:[{name:"t",type:"float"}]}),eT.setLayout({name:"mx_hash_int_0",type:"uint",inputs:[{name:"x",type:"int"}]}),tT.setLayout({name:"mx_hash_int_1",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]}),sT.setLayout({name:"mx_hash_int_2",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]}),rT.setLayout({name:"mx_hash_int_3",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"}]}),iT.setLayout({name:"mx_hash_int_4",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"},{name:"yy",type:"int"}]}),oT.setLayout({name:"mx_hash_vec3_0",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]}),aT.setLayout({name:"mx_hash_vec3_1",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]}),lT.setLayout({name:"mx_perlin_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"}]}),cT.setLayout({name:"mx_perlin_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"}]}),hT.setLayout({name:"mx_perlin_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"}]}),pT.setLayout({name:"mx_perlin_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),mT.setLayout({name:"mx_cell_noise_float_0",type:"float",inputs:[{name:"p",type:"float"}]}),fT.setLayout({name:"mx_cell_noise_float_1",type:"float",inputs:[{name:"p",type:"vec2"}]}),TT.setLayout({name:"mx_cell_noise_float_2",type:"float",inputs:[{name:"p",type:"vec3"}]}),xT.setLayout({name:"mx_cell_noise_float_3",type:"float",inputs:[{name:"p",type:"vec4"}]}),bT.setLayout({name:"mx_cell_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"float"}]}),NT.setLayout({name:"mx_cell_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec2"}]}),_T.setLayout({name:"mx_cell_noise_vec3_2",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),vT.setLayout({name:"mx_cell_noise_vec3_3",type:"vec3",inputs:[{name:"p",type:"vec4"}]}),AT.setLayout({name:"mx_fractal_noise_float",type:"float",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),RT.setLayout({name:"mx_fractal_noise_vec3",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),CT.setLayout({name:"mx_fractal_noise_vec2",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),ET.setLayout({name:"mx_fractal_noise_vec4",type:"vec4",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),wT.setLayout({name:"mx_worley_distance_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),MT.setLayout({name:"mx_worley_distance_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"zoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),BT.setLayout({name:"mx_worley_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),OT.setLayout({name:"mx_worley_noise_vec2_0",type:"vec2",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),UT.setLayout({name:"mx_worley_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),LT.setLayout({name:"mx_worley_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),PT.setLayout({name:"mx_worley_noise_vec2_1",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),VT.setLayout({name:"mx_worley_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});const kT=fi((([e])=>{const t=Mi(e).toVar(),s=_i(t.x).toVar(),r=_i(t.y).toVar(),i=_i(t.z).toVar();yi(r.lessThan(1e-4),(()=>Mi(i,i,i))).else((()=>{s.assign(No(6,s.sub(sa(s))));const e=vi(Na(s)).toVar(),t=_i(s.sub(_i(e))).toVar(),n=_i(i.mul(bo(1,r))).toVar(),o=_i(i.mul(bo(1,r.mul(t)))).toVar(),a=_i(i.mul(bo(1,r.mul(bo(1,t))))).toVar();return yi(e.equal(vi(0)),(()=>Mi(i,a,n))).elseif(e.equal(vi(1)),(()=>Mi(o,i,n))).elseif(e.equal(vi(2)),(()=>Mi(n,i,a))).elseif(e.equal(vi(3)),(()=>Mi(n,o,i))).elseif(e.equal(vi(4)),(()=>Mi(a,n,i))),Mi(i,n,o)}))})),zT=fi((([e])=>{const t=Mi(e).toVar(),s=_i(t.x).toVar(),r=_i(t.y).toVar(),i=_i(t.z).toVar(),n=_i(Aa(s,Aa(r,i))).toVar(),o=_i(Ra(s,Ra(r,i))).toVar(),a=_i(o.sub(n)).toVar(),u=_i().toVar(),l=_i().toVar(),c=_i().toVar();return c.assign(o),yi(o.greaterThan(0),(()=>{l.assign(a.div(o))})).else((()=>{l.assign(0)})),yi(l.lessThanEqual(0),(()=>{u.assign(0)})).else((()=>{yi(s.greaterThanEqual(o),(()=>{u.assign(r.sub(i).div(a))})).elseif(r.greaterThanEqual(o),(()=>{u.assign(yo(2,i.sub(s).div(a)))})).else((()=>{u.assign(yo(4,s.sub(r).div(a)))})),u.mulAssign(1/6),yi(u.lessThan(0),(()=>{u.addAssign(1)}))})),Mi(u,l,c)}));kT.setLayout({name:"mx_hsvtorgb",type:"vec3",inputs:[{name:"hsv",type:"vec3"}]}),zT.setLayout({name:"mx_rgbtohsv",type:"vec3",inputs:[{name:"c",type:"vec3"}]});const $T=fi((([e])=>{const t=Mi(e).toVar(),s=Oi(Co(t,Mi(.04045))).toVar(),r=Mi(t.div(12.92)).toVar(),i=Mi(Ua(Ra(t.add(Mi(.055)),Mi(0)).div(1.055),Mi(2.4))).toVar();return ka(r,i,s)}));$T.setLayout({name:"mx_srgb_texture_to_lin_rec709",type:"vec3",inputs:[{name:"color",type:"vec3"}]});const HT=(e,t)=>{e=_i(e),t=_i(t);const s=Ri(t.dFdx(),t.dFdy()).length().mul(.7071067811865476);return Wa(e.sub(s),e.add(s),t)},WT=(e,t,s,r)=>ka(e,t,s[r].clamp()),jT=(e,t,s=mo())=>WT(e,t,s,"x"),qT=(e,t,s=mo())=>WT(e,t,s,"y"),XT=(e,t,s,r,i)=>ka(e,t,HT(s,r[i])),YT=(e,t,s,r=mo())=>XT(e,t,s,r,"x"),KT=(e,t,s,r=mo())=>XT(e,t,s,r,"y"),QT=(e=1,t=0,s=mo())=>s.mul(e).add(t),ZT=(e,t=1)=>(e=_i(e)).abs().pow(t).mul(e.sign()),JT=(e,t=1,s=.5)=>_i(e).sub(s).mul(t).add(s),ex=(e=mo(),t=1,s=0)=>dT(e.convert("vec2|vec3")).mul(t).add(s),tx=(e=mo(),t=1,s=0)=>gT(e.convert("vec2|vec3")).mul(t).add(s),sx=(e=mo(),t=1,s=0)=>{e=e.convert("vec2|vec3");return Ui(gT(e),dT(e.add(Ri(19,73)))).mul(t).add(s)},rx=(e=mo(),t=1)=>IT(e.convert("vec2|vec3"),t,vi(1)),ix=(e=mo(),t=1)=>DT(e.convert("vec2|vec3"),t,vi(1)),nx=(e=mo(),t=1)=>GT(e.convert("vec2|vec3"),t,vi(1)),ox=(e=mo())=>yT(e.convert("vec2|vec3")),ax=(e=mo(),t=3,s=2,r=.5,i=1)=>AT(e,vi(t),s,r).mul(i),ux=(e=mo(),t=3,s=2,r=.5,i=1)=>CT(e,vi(t),s,r).mul(i),lx=(e=mo(),t=3,s=2,r=.5,i=1)=>RT(e,vi(t),s,r).mul(i),cx=(e=mo(),t=3,s=2,r=.5,i=1)=>ET(e,vi(t),s,r).mul(i);function dx(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function hx(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}class px{constructor(){this.renderItems=[],this.renderItemsIndex=0,this.opaque=[],this.transparent=[],this.lightsNode=new xc([]),this.lightsArray=[],this.occlusionQueryCount=0}begin(){return this.renderItemsIndex=0,this.opaque.length=0,this.transparent.length=0,this.lightsArray.length=0,this.occlusionQueryCount=0,this}getNextRenderItem(e,t,s,r,i,n){let o=this.renderItems[this.renderItemsIndex];return void 0===o?(o={id:e.id,object:e,geometry:t,material:s,groupOrder:r,renderOrder:e.renderOrder,z:i,group:n},this.renderItems[this.renderItemsIndex]=o):(o.id=e.id,o.object=e,o.geometry=t,o.material=s,o.groupOrder=r,o.renderOrder=e.renderOrder,o.z=i,o.group=n),this.renderItemsIndex++,o}push(e,t,s,r,i,n){const o=this.getNextRenderItem(e,t,s,r,i,n);!0===e.occlusionTest&&this.occlusionQueryCount++,(!0===s.transparent?this.transparent:this.opaque).push(o)}unshift(e,t,s,r,i,n){const o=this.getNextRenderItem(e,t,s,r,i,n);(!0===s.transparent?this.transparent:this.opaque).unshift(o)}pushLight(e){this.lightsArray.push(e)}getLightsNode(){return this.lightsNode.fromLights(this.lightsArray)}sort(e,t){this.opaque.length>1&&this.opaque.sort(e||dx),this.transparent.length>1&&this.transparent.sort(t||hx)}finish(){this.lightsNode.fromLights(this.lightsArray);for(let e=this.renderItemsIndex,t=this.renderItems.length;e<t;e++){const t=this.renderItems[e];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.groupOrder=null,t.renderOrder=null,t.z=null,t.group=null}}}class gx{constructor(){this.lists=new Ds}get(e,t){const s=this.lists,r=[e,t];let i=s.get(r);return void 0===i&&(i=new px,s.set(r,i)),i}dispose(){this.lists=new Ds}}let mx=0;class fx{constructor(){this.id=mx++,this.color=!0,this.clearColor=!0,this.clearColorValue={r:0,g:0,b:0,a:1},this.depth=!0,this.clearDepth=!0,this.clearDepthValue=1,this.stencil=!0,this.clearStencil=!0,this.clearStencilValue=1,this.viewport=!1,this.viewportValue=new s,this.scissor=!1,this.scissorValue=new s,this.textures=null,this.depthTexture=null,this.activeCubeFace=0,this.sampleCount=1,this.width=0,this.height=0,this.isRenderContext=!0}}class Tx{constructor(){this.chainMaps={}}get(e,t,s=null){const r=[e,t];let i;if(null===s)i="default";else{const e=s.texture.format;i=`${s.count}:${e}:${s.samples}:${s.depthBuffer}:${s.stencilBuffer}`}const n=this.getChainMap(i);let o=n.get(r);return void 0===o&&(o=new fx,n.set(r,o)),null!==s&&(o.sampleCount=0===s.samples?1:s.samples),o}getChainMap(e){return this.chainMaps[e]||(this.chainMaps[e]=new Ds)}dispose(){this.chainMaps={}}}const xx=new u;class yx extends js{constructor(e,t,s){super(),this.renderer=e,this.backend=t,this.info=s}updateRenderTarget(e,t=0){const s=this.get(e),r=0===e.samples?1:e.samples,i=s.depthTextureMips||(s.depthTextureMips={}),n=e.texture,o=e.textures,a=this.getSize(n),u=a.width>>t,l=a.height>>t;let c=e.depthTexture||i[t],d=!1;void 0===c&&(c=new N,c.format=e.stencilBuffer?ye:be,c.type=e.stencilBuffer?Ne:_e,c.image.width=u,c.image.height=l,i[t]=c),s.width===a.width&&a.height===s.height||(d=!0,c.needsUpdate=!0,c.image.width=u,c.image.height=l),s.width=a.width,s.height=a.height,s.textures=o,s.depthTexture=c,s.depth=e.depthBuffer,s.stencil=e.stencilBuffer,s.renderTarget=e,s.sampleCount!==r&&(d=!0,c.needsUpdate=!0,s.sampleCount=r);const h={sampleCount:r};for(let e=0;e<o.length;e++){const t=o[e];d&&(t.needsUpdate=!0),this.updateTexture(t,h)}if(this.updateTexture(c,h),!0!==s.initialized){s.initialized=!0;const t=()=>{if(e.removeEventListener("dispose",t),void 0!==o)for(let e=0;e<o.length;e++)this._destroyTexture(o[e]);else this._destroyTexture(n);this._destroyTexture(c)};e.addEventListener("dispose",t)}}updateTexture(e,t={}){const s=this.get(e);if(!0===s.initialized&&s.version===e.version)return;const r=e.isRenderTargetTexture||e.isDepthTexture||e.isFramebufferTexture,i=this.backend;if(r&&!0===s.initialized&&(i.destroySampler(e),i.destroyTexture(e)),e.isFramebufferTexture){const t=this.renderer.getRenderTarget();e.type=t?t.texture.type:ve}const{width:n,height:o,depth:a}=this.getSize(e);if(t.width=n,t.height=o,t.depth=a,t.needsMipmaps=this.needsMipmaps(e),t.levels=t.needsMipmaps?this.getMipLevels(e,n,o):1,r||!0===e.isStorageTexture)i.createSampler(e),i.createTexture(e,t);else{if(!0!==s.initialized&&i.createSampler(e),e.version>0){const r=e.image;if(void 0===r);else if(!1===r.complete);else{if(e.images){const s=[];for(const t of e.images)s.push(t);t.images=s}else t.image=r;void 0!==s.isDefaultTexture&&!0!==s.isDefaultTexture||(i.createTexture(e,t),s.isDefaultTexture=!1),!0===e.source.dataReady&&i.updateTexture(e,t),t.needsMipmaps&&0===e.mipmaps.length&&i.generateMipmaps(e)}}else i.createDefaultTexture(e),s.isDefaultTexture=!0}if(!0!==s.initialized){s.initialized=!0,this.info.memory.textures++;const t=()=>{e.removeEventListener("dispose",t),this._destroyTexture(e),this.info.memory.textures--};e.addEventListener("dispose",t)}s.version=e.version}getSize(e,t=xx){let s=e.images?e.images[0]:e.image;return s?(void 0!==s.image&&(s=s.image),t.width=s.width,t.height=s.height,t.depth=e.isCubeTexture?6:s.depth||1):t.width=t.height=t.depth=1,t}getMipLevels(e,t,s){let r;return r=e.isCompressedTexture?e.mipmaps.length:Math.floor(Math.log2(Math.max(t,s)))+1,r}needsMipmaps(e){return!!this.isEnvironmentTexture(e)||(!0===e.isCompressedTexture||e.minFilter!==_&&e.minFilter!==L)}isEnvironmentTexture(e){const t=e.mapping;return t===Se||t===Ae||t===Re||t===Ce}_destroyTexture(e){this.backend.destroySampler(e),this.backend.destroyTexture(e),this.delete(e)}}class bx extends o{constructor(e,t,s,r=1){super(e,t,s),this.a=r}set(e,t,s,r=1){return this.a=r,super.set(e,t,s)}copy(e){return void 0!==e.a&&(this.a=e.a),super.copy(e)}clone(){return new this.constructor(this.r,this.g,this.b,this.a)}}const Nx=new bx;class _x extends js{constructor(e,t){super(),this.renderer=e,this.nodes=t}update(e,t,s){const r=this.renderer,i=this.nodes.getBackgroundNode(e)||e.background;let n=!1;if(null===i)r._clearColor.getRGB(Nx,this.renderer.currentColorSpace),Nx.a=r._clearColor.a;else if(!0===i.isColor)i.getRGB(Nx,this.renderer.currentColorSpace),Nx.a=1,n=!0;else if(!0===i.isNode){const s=this.get(e),n=i;Nx.copy(r._clearColor);let o=s.backgroundMesh;if(void 0===o){const e=mn(Ui(n),{getUV:()=>Zu,getTextureLevel:e=>vp.mul(ou(e))}).mul(Sp);let t=Dl();t=t.setZ(t.w);const r=new cd;r.side=F,r.depthTest=!1,r.depthWrite=!1,r.fog=!1,r.vertexNode=t,r.fragmentNode=e,s.backgroundMeshNode=e,s.backgroundMesh=o=new O(new Ee(1,32,32),r),o.frustumCulled=!1,o.onBeforeRender=function(e,t,s){this.matrixWorld.copyPosition(s.matrixWorld)}}const a=n.getCacheKey();s.backgroundCacheKey!==a&&(s.backgroundMeshNode.node=Ui(n),o.material.needsUpdate=!0,s.backgroundCacheKey=a),t.unshift(o,o.geometry,o.material,0,0,null)}if(!0===r.autoClear||!0===n){Nx.multiplyScalar(Nx.a);const e=s.clearColorValue;e.r=Nx.r,e.g=Nx.g,e.b=Nx.b,e.a=Nx.a,s.depthClearValue=r._clearDepth,s.stencilClearValue=r._clearStencil,s.clearColor=!0===r.autoClearColor,s.clearDepth=!0===r.autoClearDepth,s.clearStencil=!0===r.autoClearStencil}else s.clearColor=!1,s.clearDepth=!1,s.clearStencil=!1}}class vx{constructor(e,t,s,r,i,n,o,a=[]){this.vertexShader=e,this.fragmentShader=t,this.computeShader=s,this.transforms=a,this.nodeAttributes=r,this.bindings=i,this.updateNodes=n,this.updateBeforeNodes=o,this.usedTimes=0}createBindings(){const e=[];for(const t of this.bindings){let s=t;!0!==t.shared&&(s=t.clone()),e.push(s)}return e}}class Sx extends js{constructor(e,t){super(),this.renderer=e,this.backend=t,this.nodeFrame=new Dd,this.nodeBuilderCache=new Map,this.callHashCache=new Ds,this.groupsData=new Ds}updateGroup(e){const t=e.groupNode,s=t.name;if(s===co.name)return!0;if(s===lo.name){const t=this.get(e),s=this.nodeFrame.renderId;return t.renderId!==s&&(t.renderId=s,!0)}if(s===uo.name){const t=this.get(e),s=this.nodeFrame.frameId;return t.frameId!==s&&(t.frameId=s,!0)}const r=[t,e];let i=this.groupsData.get(r);return void 0===i&&this.groupsData.set(r,i={}),i.version!==t.version&&(i.version=t.version,!0)}getForRenderCacheKey(e){return e.initialCacheKey}getForRender(e){const t=this.get(e);let s=t.nodeBuilderState;if(void 0===s){const{nodeBuilderCache:r}=this,i=this.getForRenderCacheKey(e);if(s=r.get(i),void 0===s){const t=this.backend.createNodeBuilder(e.object,this.renderer,e.scene);t.material=e.material,t.context.material=e.material,t.lightsNode=e.lightsNode,t.environmentNode=this.getEnvironmentNode(e.scene),t.fogNode=this.getFogNode(e.scene),t.toneMappingNode=this.getToneMappingNode(),t.clippingContext=e.clippingContext,t.build(),s=this._createNodeBuilderState(t),r.set(i,s)}s.usedTimes++,t.nodeBuilderState=s}return s}delete(e){if(e.isRenderObject){const t=this.get(e).nodeBuilderState;t.usedTimes--,0===t.usedTimes&&this.nodeBuilderCache.delete(this.getForRenderCacheKey(e))}return super.delete(e)}getForCompute(e){const t=this.get(e);let s=t.nodeBuilderState;if(void 0===s){const r=this.backend.createNodeBuilder(e,this.renderer);r.build(),s=this._createNodeBuilderState(r),t.nodeBuilderState=s}return s}_createNodeBuilderState(e){return new vx(e.vertexShader,e.fragmentShader,e.computeShader,e.getAttributesArray(),e.getBindings(),e.updateNodes,e.updateBeforeNodes,e.transforms)}getEnvironmentNode(e){return e.environmentNode||this.get(e).environmentNode||null}getBackgroundNode(e){return e.backgroundNode||this.get(e).backgroundNode||null}getFogNode(e){return e.fogNode||this.get(e).fogNode||null}getToneMappingNode(){return!1===this.isToneMappingState?null:this.renderer.toneMappingNode||this.get(this.renderer).toneMappingNode||null}getCacheKey(e,t){const s=[e,t],r=this.renderer.info.calls;let i=this.callHashCache.get(s);if(void 0===i||i.callId!==r){const n=this.getEnvironmentNode(e),o=this.getFogNode(e),a=this.getToneMappingNode(),u=[];t&&u.push(t.getCacheKey()),n&&u.push(n.getCacheKey()),o&&u.push(o.getCacheKey()),a&&u.push(a.getCacheKey()),i={callId:r,cacheKey:u.join(",")},this.callHashCache.set(s,i)}return i.cacheKey}updateScene(e){this.updateEnvironment(e),this.updateFog(e),this.updateBackground(e),this.updateToneMapping()}get isToneMappingState(){const e=this.renderer.getRenderTarget();return!e||!e.isCubeRenderTarget}updateToneMapping(){const e=this.renderer,t=this.get(e),s=e.toneMapping;if(this.isToneMappingState&&s!==W){if(t.toneMapping!==s){const r=t.rendererToneMappingNode||xg(s,xu("toneMappingExposure","float",e));r.toneMapping=s,t.rendererToneMappingNode=r,t.toneMappingNode=r,t.toneMapping=s}}else delete t.toneMappingNode,delete t.toneMapping}updateBackground(e){const t=this.get(e),s=e.background;if(s){if(t.background!==s){let e=null;if(!0===s.isCubeTexture)e=pc(s,Zu);else if(!0===s.isTexture){let t=null;s.mapping===Se||s.mapping===Ae?(t=Rc(),s.flipY=!1):t=Gc,e=uu(s,t).setUpdateMatrix(!0)}else s.isColor;t.backgroundNode=e,t.background=s}}else t.backgroundNode&&(delete t.backgroundNode,delete t.background)}updateFog(e){const t=this.get(e),s=e.fog;if(s){if(t.fog!==s){let e=null;s.isFogExp2?e=em(xu("color","color",s),xu("density","float",s)):s.isFog&&(e=Zg(xu("color","color",s),xu("near","float",s),xu("far","float",s))),t.fogNode=e,t.fog=s}}else delete t.fogNode,delete t.fog}updateEnvironment(e){const t=this.get(e),s=e.environment;if(s){if(t.environment!==s){let e=null;!0===s.isCubeTexture?e=pc(s):!0===s.isTexture&&(e=uu(s)),t.environmentNode=e,t.environment=s}}else t.environmentNode&&(delete t.environmentNode,delete t.environment)}getNodeFrame(e=this.renderer,t=null,s=null,r=null,i=null){const n=this.nodeFrame;return n.renderer=e,n.scene=t,n.object=s,n.camera=r,n.material=i,n}getNodeFrameForRender(e){return this.getNodeFrame(e.renderer,e.scene,e.object,e.camera,e.material)}updateBefore(e){const t=this.getNodeFrameForRender(e),s=e.getNodeBuilderState();for(const e of s.updateBeforeNodes)t.updateBeforeNode(e)}updateForCompute(e){const t=this.getNodeFrame(),s=this.getForCompute(e);for(const e of s.updateNodes)t.updateNode(e)}updateForRender(e){const t=this.getNodeFrameForRender(e),s=e.getNodeBuilderState();for(const e of s.updateNodes)t.updateNode(e)}dispose(){super.dispose(),this.nodeFrame=new Dd,this.nodeBuilderCache=new Map}}const Ax=new U,Rx=new a,Cx=new s,Ex=new we,wx=new l,Mx=new u;class Fx{constructor(e,t={}){this.isRenderer=!0;const{logarithmicDepthBuffer:r=!1,alpha:i=!0}=t;this.domElement=e.getDomElement(),this.backend=e,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.alpha=i,this.logarithmicDepthBuffer=r,this.outputColorSpace=p,this.toneMapping=W,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=!0,this.stencil=!0,this.clippingPlanes=[],this.info=new tr,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new s(0,0,this._width,this._height),this._scissor=new s(0,0,this._width,this._height),this._scissorTest=!1,this._attributes=null,this._geometries=null,this._nodes=null,this._animation=null,this._bindings=null,this._objects=null,this._pipelines=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._currentRenderContext=null,this._opaqueSort=null,this._transparentSort=null;const n=!0===this.alpha?0:1;this._clearColor=new bx(0,0,0,n),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._activeCubeFace=0,this._activeMipmapLevel=0,this._renderObjectFunction=null,this._currentRenderObjectFunction=null,this._handleObjectFunction=this._renderObjectDirect,this._initialized=!1,this._initPromise=null,this._compilationPromises=null,this.shadowMap={enabled:!1,type:null},this.xr={enabled:!1}}async init(){if(this._initialized)throw new Error("Renderer: Backend has already been initialized.");return null!==this._initPromise||(this._initPromise=new Promise((async(e,t)=>{const s=this.backend;try{await s.init(this)}catch(e){return void t(e)}this._nodes=new Sx(this,s),this._animation=new Ps(this._nodes,this.info),this._attributes=new Qs(s),this._background=new _x(this,this._nodes),this._geometries=new er(this._attributes,this.info),this._textures=new yx(this,s,this.info),this._pipelines=new ar(s,this._nodes),this._bindings=new ur(s,this._nodes,this._textures,this._attributes,this._pipelines,this.info),this._objects=new Ws(this,this._nodes,this._geometries,this._pipelines,this._bindings,this.info),this._renderLists=new gx,this._renderContexts=new Tx,this._initialized=!0,e()}))),this._initPromise}get coordinateSystem(){return this.backend.coordinateSystem}async compileAsync(e,t,s=null){!1===this._initialized&&await this.init();const r=this._nodes.nodeFrame,i=r.renderId,n=this._currentRenderContext,o=this._currentRenderObjectFunction,a=this._compilationPromises,u=!0===e.isScene?e:Ax;null===s&&(s=e);const l=this._renderTarget,c=this._renderContexts.get(s,t,l),d=this._activeMipmapLevel,h=[];this._currentRenderContext=c,this._currentRenderObjectFunction=this.renderObject,this._handleObjectFunction=this._createObjectPipeline,this._compilationPromises=h,r.renderId++,r.update(),c.depth=this.depth,c.stencil=this.stencil,c.clippingContext||(c.clippingContext=new zs),c.clippingContext.updateGlobal(this,t),u.onBeforeRender(this,e,t,l);const p=this._renderLists.get(e,t);if(p.begin(),this._projectObject(e,t,0,p),s!==e&&s.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&p.pushLight(e)})),p.finish(),null!==l){this._textures.updateRenderTarget(l,d);const e=this._textures.get(l);c.textures=e.textures,c.depthTexture=e.depthTexture}else c.textures=null,c.depthTexture=null;this._nodes.updateScene(u),this._background.update(u,p,c);const g=p.opaque,m=p.transparent,f=p.lightsNode;g.length>0&&this._renderObjects(g,t,u,f),m.length>0&&this._renderObjects(m,t,u,f),r.renderId=i,this._currentRenderContext=n,this._currentRenderObjectFunction=o,this._compilationPromises=a,this._handleObjectFunction=this._renderObjectDirect,await Promise.all(h)}async renderAsync(e,t){!1===this._initialized&&await this.init();const s=this._renderContext(e,t);await this.backend.resolveTimestampAsync(s,"render")}render(e,t){!1!==this._initialized&&this._renderContext(e,t)}_renderContext(e,t){const s=this._nodes.nodeFrame,r=s.renderId,i=this._currentRenderContext,n=this._currentRenderObjectFunction,o=!0===e.isScene?e:Ax,a=this._renderTarget,u=this._renderContexts.get(e,t,a),l=this._activeCubeFace,c=this._activeMipmapLevel;this._currentRenderContext=u,this._currentRenderObjectFunction=this._renderObjectFunction||this.renderObject,this.info.calls++,this.info.render.calls++,s.renderId=this.info.calls;const d=this.coordinateSystem;t.coordinateSystem!==d&&(t.coordinateSystem=d,t.updateProjectionMatrix()),!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),null===t.parent&&!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),!0===this.info.autoReset&&this.info.reset();let h=this._viewport,p=this._scissor,g=this._pixelRatio;null!==a&&(h=a.viewport,p=a.scissor,g=1),this.getDrawingBufferSize(Rx),Cx.set(0,0,Rx.width,Rx.height);const m=void 0===h.minDepth?0:h.minDepth,f=void 0===h.maxDepth?1:h.maxDepth;u.viewportValue.copy(h).multiplyScalar(g).floor(),u.viewportValue.width>>=c,u.viewportValue.height>>=c,u.viewportValue.minDepth=m,u.viewportValue.maxDepth=f,u.viewport=!1===u.viewportValue.equals(Cx),u.scissorValue.copy(p).multiplyScalar(g).floor(),u.scissor=this._scissorTest&&!1===u.scissorValue.equals(Cx),u.scissorValue.width>>=c,u.scissorValue.height>>=c,u.clippingContext||(u.clippingContext=new zs),u.clippingContext.updateGlobal(this,t),o.onBeforeRender(this,e,t,a),wx.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),Ex.setFromProjectionMatrix(wx,d);const T=this._renderLists.get(e,t);if(T.begin(),this._projectObject(e,t,0,T),T.finish(),!0===this.sortObjects&&T.sort(this._opaqueSort,this._transparentSort),null!==a){this._textures.updateRenderTarget(a,c);const e=this._textures.get(a);u.textures=e.textures,u.depthTexture=e.depthTexture,u.width=e.width,u.height=e.height,u.renderTarget=a,u.depth=a.depthBuffer,u.stencil=a.stencilBuffer}else u.textures=null,u.depthTexture=null,u.width=this.domElement.width,u.height=this.domElement.height,u.depth=this.depth,u.stencil=this.stencil;u.width>>=c,u.height>>=c,u.activeCubeFace=l,u.activeMipmapLevel=c,u.occlusionQueryCount=T.occlusionQueryCount,this._nodes.updateScene(o),this._background.update(o,T,u),this.backend.beginRender(u);const x=T.opaque,y=T.transparent,b=T.lightsNode;return x.length>0&&this._renderObjects(x,t,o,b),y.length>0&&this._renderObjects(y,t,o,b),this.backend.finishRender(u),s.renderId=r,this._currentRenderContext=i,this._currentRenderObjectFunction=n,o.onAfterRender(this,e,t,a),u}getMaxAnisotropy(){return this.backend.getMaxAnisotropy()}getActiveCubeFace(){return this._activeCubeFace}getActiveMipmapLevel(){return this._activeMipmapLevel}async setAnimationLoop(e){!1===this._initialized&&await this.init(),this._animation.setAnimationLoop(e)}getArrayBuffer(e){return this.getArrayBufferAsync(e)}async getArrayBufferAsync(e){return await this.backend.getArrayBufferAsync(e)}getContext(){return this.backend.getContext()}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(e){return e.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(e){return e.set(this._width,this._height)}setPixelRatio(e=1){this._pixelRatio=e,this.setSize(this._width,this._height,!1)}setDrawingBufferSize(e,t,s){this._width=e,this._height=t,this._pixelRatio=s,this.domElement.width=Math.floor(e*s),this.domElement.height=Math.floor(t*s),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize()}setSize(e,t,s=!0){this._width=e,this._height=t,this.domElement.width=Math.floor(e*this._pixelRatio),this.domElement.height=Math.floor(t*this._pixelRatio),!0===s&&(this.domElement.style.width=e+"px",this.domElement.style.height=t+"px"),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize()}setOpaqueSort(e){this._opaqueSort=e}setTransparentSort(e){this._transparentSort=e}getScissor(e){const t=this._scissor;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e}setScissor(e,t,s,r){const i=this._scissor;e.isVector4?i.copy(e):i.set(e,t,s,r)}getScissorTest(){return this._scissorTest}setScissorTest(e){this._scissorTest=e,this.backend.setScissorTest(e)}getViewport(e){return e.copy(this._viewport)}setViewport(e,t,s,r,i=0,n=1){const o=this._viewport;e.isVector4?o.copy(e):o.set(e,t,s,r),o.minDepth=i,o.maxDepth=n}getClearColor(e){return e.copy(this._clearColor)}setClearColor(e,t=1){this._clearColor.set(e),this._clearColor.a=t}getClearAlpha(){return this._clearColor.a}setClearAlpha(e){this._clearColor.a=e}getClearDepth(){return this._clearDepth}setClearDepth(e){this._clearDepth=e}getClearStencil(){return this._clearStencil}setClearStencil(e){this._clearStencil=e}isOccluded(e){const t=this._currentRenderContext;return t&&this.backend.isOccluded(t,e)}clear(e=!0,t=!0,s=!0){let r=null;const i=this._renderTarget;null!==i&&(this._textures.updateRenderTarget(i),r=this._textures.get(i)),this.backend.clear(e,t,s,r)}clearColor(){return this.clear(!0,!1,!1)}clearDepth(){return this.clear(!1,!0,!1)}clearStencil(){return this.clear(!1,!1,!0)}async clearAsync(e=!0,t=!0,s=!0){!1===this._initialized&&await this.init(),this.clear(e,t,s)}clearColorAsync(){return this.clearAsync(!0,!1,!1)}clearDepthAsync(){return this.clearAsync(!1,!0,!1)}clearStencilAsync(){return this.clearAsync(!1,!1,!0)}get currentColorSpace(){const e=this._renderTarget;if(null!==e){const t=e.texture;return(Array.isArray(t)?t[0]:t).colorSpace}return this.outputColorSpace}dispose(){this.info.dispose(),this._animation.dispose(),this._objects.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(e,t=0,s=0){this._renderTarget=e,this._activeCubeFace=t,this._activeMipmapLevel=s}getRenderTarget(){return this._renderTarget}setRenderObjectFunction(e){this._renderObjectFunction=e}getRenderObjectFunction(){return this._renderObjectFunction}async computeAsync(e){!1===this._initialized&&await this.init();const t=this._nodes.nodeFrame,s=t.renderId;this.info.calls++,this.info.compute.calls++,this.info.compute.computeCalls++,t.renderId=this.info.calls,!0===this.info.autoReset&&this.info.resetCompute();const r=this.backend,i=this._pipelines,n=this._bindings,o=this._nodes,a=Array.isArray(e)?e:[e];if(void 0===a[0]||!0!==a[0].isComputeNode)throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");r.beginCompute(e);for(const t of a){if(!1===i.has(t)){const e=()=>{t.removeEventListener("dispose",e),i.delete(t),n.delete(t),o.delete(t)};t.addEventListener("dispose",e),t.onInit({renderer:this})}o.updateForCompute(t),n.updateForCompute(t);const s=n.getForCompute(t),a=i.getForCompute(t,s);r.compute(e,t,s,a)}r.finishCompute(e),await this.backend.resolveTimestampAsync(e,"compute"),t.renderId=s}hasFeatureAsync(e){return this.backend.hasFeatureAsync(e)}hasFeature(e){return this.backend.hasFeature(e)}copyFramebufferToTexture(e){const t=this._currentRenderContext;this._textures.updateTexture(e),this.backend.copyFramebufferToTexture(e,t)}readRenderTargetPixelsAsync(e,t,s,r,i){return this.backend.copyTextureToBuffer(e.texture,t,s,r,i)}_projectObject(e,t,s,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)s=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)r.pushLight(e);else if(e.isSprite){if(!e.frustumCulled||Ex.intersectsSprite(e)){!0===this.sortObjects&&Mx.setFromMatrixPosition(e.matrixWorld).applyMatrix4(wx);const t=e.geometry,i=e.material;i.visible&&r.push(e,t,i,s,Mx.z,null)}}else if(e.isLineLoop);else if((e.isMesh||e.isLine||e.isPoints)&&(!e.frustumCulled||Ex.intersectsObject(e))){const t=e.geometry,i=e.material;if(!0===this.sortObjects&&(null===t.boundingSphere&&t.computeBoundingSphere(),Mx.copy(t.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(wx)),Array.isArray(i)){const n=t.groups;for(let o=0,a=n.length;o<a;o++){const a=n[o],u=i[a.materialIndex];u&&u.visible&&r.push(e,t,u,s,Mx.z,a)}}else i.visible&&r.push(e,t,i,s,Mx.z,null)}const i=e.children;for(let e=0,n=i.length;e<n;e++)this._projectObject(i[e],t,s,r)}_renderObjects(e,t,s,r){for(let i=0,n=e.length;i<n;i++){const n=e[i],{object:o,geometry:a,material:u,group:l}=n;if(t.isArrayCamera){const e=t.cameras;for(let t=0,i=e.length;t<i;t++){const i=e[t];if(o.layers.test(i.layers)){const e=i.viewport,t=void 0===e.minDepth?0:e.minDepth,n=void 0===e.maxDepth?1:e.maxDepth,c=this._currentRenderContext.viewportValue;c.copy(e).multiplyScalar(this._pixelRatio).floor(),c.minDepth=t,c.maxDepth=n,this.backend.updateViewport(this._currentRenderContext),this._currentRenderObjectFunction(o,s,i,a,u,l,r)}}}else this._currentRenderObjectFunction(o,s,t,a,u,l,r)}}renderObject(e,t,s,r,i,n,o){let a,u;if(e.onBeforeRender(this,t,s,r,i,n),i.onBeforeRender(this,t,s,r,i,n),null!==t.overrideMaterial){const e=t.overrideMaterial;i.positionNode&&i.positionNode.isNode&&(a=e.positionNode,e.positionNode=i.positionNode),e.isShadowNodeMaterial&&(e.side=null===i.shadowSide?i.side:i.shadowSide,i.shadowNode&&i.shadowNode.isNode&&(u=e.fragmentNode,e.fragmentNode=i.shadowNode),this.localClippingEnabled&&(i.clipShadows?(e.clippingPlanes!==i.clippingPlanes&&(e.clippingPlanes=i.clippingPlanes,e.needsUpdate=!0),e.clipIntersection!==i.clipIntersection&&(e.clipIntersection=i.clipIntersection)):Array.isArray(e.clippingPlanes)&&(e.clippingPlanes=null,e.needsUpdate=!0))),i=e}!0===i.transparent&&i.side===Me&&!1===i.forceSinglePass?(i.side=F,this._handleObjectFunction(e,i,t,s,o,"backSide"),i.side=Fe,this._handleObjectFunction(e,i,t,s,o),i.side=Me):this._handleObjectFunction(e,i,t,s,o),void 0!==a&&(t.overrideMaterial.positionNode=a),void 0!==u&&(t.overrideMaterial.fragmentNode=u),e.onAfterRender(this,t,s,r,i,n)}_renderObjectDirect(e,t,s,r,i,n){const o=this._objects.get(e,t,s,r,i,this._currentRenderContext,n);this._nodes.updateBefore(o),e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),this._nodes.updateForRender(o),this._geometries.updateForRender(o),this._bindings.updateForRender(o),this._pipelines.updateForRender(o),this.backend.draw(o,this.info)}_createObjectPipeline(e,t,s,r,i,n){const o=this._objects.get(e,t,s,r,i,this._currentRenderContext,n);this._nodes.updateBefore(o),this._nodes.updateForRender(o),this._geometries.updateForRender(o),this._bindings.updateForRender(o),this._pipelines.getForRender(o,this._compilationPromises)}get compute(){return this.computeAsync}get compile(){return this.compileAsync}}class Bx{constructor(e=""){this.name=e,this.visibility=0}setVisibility(e){this.visibility|=e}clone(){return Object.assign(new this.constructor,this)}}class Ox extends Bx{constructor(e,t=null){super(e),this.isBuffer=!0,this.bytesPerElement=Float32Array.BYTES_PER_ELEMENT,this._buffer=t}get byteLength(){return(e=this._buffer.byteLength)+(Ks-e%Ks)%Ks;var e}get buffer(){return this._buffer}update(){return!0}}class Ux extends Ox{constructor(e,t=null){super(e,t),this.isUniformBuffer=!0}}let Lx=0;class Ix extends Ux{constructor(e){super("UniformBuffer_"+Lx++,e?e.value:null),this.nodeUniform=e}get buffer(){return this.nodeUniform.value}}class Px extends Ux{constructor(e){super(e),this.isUniformsGroup=!0,this.uniforms=[]}addUniform(e){return this.uniforms.push(e),this}removeUniform(e){const t=this.uniforms.indexOf(e);return-1!==t&&this.uniforms.splice(t,1),this}get buffer(){let e=this._buffer;if(null===e){const t=this.byteLength;e=new Float32Array(new ArrayBuffer(t)),this._buffer=e}return e}get byteLength(){let e=0;for(let t=0,s=this.uniforms.length;t<s;t++){const s=this.uniforms[t],{boundary:r,itemSize:i}=s,n=e%Ks;0!==n&&Ks-n-r<0?e+=Ks-n:n%r!=0&&(e+=n%r),s.offset=e/this.bytesPerElement,e+=i*this.bytesPerElement}return Math.ceil(e/Ks)*Ks}update(){let e=!1;for(const t of this.uniforms)!0===this.updateByType(t)&&(e=!0);return e}updateByType(e){return e.isFloatUniform?this.updateNumber(e):e.isVector2Uniform?this.updateVector2(e):e.isVector3Uniform?this.updateVector3(e):e.isVector4Uniform?this.updateVector4(e):e.isColorUniform?this.updateColor(e):e.isMatrix3Uniform?this.updateMatrix3(e):e.isMatrix4Uniform?this.updateMatrix4(e):void 0}updateNumber(e){let t=!1;const s=this.buffer,r=e.getValue(),i=e.offset;return s[i]!==r&&(s[i]=r,t=!0),t}updateVector2(e){let t=!1;const s=this.buffer,r=e.getValue(),i=e.offset;return s[i+0]===r.x&&s[i+1]===r.y||(s[i+0]=r.x,s[i+1]=r.y,t=!0),t}updateVector3(e){let t=!1;const s=this.buffer,r=e.getValue(),i=e.offset;return s[i+0]===r.x&&s[i+1]===r.y&&s[i+2]===r.z||(s[i+0]=r.x,s[i+1]=r.y,s[i+2]=r.z,t=!0),t}updateVector4(e){let t=!1;const s=this.buffer,r=e.getValue(),i=e.offset;return s[i+0]===r.x&&s[i+1]===r.y&&s[i+2]===r.z&&s[i+4]===r.w||(s[i+0]=r.x,s[i+1]=r.y,s[i+2]=r.z,s[i+3]=r.w,t=!0),t}updateColor(e){let t=!1;const s=this.buffer,r=e.getValue(),i=e.offset;return s[i+0]===r.r&&s[i+1]===r.g&&s[i+2]===r.b||(s[i+0]=r.r,s[i+1]=r.g,s[i+2]=r.b,t=!0),t}updateMatrix3(e){let t=!1;const s=this.buffer,r=e.getValue().elements,i=e.offset;return s[i+0]===r[0]&&s[i+1]===r[1]&&s[i+2]===r[2]&&s[i+4]===r[3]&&s[i+5]===r[4]&&s[i+6]===r[5]&&s[i+8]===r[6]&&s[i+9]===r[7]&&s[i+10]===r[8]||(s[i+0]=r[0],s[i+1]=r[1],s[i+2]=r[2],s[i+4]=r[3],s[i+5]=r[4],s[i+6]=r[5],s[i+8]=r[6],s[i+9]=r[7],s[i+10]=r[8],t=!0),t}updateMatrix4(e){let t=!1;const s=this.buffer,r=e.getValue().elements,i=e.offset;return!1===function(e,t,s){for(let r=0,i=t.length;r<i;r++)if(e[s+r]!==t[r])return!1;return!0}(s,r,i)&&(s.set(r,i),t=!0),t}}let Dx=0;class Vx extends Px{constructor(e,t){super(e),this.id=Dx++,this.groupNode=t,this.isNodeUniformsGroup=!0}get shared(){return this.groupNode.shared}getNodes(){const e=[];for(const t of this.uniforms){const s=t.nodeUniform.node;if(!s)throw new Error("NodeUniformsGroup: Uniform has no node.");e.push(s)}return e}}let Gx=0;class kx extends Bx{constructor(e,t){super(e),this.id=Gx++,this.texture=t,this.version=t?t.version:0,this.store=!1,this.isSampledTexture=!0}get needsBindingsUpdate(){const{texture:e,version:t}=this;return!!e.isVideoTexture||t!==e.version}update(){const{texture:e,version:t}=this;return t!==e.version&&(this.version=e.version,!0)}}class zx extends kx{constructor(e,t){super(e,t?t.value:null),this.textureNode=t}get needsBindingsUpdate(){return this.textureNode.value!==this.texture||super.needsBindingsUpdate}update(){const{textureNode:e}=this;return this.texture!==e.value?(this.texture=e.value,!0):super.update()}}class $x extends zx{constructor(e,t){super(e,t),this.isSampledCubeTexture=!0}}const Hx={[Go.ATAN2]:"atan",textureDimensions:"textureSize",equals:"equal"},Wx={low:"lowp",medium:"mediump",high:"highp"},jx={instance:!0,swizzleAssign:!0},qx="\nprecision highp float;\nprecision highp int;\nprecision mediump sampler2DArray;\nprecision lowp sampler2DShadow;\n";class Xx extends Pd{constructor(e,t,s=null){super(e,t,new Rf,s),this.uniformGroups={},this.transforms=[]}getMethod(e){return Hx[e]||e}getPropertyName(e,t){return e.isOutputStructVar?"":super.getPropertyName(e,t)}buildFunctionCode(e){const t=e.layout,s=this.flowShaderNode(e),r=[];for(const e of t.inputs)r.push(this.getType(e.type)+" "+e.name);return`${this.getType(t.type)} ${t.name}( ${r.join(", ")} ) {\n\n\t${s.vars}\n\n${s.code}\n\treturn ${s.result};\n\n}`}setupPBO(e){const t=e.value;if(void 0===t.pbo){const e=t.array,s=t.count*t.itemSize,{itemSize:r}=t;let i=Ue;2===r?i=Le:3===r?i=6407:4===r&&(i=Ie);const n=Math.pow(2,Math.ceil(Math.log2(Math.sqrt(s/r))));let o=Math.ceil(s/r/n);n*o*r<s&&o++;const a=new Float32Array(n*o*r);a.set(e,0),t.array=a;const u=new Be(t.array,n,o,i,y);u.needsUpdate=!0,u.isPBOTexture=!0;const l=new ho(u);l.setPrecision("high"),t.pboNode=l,t.pbo=l.value,this.getUniformFromNode(t.pboNode,"texture",this.shaderStage,this.context.label)}}generatePBO(e){const{node:t,indexNode:s}=e,r=t.value;if(this.renderer.backend.has(r)){this.renderer.backend.get(r).pbo=r.pbo}const i=this.getUniformFromNode(r.pboNode,"texture",this.shaderStage,this.context.label),n=this.getPropertyName(i);s.increaseUsage(this);const o=s.build(this,"uint"),a=this.getDataFromNode(e);let u=a.propertyName;if(void 0===u){const s=this.getVarFromNode(e);u=this.getPropertyName(s);const i=this.getDataFromNode(t);let l=i.propertySizeName;void 0===l&&(l=u+"Size",this.getVarFromNode(t,l,"uint"),this.addLineFlowCode(`${l} = uint( textureSize( ${n}, 0 ).x )`),i.propertySizeName=l);const{itemSize:c}=r,d="."+mr.join("").slice(0,c),h=`ivec2(${o} % ${l}, ${o} / ${l})`,p=this.generateTextureLoad(null,n,h,null,"0");this.addLineFlowCode(`${u} = ${p+d}`),a.propertyName=u}return u}generateTextureLoad(e,t,s,r,i="0"){return r?`texelFetch( ${t}, ivec3( ${s}, ${r} ), ${i} )`:`texelFetch( ${t}, ${s}, ${i} )`}generateTexture(e,t,s,r){return e.isDepthTexture?`texture( ${t}, ${s} ).x`:(r&&(s=`vec3( ${s}, ${r} )`),`texture( ${t}, ${s} )`)}generateTextureLevel(e,t,s,r){return`textureLod( ${t}, ${s}, ${r} )`}generateTextureCompare(e,t,s,r,i,n=this.shaderStage){if("fragment"===n)return`texture( ${t}, vec3( ${s}, ${r} ) )`}getVars(e){const t=[],s=this.vars[e];if(void 0!==s)for(const e of s)e.isOutputStructVar||t.push(`${this.getVar(e.type,e.name)};`);return t.join("\n\t")}getUniforms(e){const t=this.uniforms[e],s=[],r={};for(const e of t){let t=null,i=!1;if("texture"===e.type){const s=e.node.value;t=s.compareFunction?`sampler2DShadow ${e.name};`:!0===s.isDataArrayTexture?`sampler2DArray ${e.name};`:`sampler2D ${e.name};`}else if("cubeTexture"===e.type)t=`samplerCube ${e.name};`;else if("buffer"===e.type){const s=e.node,r=this.getType(s.bufferType),i=s.bufferCount,n=i>0?i:"";t=`${s.name} {\n\t${r} ${e.name}[${n}];\n};\n`}else{t=`${this.getVectorType(e.type)} ${e.name};`,i=!0}const n=e.node.precision;if(null!==n&&(t=Wx[n]+" "+t),i){t="\t"+t;const s=e.groupNode.name;(r[s]||(r[s]=[])).push(t)}else t="uniform "+t,s.push(t)}let i="";for(const t in r){const s=r[t];i+=this._getGLSLUniformStruct(e+"_"+t,s.join("\n"))+"\n"}return i+=s.join("\n"),i}getTypeFromAttribute(e){let t=super.getTypeFromAttribute(e);if(/^[iu]/.test(t)&&e.gpuType!==Oe){let s=e;e.isInterleavedBufferAttribute&&(s=e.data);const r=s.array;!1==(r instanceof Uint32Array||r instanceof Int32Array)&&(t=t.slice(1))}return t}getAttributes(e){let t="";if("vertex"===e||"compute"===e){const e=this.getAttributesArray();let s=0;for(const r of e)t+=`layout( location = ${s++} ) in ${r.type} ${r.name};\n`}return t}getStructMembers(e){const t=[],s=e.getMemberTypes();for(let e=0;e<s.length;e++){const r=s[e];t.push(`layout( location = ${e} ) out ${r} m${e};`)}return t.join("\n")}getStructs(e){const t=[],s=this.structs[e];if(0===s.length)return"layout( location = 0 ) out vec4 fragColor;\n";for(let e=0,r=s.length;e<r;e++){const r=s[e];let i="\n";i+=this.getStructMembers(r),i+="\n",t.push(i)}return t.join("\n\n")}getVaryings(e){let t="";const s=this.varyings;if("vertex"===e||"compute"===e)for(const r of s){"compute"===e&&(r.needsInterpolation=!0);const s=r.type;t+=`${"int"===s||"uint"===s?"flat ":""}${r.needsInterpolation?"out":"/*out*/"} ${s} ${r.name};\n`}else if("fragment"===e)for(const e of s)if(e.needsInterpolation){const s=e.type;t+=`${"int"===s||"uint"===s?"flat ":""}in ${s} ${e.name};\n`}return t}getVertexIndex(){return"uint( gl_VertexID )"}getInstanceIndex(){return"uint( gl_InstanceID )"}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord"}getFragDepth(){return"gl_FragDepth"}isAvailable(e){return!0===jx[e]}isFlipY(){return!0}registerTransform(e,t){this.transforms.push({varyingName:e,attributeNode:t})}getTransforms(){const e=this.transforms;let t="";for(let s=0;s<e.length;s++){const r=e[s],i=this.getPropertyName(r.attributeNode);t+=`${r.varyingName} = ${i};\n\t`}return t}_getGLSLUniformStruct(e,t){return`\nlayout( std140 ) uniform ${e} {\n${t}\n};`}_getGLSLVertexCode(e){return`#version 300 es\n\n${this.getSignature()}\n\n// precision\n${qx}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// attributes\n${e.attributes}\n\n// codes\n${e.codes}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// transforms\n\t${e.transforms}\n\n\t// flow\n\t${e.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`}_getGLSLFragmentCode(e){return`#version 300 es\n\n${this.getSignature()}\n\n// precision\n${qx}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// codes\n${e.codes}\n\n${e.structs}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};for(const t in e){let s="// code\n\n";s+=this.flowCode[t];const r=this.flowNodes[t],i=r[r.length-1];for(const e of r){const r=this.getFlowData(e),n=e.name;n&&(s.length>0&&(s+="\n"),s+=`\t// flow -> ${n}\n\t`),s+=`${r.code}\n\t`,e===i&&"compute"!==t&&(s+="// result\n\t","vertex"===t?(s+="gl_Position = ",s+=`${r.result};`):"fragment"===t&&(e.outputNode.isOutputStructNode||(s+="fragColor = ",s+=`${r.result};`)))}const n=e[t];n.uniforms=this.getUniforms(t),n.attributes=this.getAttributes(t),n.varyings=this.getVaryings(t),n.vars=this.getVars(t),n.structs=this.getStructs(t),n.codes=this.getCodes(t),n.transforms=this.getTransforms(t),n.flow=s}null!==this.material?(this.vertexShader=this._getGLSLVertexCode(e.vertex),this.fragmentShader=this._getGLSLFragmentCode(e.fragment)):this.computeShader=this._getGLSLVertexCode(e.compute)}getUniformFromNode(e,t,s,r=null){const i=super.getUniformFromNode(e,t,s,r),n=this.getDataFromNode(e,s,this.globalCache);let o=n.uniformGPU;if(void 0===o){if("texture"===t)o=new zx(i.name,i.node),this.bindings[s].push(o);else if("cubeTexture"===t)o=new $x(i.name,i.node),this.bindings[s].push(o);else if("buffer"===t){e.name=`NodeBuffer_${e.id}`,i.name=`buffer${e.id}`;const t=new Ix(e);t.name=e.name,this.bindings[s].push(t),o=t}else{const r=e.groupNode,n=r.name,a=this.uniformGroups[s]||(this.uniformGroups[s]={});let u=a[n];void 0===u&&(u=new Vx(s+"_"+n,r),a[n]=u,this.bindings[s].push(u)),o=this.getNodeUniform(i,t),u.addUniform(o)}n.uniformGPU=o}return i}}let Yx=null,Kx=null,Qx=null;class Zx{constructor(e={}){this.parameters=Object.assign({},e),this.data=new WeakMap,this.renderer=null,this.domElement=null}async init(e){this.renderer=e}begin(e){}finish(e){}draw(e,t){}createProgram(e){}destroyProgram(e){}createBindings(e){}updateBindings(e){}createRenderPipeline(e){}createComputePipeline(e,t){}destroyPipeline(e){}needsRenderUpdate(e){}getRenderCacheKey(e){}createNodeBuilder(e){}createSampler(e){}createDefaultTexture(e){}createTexture(e){}copyTextureToBuffer(e,t,s,r,i){}createAttribute(e){}createIndexAttribute(e){}updateAttribute(e){}destroyAttribute(e){}getContext(){}updateSize(){}resolveTimestampAsync(e,t){}hasFeatureAsync(e){}hasFeature(e){}getInstanceCount(e){const{object:t,geometry:s}=e;return s.isInstancedBufferGeometry?s.instanceCount:t.isInstancedMesh?t.count:1}getDrawingBufferSize(){return Yx=Yx||new a,this.renderer.getDrawingBufferSize(Yx)}getScissor(){return Kx=Kx||new s,this.renderer.getScissor(Kx)}setScissorTest(e){}getClearColor(){const e=this.renderer;return Qx=Qx||new bx,e.getClearColor(Qx),Qx.getRGB(Qx,this.renderer.currentColorSpace),Qx}getDomElement(){let e=this.domElement;return null===e&&(e=void 0!==this.parameters.canvas?this.parameters.canvas:Pe(),"setAttribute"in e&&e.setAttribute("data-engine",`three.js r${V} webgpu`),this.domElement=e),e}set(e,t){this.data.set(e,t)}get(e){let t=this.data.get(e);return void 0===t&&(t={},this.data.set(e,t)),t}has(e){return this.data.has(e)}delete(e){this.data.delete(e)}}let Jx=0;class ey{constructor(e,t){this.buffers=[e.bufferGPU,t],this.type=e.type,this.bufferType=e.bufferType,this.pbo=e.pbo,this.byteLength=e.byteLength,this.bytesPerElement=e.BYTES_PER_ELEMENT,this.version=e.version,this.isInteger=e.isInteger,this.activeBufferIndex=0,this.baseId=e.id}get id(){return`${this.baseId}|${this.activeBufferIndex}`}get bufferGPU(){return this.buffers[this.activeBufferIndex]}get transformBuffer(){return this.buffers[1^this.activeBufferIndex]}switchBuffers(){this.activeBufferIndex^=1}}class ty{constructor(e){this.backend=e}createAttribute(e,t){const s=this.backend,{gl:r}=s,i=e.array,n=e.usage||r.STATIC_DRAW,o=e.isInterleavedBufferAttribute?e.data:e,a=s.get(o);let u,l=a.bufferGPU;if(void 0===l&&(l=this._createBuffer(r,t,i,n),a.bufferGPU=l,a.bufferType=t,a.version=o.version),i instanceof Float32Array)u=r.FLOAT;else if(i instanceof Uint16Array)u=e.isFloat16BufferAttribute?r.HALF_FLOAT:r.UNSIGNED_SHORT;else if(i instanceof Int16Array)u=r.SHORT;else if(i instanceof Uint32Array)u=r.UNSIGNED_INT;else if(i instanceof Int32Array)u=r.INT;else if(i instanceof Int8Array)u=r.BYTE;else if(i instanceof Uint8Array)u=r.UNSIGNED_BYTE;else{if(!(i instanceof Uint8ClampedArray))throw new Error("THREE.WebGLBackend: Unsupported buffer data format: "+i);u=r.UNSIGNED_BYTE}let c={bufferGPU:l,bufferType:t,type:u,byteLength:i.byteLength,bytesPerElement:i.BYTES_PER_ELEMENT,version:e.version,pbo:e.pbo,isInteger:u===r.INT||u===r.UNSIGNED_INT||e.gpuType===Oe,id:Jx++};if(e.isStorageBufferAttribute||e.isStorageInstancedBufferAttribute){const e=this._createBuffer(r,t,i,n);c=new ey(c,e)}s.set(e,c)}updateAttribute(e){const t=this.backend,{gl:s}=t,r=e.array,i=e.isInterleavedBufferAttribute?e.data:e,n=t.get(i),o=n.bufferType,a=e.isInterleavedBufferAttribute?e.data.updateRanges:e.updateRanges;if(s.bindBuffer(o,n.bufferGPU),0===a.length)s.bufferSubData(o,0,r);else{for(let e=0,t=a.length;e<t;e++){const t=a[e];s.bufferSubData(o,t.start*r.BYTES_PER_ELEMENT,r,t.start,t.count)}i.clearUpdateRanges()}s.bindBuffer(o,null),n.version=i.version}destroyAttribute(e){const t=this.backend,{gl:s}=t;e.isInterleavedBufferAttribute&&t.delete(e.data);const r=t.get(e);s.deleteBuffer(r.bufferGPU),t.delete(e)}async getArrayBufferAsync(e){const t=this.backend,{gl:s}=t,r=e.isInterleavedBufferAttribute?e.data:e,{bufferGPU:i}=t.get(r),n=e.array,o=n.byteLength;s.bindBuffer(s.COPY_READ_BUFFER,i);const a=s.createBuffer();s.bindBuffer(s.COPY_WRITE_BUFFER,a),s.bufferData(s.COPY_WRITE_BUFFER,o,s.STREAM_READ),s.copyBufferSubData(s.COPY_READ_BUFFER,s.COPY_WRITE_BUFFER,0,0,o),await t.utils._clientWaitAsync();const u=new e.array.constructor(n.length);return s.getBufferSubData(s.COPY_WRITE_BUFFER,0,u),s.deleteBuffer(a),u.buffer}_createBuffer(e,t,s,r){const i=e.createBuffer();return e.bindBuffer(t,i),e.bufferData(t,s,r),e.bindBuffer(t,null),i}}let sy,ry,iy=!1;class ny{constructor(e){this.backend=e,this.gl=this.backend.gl,this.enabled={},this.currentFlipSided=null,this.currentCullFace=null,this.currentProgram=null,this.currentBlendingEnabled=!1,this.currentBlending=null,this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentPremultipledAlpha=null,this.currentPolygonOffsetFactor=null,this.currentPolygonOffsetUnits=null,this.currentColorMask=null,this.currentDepthFunc=null,this.currentDepthMask=null,this.currentStencilFunc=null,this.currentStencilRef=null,this.currentStencilFuncMask=null,this.currentStencilFail=null,this.currentStencilZFail=null,this.currentStencilZPass=null,this.currentStencilMask=null,this.currentLineWidth=null,this.currentBoundFramebuffers={},this.currentDrawbuffers=new WeakMap,this.maxTextures=this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS),this.currentTextureSlot=null,this.currentBoundTextures={},!1===iy&&(this._init(this.gl),iy=!0)}_init(e){sy={[De]:e.FUNC_ADD,[Ve]:e.FUNC_SUBTRACT,[Ge]:e.FUNC_REVERSE_SUBTRACT},ry={[ke]:e.ZERO,[ze]:e.ONE,[$e]:e.SRC_COLOR,[He]:e.SRC_ALPHA,[We]:e.SRC_ALPHA_SATURATE,[je]:e.DST_COLOR,[qe]:e.DST_ALPHA,[Xe]:e.ONE_MINUS_SRC_COLOR,[Ye]:e.ONE_MINUS_SRC_ALPHA,[Ke]:e.ONE_MINUS_DST_COLOR,[Qe]:e.ONE_MINUS_DST_ALPHA}}enable(e){const{enabled:t}=this;!0!==t[e]&&(this.gl.enable(e),t[e]=!0)}disable(e){const{enabled:t}=this;!1!==t[e]&&(this.gl.disable(e),t[e]=!1)}setFlipSided(e){if(this.currentFlipSided!==e){const{gl:t}=this;e?t.frontFace(t.CW):t.frontFace(t.CCW),this.currentFlipSided=e}}setCullFace(e){const{gl:t}=this;e!==Ze?(this.enable(t.CULL_FACE),e!==this.currentCullFace&&(e===Je?t.cullFace(t.BACK):e===et?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):this.disable(t.CULL_FACE),this.currentCullFace=e}setLineWidth(e){const{currentLineWidth:t,gl:s}=this;e!==t&&(s.lineWidth(e),this.currentLineWidth=e)}setBlending(e,t,s,r,i,n,o,a){const{gl:u}=this;if(e!==B){if(!1===this.currentBlendingEnabled&&(this.enable(u.BLEND),this.currentBlendingEnabled=!0),e===tt)i=i||t,n=n||s,o=o||r,t===this.currentBlendEquation&&i===this.currentBlendEquationAlpha||(u.blendEquationSeparate(sy[t],sy[i]),this.currentBlendEquation=t,this.currentBlendEquationAlpha=i),s===this.currentBlendSrc&&r===this.currentBlendDst&&n===this.currentBlendSrcAlpha&&o===this.currentBlendDstAlpha||(u.blendFuncSeparate(ry[s],ry[r],ry[n],ry[o]),this.currentBlendSrc=s,this.currentBlendDst=r,this.currentBlendSrcAlpha=n,this.currentBlendDstAlpha=o),this.currentBlending=e,this.currentPremultipledAlpha=!1;else if(e!==this.currentBlending||a!==this.currentPremultipledAlpha){if(this.currentBlendEquation===De&&this.currentBlendEquationAlpha===De||(u.blendEquation(u.FUNC_ADD),this.currentBlendEquation=De,this.currentBlendEquationAlpha=De),a)switch(e){case nt:u.blendFuncSeparate(u.ONE,u.ONE_MINUS_SRC_ALPHA,u.ONE,u.ONE_MINUS_SRC_ALPHA);break;case it:u.blendFunc(u.ONE,u.ONE);break;case rt:u.blendFuncSeparate(u.ZERO,u.ONE_MINUS_SRC_COLOR,u.ZERO,u.ONE);break;case st:u.blendFuncSeparate(u.ZERO,u.SRC_COLOR,u.ZERO,u.SRC_ALPHA)}else switch(e){case nt:u.blendFuncSeparate(u.SRC_ALPHA,u.ONE_MINUS_SRC_ALPHA,u.ONE,u.ONE_MINUS_SRC_ALPHA);break;case it:u.blendFunc(u.SRC_ALPHA,u.ONE);break;case rt:u.blendFuncSeparate(u.ZERO,u.ONE_MINUS_SRC_COLOR,u.ZERO,u.ONE);break;case st:u.blendFunc(u.ZERO,u.SRC_COLOR)}this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentBlending=e,this.currentPremultipledAlpha=a}}else!0===this.currentBlendingEnabled&&(this.disable(u.BLEND),this.currentBlendingEnabled=!1)}setColorMask(e){this.currentColorMask!==e&&(this.gl.colorMask(e,e,e,e),this.currentColorMask=e)}setDepthTest(e){const{gl:t}=this;e?this.enable(t.DEPTH_TEST):this.disable(t.DEPTH_TEST)}setDepthMask(e){this.currentDepthMask!==e&&(this.gl.depthMask(e),this.currentDepthMask=e)}setDepthFunc(e){if(this.currentDepthFunc!==e){const{gl:t}=this;switch(e){case pt:t.depthFunc(t.NEVER);break;case ht:t.depthFunc(t.ALWAYS);break;case dt:t.depthFunc(t.LESS);break;case ct:t.depthFunc(t.LEQUAL);break;case lt:t.depthFunc(t.EQUAL);break;case ut:t.depthFunc(t.GEQUAL);break;case at:t.depthFunc(t.GREATER);break;case ot:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.LEQUAL)}this.currentDepthFunc=e}}setStencilTest(e){const{gl:t}=this;e?this.enable(t.STENCIL_TEST):this.disable(t.STENCIL_TEST)}setStencilMask(e){this.currentStencilMask!==e&&(this.gl.stencilMask(e),this.currentStencilMask=e)}setStencilFunc(e,t,s){this.currentStencilFunc===e&&this.currentStencilRef===t&&this.currentStencilFuncMask===s||(this.gl.stencilFunc(e,t,s),this.currentStencilFunc=e,this.currentStencilRef=t,this.currentStencilFuncMask=s)}setStencilOp(e,t,s){this.currentStencilFail===e&&this.currentStencilZFail===t&&this.currentStencilZPass===s||(this.gl.stencilOp(e,t,s),this.currentStencilFail=e,this.currentStencilZFail=t,this.currentStencilZPass=s)}setMaterial(e,t){const{gl:s}=this;e.side===Me?this.disable(s.CULL_FACE):this.enable(s.CULL_FACE);let r=e.side===F;t&&(r=!r),this.setFlipSided(r),e.blending===nt&&!1===e.transparent?this.setBlending(B):this.setBlending(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),this.setDepthFunc(e.depthFunc),this.setDepthTest(e.depthTest),this.setDepthMask(e.depthWrite),this.setColorMask(e.colorWrite);const i=e.stencilWrite;this.setStencilTest(i),i&&(this.setStencilMask(e.stencilWriteMask),this.setStencilFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),this.setStencilOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),this.setPolygonOffset(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?this.enable(s.SAMPLE_ALPHA_TO_COVERAGE):this.disable(s.SAMPLE_ALPHA_TO_COVERAGE)}setPolygonOffset(e,t,s){const{gl:r}=this;e?(this.enable(r.POLYGON_OFFSET_FILL),this.currentPolygonOffsetFactor===t&&this.currentPolygonOffsetUnits===s||(r.polygonOffset(t,s),this.currentPolygonOffsetFactor=t,this.currentPolygonOffsetUnits=s)):this.disable(r.POLYGON_OFFSET_FILL)}useProgram(e){return this.currentProgram!==e&&(this.gl.useProgram(e),this.currentProgram=e,!0)}bindFramebuffer(e,t){const{gl:s,currentBoundFramebuffers:r}=this;return r[e]!==t&&(s.bindFramebuffer(e,t),r[e]=t,e===s.DRAW_FRAMEBUFFER&&(r[s.FRAMEBUFFER]=t),e===s.FRAMEBUFFER&&(r[s.DRAW_FRAMEBUFFER]=t),!0)}drawBuffers(e,t){const{gl:s}=this;let r=[],i=!1;if(null!==e.textures){r=this.currentDrawbuffers.get(t),void 0===r&&(r=[],this.currentDrawbuffers.set(t,r));const n=e.textures;if(r.length!==n.length||r[0]!==s.COLOR_ATTACHMENT0){for(let e=0,t=n.length;e<t;e++)r[e]=s.COLOR_ATTACHMENT0+e;r.length=n.length,i=!0}}else r[0]!==s.BACK&&(r[0]=s.BACK,i=!0);i&&s.drawBuffers(r)}activeTexture(e){const{gl:t,currentTextureSlot:s,maxTextures:r}=this;void 0===e&&(e=t.TEXTURE0+r-1),s!==e&&(t.activeTexture(e),this.currentTextureSlot=e)}bindTexture(e,t,s){const{gl:r,currentTextureSlot:i,currentBoundTextures:n,maxTextures:o}=this;void 0===s&&(s=null===i?r.TEXTURE0+o-1:i);let a=n[s];void 0===a&&(a={type:void 0,texture:void 0},n[s]=a),a.type===e&&a.texture===t||(i!==s&&(r.activeTexture(s),this.currentTextureSlot=s),r.bindTexture(e,t),a.type=e,a.texture=t)}unbindTexture(){const{gl:e,currentTextureSlot:t,currentBoundTextures:s}=this,r=s[t];void 0!==r&&void 0!==r.type&&(e.bindTexture(r.type,null),r.type=void 0,r.texture=void 0)}}class oy{constructor(e){this.backend=e,this.gl=this.backend.gl,this.extensions=e.extensions}convert(e,t=C){const{gl:s,extensions:r}=this;let i;if(e===ve)return s.UNSIGNED_BYTE;if(e===gt)return s.UNSIGNED_SHORT_4_4_4_4;if(e===mt)return s.UNSIGNED_SHORT_5_5_5_1;if(e===ft)return s.BYTE;if(e===Tt)return s.SHORT;if(e===xt)return s.UNSIGNED_SHORT;if(e===Oe)return s.INT;if(e===_e)return s.UNSIGNED_INT;if(e===y)return s.FLOAT;if(e===k)return s.HALF_FLOAT;if(e===yt)return s.ALPHA;if(e===s.RGB)return s.RGB;if(e===Ie)return s.RGBA;if(e===bt)return s.LUMINANCE;if(e===Nt)return s.LUMINANCE_ALPHA;if(e===be)return s.DEPTH_COMPONENT;if(e===ye)return s.DEPTH_STENCIL;if(e===Ue)return s.RED;if(e===_t)return s.RED_INTEGER;if(e===Le)return s.RG;if(e===vt)return s.RG_INTEGER;if(e===St)return s.RGBA_INTEGER;if(e===At||e===Rt||e===Ct||e===Et)if(t===p){if(i=r.get("WEBGL_compressed_texture_s3tc_srgb"),null===i)return null;if(e===At)return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(e===Rt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(e===Ct)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(e===Et)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(i=r.get("WEBGL_compressed_texture_s3tc"),null===i)return null;if(e===At)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===Rt)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===Ct)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===Et)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(e===wt||e===Mt||e===Ft||e===Bt){if(i=r.get("WEBGL_compressed_texture_pvrtc"),null===i)return null;if(e===wt)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===Mt)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===Ft)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===Bt)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(e===Ot)return i=r.get("WEBGL_compressed_texture_etc1"),null!==i?i.COMPRESSED_RGB_ETC1_WEBGL:null;if(e===Ut||e===Lt){if(i=r.get("WEBGL_compressed_texture_etc"),null===i)return null;if(e===Ut)return t===p?i.COMPRESSED_SRGB8_ETC2:i.COMPRESSED_RGB8_ETC2;if(e===Lt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:i.COMPRESSED_RGBA8_ETC2_EAC}if(e===It||e===Pt||e===Dt||e===Vt||e===Gt||e===kt||e===zt||e===$t||e===Ht||e===Wt||e===jt||e===qt||e===Xt||e===Yt){if(i=r.get("WEBGL_compressed_texture_astc"),null===i)return null;if(e===It)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:i.COMPRESSED_RGBA_ASTC_4x4_KHR;if(e===Pt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:i.COMPRESSED_RGBA_ASTC_5x4_KHR;if(e===Dt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:i.COMPRESSED_RGBA_ASTC_5x5_KHR;if(e===Vt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:i.COMPRESSED_RGBA_ASTC_6x5_KHR;if(e===Gt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:i.COMPRESSED_RGBA_ASTC_6x6_KHR;if(e===kt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:i.COMPRESSED_RGBA_ASTC_8x5_KHR;if(e===zt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:i.COMPRESSED_RGBA_ASTC_8x6_KHR;if(e===$t)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:i.COMPRESSED_RGBA_ASTC_8x8_KHR;if(e===Ht)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:i.COMPRESSED_RGBA_ASTC_10x5_KHR;if(e===Wt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:i.COMPRESSED_RGBA_ASTC_10x6_KHR;if(e===jt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:i.COMPRESSED_RGBA_ASTC_10x8_KHR;if(e===qt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:i.COMPRESSED_RGBA_ASTC_10x10_KHR;if(e===Xt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:i.COMPRESSED_RGBA_ASTC_12x10_KHR;if(e===Yt)return t===p?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:i.COMPRESSED_RGBA_ASTC_12x12_KHR}if(e===Kt){if(i=r.get("EXT_texture_compression_bptc"),null===i)return null;if(e===Kt)return t===p?i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:i.COMPRESSED_RGBA_BPTC_UNORM_EXT}if(e===Qt||e===Zt||e===Jt||e===es){if(i=r.get("EXT_texture_compression_rgtc"),null===i)return null;if(e===Kt)return i.COMPRESSED_RED_RGTC1_EXT;if(e===Zt)return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(e===Jt)return i.COMPRESSED_RED_GREEN_RGTC2_EXT;if(e===es)return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return e===Ne?s.UNSIGNED_INT_24_8:void 0!==s[e]?s[e]:null}_clientWaitAsync(){const{gl:e}=this,t=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),new Promise(((s,r)=>{!function i(){const n=e.clientWaitSync(t,e.SYNC_FLUSH_COMMANDS_BIT,0);if(n===e.WAIT_FAILED)return e.deleteSync(t),void r();n!==e.TIMEOUT_EXPIRED?(e.deleteSync(t),s()):requestAnimationFrame(i)}()}))}}let ay,uy,ly,cy=!1;class dy{constructor(e){this.backend=e,this.gl=e.gl,this.extensions=e.extensions,this.defaultTextures={},!1===cy&&(this._init(this.gl),cy=!0)}_init(e){ay={[ts]:e.REPEAT,[ss]:e.CLAMP_TO_EDGE,[rs]:e.MIRRORED_REPEAT},uy={[_]:e.NEAREST,[is]:e.NEAREST_MIPMAP_NEAREST,[ns]:e.NEAREST_MIPMAP_LINEAR,[L]:e.LINEAR,[os]:e.LINEAR_MIPMAP_NEAREST,[A]:e.LINEAR_MIPMAP_LINEAR},ly={[as]:e.NEVER,[us]:e.ALWAYS,[v]:e.LESS,[ls]:e.LEQUAL,[cs]:e.EQUAL,[ds]:e.GEQUAL,[hs]:e.GREATER,[ps]:e.NOTEQUAL}}filterFallback(e){const{gl:t}=this;return e===_||e===is||e===ns?t.NEAREST:t.LINEAR}getGLTextureType(e){const{gl:t}=this;let s;return s=!0===e.isCubeTexture?t.TEXTURE_CUBE_MAP:!0===e.isDataArrayTexture?t.TEXTURE_2D_ARRAY:t.TEXTURE_2D,s}getInternalFormat(e,t,s,r,i=!1){const{gl:n,extensions:o}=this;if(null!==e&&void 0!==n[e])return n[e];let a=t;return t===n.RED&&(s===n.FLOAT&&(a=n.R32F),s===n.HALF_FLOAT&&(a=n.R16F),s===n.UNSIGNED_BYTE&&(a=n.R8)),t===n.RED_INTEGER&&(s===n.UNSIGNED_BYTE&&(a=n.R8UI),s===n.UNSIGNED_SHORT&&(a=n.R16UI),s===n.UNSIGNED_INT&&(a=n.R32UI),s===n.BYTE&&(a=n.R8I),s===n.SHORT&&(a=n.R16I),s===n.INT&&(a=n.R32I)),t===n.RG&&(s===n.FLOAT&&(a=n.RG32F),s===n.HALF_FLOAT&&(a=n.RG16F),s===n.UNSIGNED_BYTE&&(a=n.RG8)),t===n.RGB&&(s===n.FLOAT&&(a=n.RGB32F),s===n.HALF_FLOAT&&(a=n.RGB16F),s===n.UNSIGNED_BYTE&&(a=n.RGB8),s===n.UNSIGNED_SHORT_5_6_5&&(a=n.RGB565),s===n.UNSIGNED_SHORT_5_5_5_1&&(a=n.RGB5_A1),s===n.UNSIGNED_SHORT_4_4_4_4&&(a=n.RGB4)),t===n.RGBA&&(s===n.FLOAT&&(a=n.RGBA32F),s===n.HALF_FLOAT&&(a=n.RGBA16F),s===n.UNSIGNED_BYTE&&(a=r===p&&!1===i?n.SRGB8_ALPHA8:n.RGBA8),s===n.UNSIGNED_SHORT_4_4_4_4&&(a=n.RGBA4),s===n.UNSIGNED_SHORT_5_5_5_1&&(a=n.RGB5_A1)),t===n.DEPTH_COMPONENT&&(s===n.UNSIGNED_INT&&(a=n.DEPTH24_STENCIL8),s===n.FLOAT&&(a=n.DEPTH_COMPONENT32F)),t===n.DEPTH_STENCIL&&s===n.UNSIGNED_INT_24_8&&(a=n.DEPTH24_STENCIL8),a!==n.R16F&&a!==n.R32F&&a!==n.RG16F&&a!==n.RG32F&&a!==n.RGBA16F&&a!==n.RGBA32F||o.get("EXT_color_buffer_float"),a}setTextureParameters(e,t){const{gl:s,extensions:r,backend:i}=this,{currentAnisotropy:n}=i.get(t);s.texParameteri(e,s.TEXTURE_WRAP_S,ay[t.wrapS]),s.texParameteri(e,s.TEXTURE_WRAP_T,ay[t.wrapT]),e!==s.TEXTURE_3D&&e!==s.TEXTURE_2D_ARRAY||s.texParameteri(e,s.TEXTURE_WRAP_R,ay[t.wrapR]),s.texParameteri(e,s.TEXTURE_MAG_FILTER,uy[t.magFilter]);const o=t.isVideoTexture||t.minFilter!==L?t.minFilter:A;if(s.texParameteri(e,s.TEXTURE_MIN_FILTER,uy[o]),t.compareFunction&&(s.texParameteri(e,s.TEXTURE_COMPARE_MODE,s.COMPARE_REF_TO_TEXTURE),s.texParameteri(e,s.TEXTURE_COMPARE_FUNC,ly[t.compareFunction])),!0===r.has("EXT_texture_filter_anisotropic")){if(t.magFilter===_)return;if(t.minFilter!==ns&&t.minFilter!==A)return;if(t.type===y&&!1===r.has("OES_texture_float_linear"))return;if(t.anisotropy>1||n!==t.anisotropy){const n=r.get("EXT_texture_filter_anisotropic");s.texParameterf(e,n.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(t.anisotropy,i.getMaxAnisotropy())),i.get(t).currentAnisotropy=t.anisotropy}}}createDefaultTexture(e){const{gl:t,backend:s,defaultTextures:r}=this,i=this.getGLTextureType(e);let n=r[i];void 0===n&&(n=t.createTexture(),s.state.bindTexture(i,n),t.texParameteri(i,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(i,t.TEXTURE_MAG_FILTER,t.NEAREST),r[i]=n),s.set(e,{textureGPU:n,glTextureType:i,isDefault:!0})}createTexture(e,t){const{gl:s,backend:r}=this,{levels:i,width:n,height:o,depth:a}=t,u=r.utils.convert(e.format,e.colorSpace),l=r.utils.convert(e.type),c=this.getInternalFormat(e.internalFormat,u,l,e.colorSpace,e.isVideoTexture),d=s.createTexture(),h=this.getGLTextureType(e);r.state.bindTexture(h,d),s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,e.flipY),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),s.pixelStorei(s.UNPACK_ALIGNMENT,e.unpackAlignment),s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL,s.NONE),this.setTextureParameters(h,e),e.isDataArrayTexture?s.texStorage3D(s.TEXTURE_2D_ARRAY,i,c,n,o,a):e.isVideoTexture||s.texStorage2D(h,i,c,n,o),r.set(e,{textureGPU:d,glTextureType:h,glFormat:u,glType:l,glInternalFormat:c})}copyBufferToTexture(e,t){const{gl:s,backend:r}=this,{textureGPU:i,glTextureType:n,glFormat:o,glType:a}=r.get(t),{width:u,height:l}=t.source.data;s.bindBuffer(s.PIXEL_UNPACK_BUFFER,e),r.state.bindTexture(n,i),s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,!1),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),s.texSubImage2D(n,0,0,0,u,l,o,a,0),s.bindBuffer(s.PIXEL_UNPACK_BUFFER,null),r.state.unbindTexture()}updateTexture(e,t){const{gl:s}=this,{width:r,height:i}=t,{textureGPU:n,glTextureType:o,glFormat:a,glType:u,glInternalFormat:l}=this.backend.get(e);if(e.isRenderTargetTexture||void 0===n)return;const c=e=>e.isDataTexture?e.image.data:e instanceof ImageBitmap||e instanceof OffscreenCanvas||e instanceof HTMLImageElement||e instanceof HTMLCanvasElement?e:e.data;if(this.backend.state.bindTexture(o,n),e.isCompressedTexture){const r=e.mipmaps;for(let i=0;i<r.length;i++){const n=r[i];if(e.isCompressedArrayTexture){const r=t.image;e.format!==s.RGBA?null!==a&&s.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY,i,0,0,0,n.width,n.height,r.depth,a,n.data,0,0):s.texSubImage3D(s.TEXTURE_2D_ARRAY,i,0,0,0,n.width,n.height,r.depth,a,u,n.data)}else null!==a&&s.compressedTexSubImage2D(s.TEXTURE_2D,i,0,0,n.width,n.height,a,n.data)}}else if(e.isCubeTexture){const e=t.images;for(let t=0;t<6;t++){const n=c(e[t]);s.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,0,0,r,i,a,u,n)}}else if(e.isDataArrayTexture){const e=t.image;s.texSubImage3D(s.TEXTURE_2D_ARRAY,0,0,0,0,e.width,e.height,e.depth,a,u,e.data)}else if(e.isVideoTexture)e.update(),s.texImage2D(o,0,l,a,u,t.image);else{const e=c(t.image);s.texSubImage2D(o,0,0,0,r,i,a,u,e)}}generateMipmaps(e){const{gl:t,backend:s}=this,{textureGPU:r,glTextureType:i}=s.get(e);s.state.bindTexture(i,r),t.generateMipmap(i)}deallocateRenderBuffers(e){const{gl:t,backend:s}=this;if(e){const r=s.get(e);if(r.renderBufferStorageSetup=void 0,r.framebuffer&&(t.deleteFramebuffer(r.framebuffer),r.framebuffer=void 0),r.depthRenderbuffer&&(t.deleteRenderbuffer(r.depthRenderbuffer),r.depthRenderbuffer=void 0),r.stencilRenderbuffer&&(t.deleteRenderbuffer(r.stencilRenderbuffer),r.stencilRenderbuffer=void 0),r.msaaFrameBuffer&&(t.deleteFramebuffer(r.msaaFrameBuffer),r.msaaFrameBuffer=void 0),r.msaaRenderbuffers){for(let e=0;e<r.msaaRenderbuffers.length;e++)t.deleteRenderbuffer(r.msaaRenderbuffers[e]);r.msaaRenderbuffers=void 0}}}destroyTexture(e){const{gl:t,backend:s}=this,{textureGPU:r,renderTarget:i}=s.get(e);this.deallocateRenderBuffers(i),t.deleteTexture(r),s.delete(e)}copyFramebufferToTexture(e,t){const{gl:s}=this,{state:r}=this.backend,{textureGPU:i}=this.backend.get(e),n=e.image.width,o=e.image.height;if(e.isDepthTexture){let e=s.DEPTH_BUFFER_BIT;t.stencil&&(e|=s.STENCIL_BUFFER_BIT);const a=s.createFramebuffer();r.bindFramebuffer(s.DRAW_FRAMEBUFFER,a),s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,i,0),s.blitFramebuffer(0,0,n,o,0,0,n,o,e,s.NEAREST),s.deleteFramebuffer(a)}else r.bindTexture(s.TEXTURE_2D,i),s.copyTexSubImage2D(s.TEXTURE_2D,0,0,0,0,0,n,o),r.unbindTexture();e.generateMipmaps&&this.generateMipmaps(e),this.backend._setFramebuffer(t)}setupRenderBufferStorage(e,t){const{gl:s}=this,r=t.renderTarget,{samples:i,depthTexture:n,depthBuffer:o,stencilBuffer:a,width:u,height:l}=r;if(s.bindRenderbuffer(s.RENDERBUFFER,e),o&&!a){let t=s.DEPTH_COMPONENT24;i>0?(n&&n.isDepthTexture&&n.type===s.FLOAT&&(t=s.DEPTH_COMPONENT32F),s.renderbufferStorageMultisample(s.RENDERBUFFER,i,t,u,l)):s.renderbufferStorage(s.RENDERBUFFER,t,u,l),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.RENDERBUFFER,e)}else o&&a&&(i>0?s.renderbufferStorageMultisample(s.RENDERBUFFER,i,s.DEPTH24_STENCIL8,u,l):s.renderbufferStorage(s.RENDERBUFFER,s.DEPTH_STENCIL,u,l),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.RENDERBUFFER,e))}async copyTextureToBuffer(e,t,s,r,i){const{backend:n,gl:o}=this,{textureGPU:a,glFormat:u,glType:l}=this.backend.get(e),c=o.createFramebuffer();o.bindFramebuffer(o.READ_FRAMEBUFFER,c),o.framebufferTexture2D(o.READ_FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,a,0);const d=this._getTypedArrayType(l),h=r*i,p=h*this._getBytesPerTexel(u),g=o.createBuffer();o.bindBuffer(o.PIXEL_PACK_BUFFER,g),o.bufferData(o.PIXEL_PACK_BUFFER,p,o.STREAM_READ),o.readPixels(t,s,r,i,u,l,0),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),await n.utils._clientWaitAsync();const m=new d(h);return o.bindBuffer(o.PIXEL_PACK_BUFFER,g),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,m),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),o.deleteFramebuffer(c),m}_getTypedArrayType(e){const{gl:t}=this;if(e===t.UNSIGNED_BYTE)return Uint8Array;if(e===t.UNSIGNED_SHORT_4_4_4_4)return Uint16Array;if(e===t.UNSIGNED_SHORT_5_5_5_1)return Uint16Array;if(e===t.UNSIGNED_SHORT_5_6_5)return Uint16Array;if(e===t.UNSIGNED_SHORT)return Uint16Array;if(e===t.UNSIGNED_INT)return Uint32Array;if(e===t.FLOAT)return Float32Array;throw new Error(`Unsupported WebGL type: ${e}`)}_getBytesPerTexel(e){const{gl:t}=this;return e===t.RGBA?4:e===t.RGB?3:e===t.ALPHA?1:void 0}}class hy{constructor(e){this.backend=e,this.gl=this.backend.gl,this.availableExtensions=this.gl.getSupportedExtensions(),this.extensions={}}get(e){let t=this.extensions[e];return void 0===t&&(t=this.gl.getExtension(e)),t}has(e){return this.availableExtensions.includes(e)}}class py{constructor(e){this.backend=e,this.maxAnisotropy=null}getMaxAnisotropy(){if(null!==this.maxAnisotropy)return this.maxAnisotropy;const e=this.backend.gl,t=this.backend.extensions;if(!0===t.has("EXT_texture_filter_anisotropic")){const s=t.get("EXT_texture_filter_anisotropic");this.maxAnisotropy=e.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else this.maxAnisotropy=0;return this.maxAnisotropy}}const gy={WEBGL_compressed_texture_astc:"texture-compression-astc",WEBGL_compressed_texture_etc:"texture-compression-etc2",WEBGL_compressed_texture_etc1:"texture-compression-etc1",WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBKIT_WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBGL_compressed_texture_s3tc:"texture-compression-bc",EXT_texture_compression_bptc:"texture-compression-bptc"};class my extends Zx{constructor(e={}){super(e),this.isWebGLBackend=!0}init(e){super.init(e);const t=this.parameters,s=void 0!==t.context?t.context:e.domElement.getContext("webgl2");this.gl=s,this.extensions=new hy(this),this.capabilities=new py(this),this.attributeUtils=new ty(this),this.textureUtils=new dy(this),this.state=new ny(this),this.utils=new oy(this),this.vaoCache={},this.transformFeedbackCache={},this.discard=!1,this.extensions.get("EXT_color_buffer_float"),this.parallel=this.extensions.get("KHR_parallel_shader_compile"),this._currentContext=null}get coordinateSystem(){return gs}async getArrayBufferAsync(e){return await this.attributeUtils.getArrayBufferAsync(e)}getContext(){return this.gl}beginRender(e){const{gl:t}=this,s=this.get(e);if(s.previousContext=this._currentContext,this._currentContext=e,this._setFramebuffer(e),this.clear(e.clearColor,e.clearDepth,e.clearStencil,e,!1),e.viewport?this.updateViewport(e):t.viewport(0,0,t.drawingBufferWidth,t.drawingBufferHeight),e.scissor){const{x:s,y:r,width:i,height:n}=e.scissorValue;t.scissor(s,r,i,n)}const r=e.occlusionQueryCount;r>0&&(s.currentOcclusionQueries=s.occlusionQueries,s.currentOcclusionQueryObjects=s.occlusionQueryObjects,s.lastOcclusionObject=null,s.occlusionQueries=new Array(r),s.occlusionQueryObjects=new Array(r),s.occlusionQueryIndex=0)}finishRender(e){const{gl:t,state:s}=this,r=this.get(e).previousContext,i=e.textures;if(null!==i)for(let e=0;e<i.length;e++){const t=i[e];t.generateMipmaps&&this.generateMipmaps(t)}if(this._currentContext=r,null!==e.textures&&e.renderTarget){const r=this.get(e.renderTarget),{samples:i}=e.renderTarget,n=r.framebuffer,o=t.COLOR_BUFFER_BIT;if(i>0){const i=r.msaaFrameBuffer,a=e.textures;s.bindFramebuffer(t.READ_FRAMEBUFFER,i),s.bindFramebuffer(t.DRAW_FRAMEBUFFER,n);for(let s=0;s<a.length;s++)t.blitFramebuffer(0,0,e.width,e.height,0,0,e.width,e.height,o,t.NEAREST),t.invalidateFramebuffer(t.READ_FRAMEBUFFER,r.invalidationArray)}}if(null!==r)if(this._setFramebuffer(r),r.viewport)this.updateViewport(r);else{const e=this.gl;e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight)}const n=e.occlusionQueryCount;if(n>0){if(n>this.get(e).occlusionQueryIndex){const{gl:e}=this;e.endQuery(e.ANY_SAMPLES_PASSED)}this.resolveOccludedAsync(e)}}resolveOccludedAsync(e){const t=this.get(e),{currentOcclusionQueries:s,currentOcclusionQueryObjects:r}=t;if(s&&r){const e=new WeakSet,{gl:i}=this;t.currentOcclusionQueryObjects=null,t.currentOcclusionQueries=null;const n=()=>{let o=0;for(let t=0;t<s.length;t++){const n=s[t];null!==n&&(i.getQueryParameter(n,i.QUERY_RESULT_AVAILABLE)&&(i.getQueryParameter(n,i.QUERY_RESULT)>0&&e.add(r[t]),s[t]=null,i.deleteQuery(n),o++))}o<s.length?requestAnimationFrame(n):t.occluded=e};n()}}isOccluded(e,t){const s=this.get(e);return s.occluded&&s.occluded.has(t)}updateViewport(e){const t=this.gl,{x:s,y:r,width:i,height:n}=e.viewportValue;t.viewport(s,r,i,n)}setScissorTest(e){const t=this.gl;e?t.enable(t.SCISSOR_TEST):t.disable(t.SCISSOR_TEST)}clear(e,t,s,r=null,i=!0){const{gl:n}=this;null===r&&(r={textures:null,clearColorValue:this.getClearColor()});let o=0;if(e&&(o|=n.COLOR_BUFFER_BIT),t&&(o|=n.DEPTH_BUFFER_BIT),s&&(o|=n.STENCIL_BUFFER_BIT),0!==o){const a=r.clearColorValue||this.getClearColor();if(t&&this.state.setDepthMask(!0),null===r.textures)n.clearColor(a.r,a.g,a.b,a.a),n.clear(o);else{if(i&&this._setFramebuffer(r),e)for(let e=0;e<r.textures.length;e++)n.clearBufferfv(n.COLOR,e,[a.r,a.g,a.b,a.a]);t&&s?n.clearBufferfi(n.DEPTH_STENCIL,0,1,0):t?n.clearBufferfv(n.DEPTH,0,[1]):s&&n.clearBufferiv(n.STENCIL,0,[0])}}}beginCompute(){const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null)}compute(e,t,s,r){const i=this.gl;this.discard||(i.enable(i.RASTERIZER_DISCARD),this.discard=!0);const{programGPU:n,transformBuffers:o,attributes:a}=this.get(r),u=this._getVaoKey(null,a),l=this.vaoCache[u];void 0===l?this._createVao(null,a):i.bindVertexArray(l),i.useProgram(n),this._bindUniforms(s);const c=this._getTransformFeedback(o);i.bindTransformFeedback(i.TRANSFORM_FEEDBACK,c),i.beginTransformFeedback(i.POINTS),a[0].isStorageInstancedBufferAttribute?i.drawArraysInstanced(i.POINTS,0,1,t.count):i.drawArrays(i.POINTS,0,t.count),i.endTransformFeedback(),i.bindTransformFeedback(i.TRANSFORM_FEEDBACK,null);for(let e=0;e<o.length;e++){const t=o[e];t.pbo&&this.textureUtils.copyBufferToTexture(t.transformBuffer,t.pbo),t.switchBuffers()}}finishCompute(){const e=this.gl;this.discard=!1,e.disable(e.RASTERIZER_DISCARD)}draw(e,t){const{pipeline:s,material:r,context:i}=e,{programGPU:n}=this.get(s),{gl:o,state:a}=this,u=this.get(i);this._bindUniforms(e.getBindings()),a.setMaterial(r),o.useProgram(n);let l=e.staticVao;if(void 0===l){const t=this._getVaoKey(e.getIndex(),e.getAttributes());if(l=this.vaoCache[t],void 0===l){let t;({vaoGPU:l,staticVao:t}=this._createVao(e.getIndex(),e.getAttributes())),t&&(e.staticVao=l)}}o.bindVertexArray(l);const c=e.getIndex(),d=e.object,h=e.geometry,p=h.drawRange,g=p.start,m=u.lastOcclusionObject;if(m!==d&&void 0!==m){if(null!==m&&!0===m.occlusionTest&&(o.endQuery(o.ANY_SAMPLES_PASSED),u.occlusionQueryIndex++),!0===d.occlusionTest){const e=o.createQuery();o.beginQuery(o.ANY_SAMPLES_PASSED,e),u.occlusionQueries[u.occlusionQueryIndex]=e,u.occlusionQueryObjects[u.occlusionQueryIndex]=d}u.lastOcclusionObject=d}let f;d.isPoints?f=o.POINTS:d.isLineSegments?f=o.LINES:d.isLine?f=o.LINE_STRIP:d.isLineLoop?f=o.LINE_LOOP:!0===r.wireframe?(a.setLineWidth(r.wireframeLinewidth*this.renderer.getPixelRatio()),f=o.LINES):f=o.TRIANGLES;const T=this.getInstanceCount(e);if(null!==c){const e=this.get(c),s=p.count!==1/0?p.count:c.count;T>1?o.drawElementsInstanced(f,c.count,e.type,g,T):o.drawElements(f,c.count,e.type,g),t.update(d,s,1)}else{const e=h.attributes.position,s=p.count!==1/0?p.count:e.count;T>1?o.drawArraysInstanced(f,0,s,T):o.drawArrays(f,0,s),t.update(d,s,1)}o.bindVertexArray(null)}needsRenderUpdate(){return!1}getRenderCacheKey(e){return e.id}createDefaultTexture(e){this.textureUtils.createDefaultTexture(e)}createTexture(e,t){this.textureUtils.createTexture(e,t)}updateTexture(e,t){this.textureUtils.updateTexture(e,t)}generateMipmaps(e){this.textureUtils.generateMipmaps(e)}destroyTexture(e){this.textureUtils.destroyTexture(e)}copyTextureToBuffer(e,t,s,r,i){return this.textureUtils.copyTextureToBuffer(e,t,s,r,i)}createSampler(){}destroySampler(){}createNodeBuilder(e,t,s=null){return new Xx(e,t,s)}createProgram(e){const t=this.gl,{stage:s,code:r}=e,i="fragment"===s?t.createShader(t.FRAGMENT_SHADER):t.createShader(t.VERTEX_SHADER);t.shaderSource(i,r),t.compileShader(i),this.set(e,{shaderGPU:i})}destroyProgram(){}createRenderPipeline(e,t){const s=this.gl,r=e.pipeline,{fragmentProgram:i,vertexProgram:n}=r,o=s.createProgram(),a=this.get(i).shaderGPU,u=this.get(n).shaderGPU;if(s.attachShader(o,a),s.attachShader(o,u),s.linkProgram(o),this.set(r,{programGPU:o,fragmentShader:a,vertexShader:u}),null!==t&&this.parallel){const i=new Promise((t=>{const i=this.parallel,n=()=>{s.getProgramParameter(o,i.COMPLETION_STATUS_KHR)?(this._completeCompile(e,r),t()):requestAnimationFrame(n)};n()}));t.push(i)}else this._completeCompile(e,r)}_completeCompile(e,t){const s=this.gl,r=this.get(t),{programGPU:i,fragmentShader:n,vertexShader:o}=r;s.getProgramParameter(i,s.LINK_STATUS),s.useProgram(i),this._setupBindings(e.getBindings(),i),this.set(t,{programGPU:i})}createComputePipeline(e,t){const s=this.gl,r={stage:"fragment",code:"#version 300 es\nprecision highp float;\nvoid main() {}"};this.createProgram(r);const{computeProgram:i}=e,n=s.createProgram(),o=this.get(r).shaderGPU,a=this.get(i).shaderGPU,u=i.transforms,l=[],c=[];for(let e=0;e<u.length;e++){const t=u[e];l.push(t.varyingName),c.push(t.attributeNode)}s.attachShader(n,o),s.attachShader(n,a),s.transformFeedbackVaryings(n,l,s.SEPARATE_ATTRIBS),s.linkProgram(n),s.getProgramParameter(n,s.LINK_STATUS),s.useProgram(n),this.createBindings(t),this._setupBindings(t,n);const d=i.attributes,h=[],p=[];for(let e=0;e<d.length;e++){const t=d[e].node.attribute;h.push(t),this.has(t)||this.attributeUtils.createAttribute(t,s.ARRAY_BUFFER)}for(let e=0;e<c.length;e++){const t=c[e].attribute;this.has(t)||this.attributeUtils.createAttribute(t,s.ARRAY_BUFFER);const r=this.get(t);p.push(r)}this.set(e,{programGPU:n,transformBuffers:p,attributes:h})}createBindings(e){this.updateBindings(e)}updateBindings(e){const{gl:t}=this;let s=0,r=0;for(const i of e)if(i.isUniformsGroup||i.isUniformBuffer){const e=t.createBuffer(),r=i.buffer;t.bindBuffer(t.UNIFORM_BUFFER,e),t.bufferData(t.UNIFORM_BUFFER,r,t.DYNAMIC_DRAW),t.bindBufferBase(t.UNIFORM_BUFFER,s,e),this.set(i,{index:s++,bufferGPU:e})}else if(i.isSampledTexture){const{textureGPU:e,glTextureType:t}=this.get(i.texture);this.set(i,{index:r++,textureGPU:e,glTextureType:t})}}updateBinding(e){const t=this.gl;if(e.isUniformsGroup||e.isUniformBuffer){const s=this.get(e).bufferGPU,r=e.buffer;t.bindBuffer(t.UNIFORM_BUFFER,s),t.bufferData(t.UNIFORM_BUFFER,r,t.DYNAMIC_DRAW)}}createIndexAttribute(e){const t=this.gl;this.attributeUtils.createAttribute(e,t.ELEMENT_ARRAY_BUFFER)}createAttribute(e){if(this.has(e))return;const t=this.gl;this.attributeUtils.createAttribute(e,t.ARRAY_BUFFER)}createStorageAttribute(e){}updateAttribute(e){this.attributeUtils.updateAttribute(e)}destroyAttribute(e){this.attributeUtils.destroyAttribute(e)}updateSize(){}async hasFeatureAsync(e){return this.hasFeature(e)}hasFeature(e){const t=Object.keys(gy).filter((t=>gy[t]===e)),s=this.extensions;for(let e=0;e<t.length;e++)if(s.has(t[e]))return!0;return!1}getMaxAnisotropy(){return this.capabilities.getMaxAnisotropy()}copyFramebufferToTexture(e,t){this.textureUtils.copyFramebufferToTexture(e,t)}_setFramebuffer(e){const{gl:t,state:s}=this;let r=null;if(null!==e.textures){const i=e.renderTarget,n=this.get(i),{samples:o,depthBuffer:a,stencilBuffer:u}=i,l=this.renderer._activeCubeFace,c=!0===i.isWebGLCubeRenderTarget;let d,h=n.msaaFrameBuffer,p=n.depthRenderbuffer;if(c?(void 0===n.cubeFramebuffers&&(n.cubeFramebuffers=[]),d=n.cubeFramebuffers[l]):d=n.framebuffer,void 0===d){d=t.createFramebuffer(),s.bindFramebuffer(t.FRAMEBUFFER,d);const r=e.textures;if(c){n.cubeFramebuffers[l]=d;const{textureGPU:e}=this.get(r[0]);t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+l,e,0)}else{for(let s=0;s<r.length;s++){const i=r[s],n=this.get(i);n.renderTarget=e.renderTarget;const o=t.COLOR_ATTACHMENT0+s;t.framebufferTexture2D(t.FRAMEBUFFER,o,t.TEXTURE_2D,n.textureGPU,0)}n.framebuffer=d,s.drawBuffers(e,d)}if(null!==e.depthTexture){const s=this.get(e.depthTexture),r=u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;t.framebufferTexture2D(t.FRAMEBUFFER,r,t.TEXTURE_2D,s.textureGPU,0)}}if(o>0){if(void 0===h){const r=[];h=t.createFramebuffer(),s.bindFramebuffer(t.FRAMEBUFFER,h);const i=[],l=e.textures;for(let s=0;s<l.length;s++){if(i[s]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,i[s]),r.push(t.COLOR_ATTACHMENT0+s),a){const e=u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;r.push(e)}const n=e.textures[s],l=this.get(n);t.renderbufferStorageMultisample(t.RENDERBUFFER,o,l.glInternalFormat,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+s,t.RENDERBUFFER,i[s])}if(n.msaaFrameBuffer=h,n.msaaRenderbuffers=i,void 0===p){p=t.createRenderbuffer(),this.textureUtils.setupRenderBufferStorage(p,e),n.depthRenderbuffer=p;const s=u?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;r.push(s)}n.invalidationArray=r}r=n.msaaFrameBuffer}else r=d}s.bindFramebuffer(t.FRAMEBUFFER,r)}_getVaoKey(e,t){let s=[];if(null!==e){s+=":"+this.get(e).id}for(let e=0;e<t.length;e++){s+=":"+this.get(t[e]).id}return s}_createVao(e,t){const{gl:s}=this,r=s.createVertexArray();let i="",n=!0;if(s.bindVertexArray(r),null!==e){const t=this.get(e);s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,t.bufferGPU),i+=":"+t.id}for(let e=0;e<t.length;e++){const r=t[e],o=this.get(r);let a,u;i+=":"+o.id,s.bindBuffer(s.ARRAY_BUFFER,o.bufferGPU),s.enableVertexAttribArray(e),(r.isStorageBufferAttribute||r.isStorageInstancedBufferAttribute)&&(n=!1),!0===r.isInterleavedBufferAttribute?(a=r.data.stride*o.bytesPerElement,u=r.offset*o.bytesPerElement):(a=0,u=0),o.isInteger?s.vertexAttribIPointer(e,r.itemSize,o.type,a,u):s.vertexAttribPointer(e,r.itemSize,o.type,r.normalized,a,u),r.isInstancedBufferAttribute&&!r.isInterleavedBufferAttribute?s.vertexAttribDivisor(e,r.meshPerAttribute):r.isInterleavedBufferAttribute&&r.data.isInstancedInterleavedBuffer&&s.vertexAttribDivisor(e,r.data.meshPerAttribute)}return s.bindBuffer(s.ARRAY_BUFFER,null),this.vaoCache[i]=r,{vaoGPU:r,staticVao:n}}_getTransformFeedback(e){let t="";for(let s=0;s<e.length;s++)t+=":"+e[s].id;let s=this.transformFeedbackCache[t];if(void 0!==s)return s;const r=this.gl;s=r.createTransformFeedback(),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,s);for(let t=0;t<e.length;t++){const s=e[t];r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER,t,s.transformBuffer)}return r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,null),this.transformFeedbackCache[t]=s,s}_setupBindings(e,t){const s=this.gl;for(const r of e){const e=this.get(r).index;if(r.isUniformsGroup||r.isUniformBuffer){const i=s.getUniformBlockIndex(t,r.name);s.uniformBlockBinding(t,i,e)}else if(r.isSampledTexture){const i=s.getUniformLocation(t,r.name);s.uniform1i(i,e)}}}_bindUniforms(e){const{gl:t,state:s}=this;for(const r of e){const e=this.get(r),i=e.index;r.isUniformsGroup||r.isUniformBuffer?t.bindBufferBase(t.UNIFORM_BUFFER,i,e.bufferGPU):r.isSampledTexture&&s.bindTexture(e.glTextureType,e.textureGPU,t.TEXTURE0+i)}}}const fy="point-list",Ty="line-list",xy="line-strip",yy="triangle-list",by="triangle-strip",Ny="never",_y="less",vy="equal",Sy="less-equal",Ay="greater",Ry="not-equal",Cy="greater-equal",Ey="always",wy="store",My="load",Fy="clear",By="ccw",Oy="none",Uy="front",Ly="back",Iy="uint16",Py="uint32",Dy={R8Unorm:"r8unorm",R8Snorm:"r8snorm",R8Uint:"r8uint",R8Sint:"r8sint",R16Uint:"r16uint",R16Sint:"r16sint",R16Float:"r16float",RG8Unorm:"rg8unorm",RG8Snorm:"rg8snorm",RG8Uint:"rg8uint",RG8Sint:"rg8sint",R32Uint:"r32uint",R32Sint:"r32sint",R32Float:"r32float",RG16Uint:"rg16uint",RG16Sint:"rg16sint",RG16Float:"rg16float",RGBA8Unorm:"rgba8unorm",RGBA8UnormSRGB:"rgba8unorm-srgb",RGBA8Snorm:"rgba8snorm",RGBA8Uint:"rgba8uint",RGBA8Sint:"rgba8sint",BGRA8Unorm:"bgra8unorm",BGRA8UnormSRGB:"bgra8unorm-srgb",RGB9E5UFloat:"rgb9e5ufloat",RGB10A2Unorm:"rgb10a2unorm",RG11B10uFloat:"rgb10a2unorm",RG32Uint:"rg32uint",RG32Sint:"rg32sint",RG32Float:"rg32float",RGBA16Uint:"rgba16uint",RGBA16Sint:"rgba16sint",RGBA16Float:"rgba16float",RGBA32Uint:"rgba32uint",RGBA32Sint:"rgba32sint",RGBA32Float:"rgba32float",Stencil8:"stencil8",Depth16Unorm:"depth16unorm",Depth24Plus:"depth24plus",Depth24PlusStencil8:"depth24plus-stencil8",Depth32Float:"depth32float",Depth32FloatStencil8:"depth32float-stencil8",BC1RGBAUnorm:"bc1-rgba-unorm",BC1RGBAUnormSRGB:"bc1-rgba-unorm-srgb",BC2RGBAUnorm:"bc2-rgba-unorm",BC2RGBAUnormSRGB:"bc2-rgba-unorm-srgb",BC3RGBAUnorm:"bc3-rgba-unorm",BC3RGBAUnormSRGB:"bc3-rgba-unorm-srgb",BC4RUnorm:"bc4-r-unorm",BC4RSnorm:"bc4-r-snorm",BC5RGUnorm:"bc5-rg-unorm",BC5RGSnorm:"bc5-rg-snorm",BC6HRGBUFloat:"bc6h-rgb-ufloat",BC6HRGBFloat:"bc6h-rgb-float",BC7RGBAUnorm:"bc7-rgba-unorm",BC7RGBAUnormSRGB:"bc7-rgba-srgb",ETC2RGB8Unorm:"etc2-rgb8unorm",ETC2RGB8UnormSRGB:"etc2-rgb8unorm-srgb",ETC2RGB8A1Unorm:"etc2-rgb8a1unorm",ETC2RGB8A1UnormSRGB:"etc2-rgb8a1unorm-srgb",ETC2RGBA8Unorm:"etc2-rgba8unorm",ETC2RGBA8UnormSRGB:"etc2-rgba8unorm-srgb",EACR11Unorm:"eac-r11unorm",EACR11Snorm:"eac-r11snorm",EACRG11Unorm:"eac-rg11unorm",EACRG11Snorm:"eac-rg11snorm",ASTC4x4Unorm:"astc-4x4-unorm",ASTC4x4UnormSRGB:"astc-4x4-unorm-srgb",ASTC5x4Unorm:"astc-5x4-unorm",ASTC5x4UnormSRGB:"astc-5x4-unorm-srgb",ASTC5x5Unorm:"astc-5x5-unorm",ASTC5x5UnormSRGB:"astc-5x5-unorm-srgb",ASTC6x5Unorm:"astc-6x5-unorm",ASTC6x5UnormSRGB:"astc-6x5-unorm-srgb",ASTC6x6Unorm:"astc-6x6-unorm",ASTC6x6UnormSRGB:"astc-6x6-unorm-srgb",ASTC8x5Unorm:"astc-8x5-unorm",ASTC8x5UnormSRGB:"astc-8x5-unorm-srgb",ASTC8x6Unorm:"astc-8x6-unorm",ASTC8x6UnormSRGB:"astc-8x6-unorm-srgb",ASTC8x8Unorm:"astc-8x8-unorm",ASTC8x8UnormSRGB:"astc-8x8-unorm-srgb",ASTC10x5Unorm:"astc-10x5-unorm",ASTC10x5UnormSRGB:"astc-10x5-unorm-srgb",ASTC10x6Unorm:"astc-10x6-unorm",ASTC10x6UnormSRGB:"astc-10x6-unorm-srgb",ASTC10x8Unorm:"astc-10x8-unorm",ASTC10x8UnormSRGB:"astc-10x8-unorm-srgb",ASTC10x10Unorm:"astc-10x10-unorm",ASTC10x10UnormSRGB:"astc-10x10-unorm-srgb",ASTC12x10Unorm:"astc-12x10-unorm",ASTC12x10UnormSRGB:"astc-12x10-unorm-srgb",ASTC12x12Unorm:"astc-12x12-unorm",ASTC12x12UnormSRGB:"astc-12x12-unorm-srgb"},Vy="clamp-to-edge",Gy="repeat",ky="mirror-repeat",zy="linear",$y="nearest",Hy={Zero:"zero",One:"one",Src:"src",OneMinusSrc:"one-minus-src",SrcAlpha:"src-alpha",OneMinusSrcAlpha:"one-minus-src-alpha",Dst:"dst",OneMinusDstColor:"one-minus-dst",DstAlpha:"dst-alpha",OneMinusDstAlpha:"one-minus-dst-alpha",SrcAlphaSaturated:"src-alpha-saturated",Constant:"constant",OneMinusConstant:"one-minus-constant"},Wy="add",jy="subtract",qy="reverse-subtract",Xy="min",Yy="max",Ky=0,Qy=15,Zy="keep",Jy="zero",eb="replace",tb="invert",sb="increment-clamp",rb="decrement-clamp",ib="increment-wrap",nb="decrement-wrap",ob="storage",ab="unfilterable-float",ub="depth",lb="2d",cb="3d",db="2d",hb="2d-array",pb="cube",gb="all",mb="vertex",fb="instance",Tb={DepthClipControl:"depth-clip-control",Depth32FloatStencil8:"depth32float-stencil8",TextureCompressionBC:"texture-compression-bc",TextureCompressionETC2:"texture-compression-etc2",TextureCompressionASTC:"texture-compression-astc",TimestampQuery:"timestamp-query",IndirectFirstInstance:"indirect-first-instance",ShaderF16:"shader-f16",RG11B10UFloat:"rg11b10ufloat-renderable",BGRA8UNormStorage:"bgra8unorm-storage",Float32Filterable:"float32-filterable"};class xb extends Bx{constructor(e,t){super(e),this.texture=t,this.version=t?t.version:0,this.isSampler=!0}}class yb extends xb{constructor(e,t){super(e,t?t.value:null),this.textureNode=t}}class bb extends Ox{constructor(e,t){super(e,t?t.array:null),this.attribute=t,this.isStorageBuffer=!0}}let Nb=0;class _b extends bb{constructor(e){super("StorageBuffer_"+Nb++,e?e.value:null),this.nodeUniform=e}get buffer(){return this.nodeUniform.value}}class vb{constructor(e){this.device=e;this.mipmapSampler=e.createSampler({minFilter:zy}),this.flipYSampler=e.createSampler({minFilter:$y}),this.transferPipelines={},this.flipYPipelines={},this.mipmapVertexShaderModule=e.createShaderModule({label:"mipmapVertex",code:"\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n"}),this.mipmapFragmentShaderModule=e.createShaderModule({label:"mipmapFragment",code:"\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n"}),this.flipYFragmentShaderModule=e.createShaderModule({label:"flipYFragment",code:"\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n"})}getTransferPipeline(e){let t=this.transferPipelines[e];return void 0===t&&(t=this.device.createRenderPipeline({vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.mipmapFragmentShaderModule,entryPoint:"main",targets:[{format:e}]},primitive:{topology:by,stripIndexFormat:Py},layout:"auto"}),this.transferPipelines[e]=t),t}getFlipYPipeline(e){let t=this.flipYPipelines[e];return void 0===t&&(t=this.device.createRenderPipeline({vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.flipYFragmentShaderModule,entryPoint:"main",targets:[{format:e}]},primitive:{topology:by,stripIndexFormat:Py},layout:"auto"}),this.flipYPipelines[e]=t),t}flipY(e,t,s=0){const r=t.format,{width:i,height:n}=t.size,o=this.getTransferPipeline(r),a=this.getFlipYPipeline(r),u=this.device.createTexture({size:{width:i,height:n,depthOrArrayLayers:1},format:r,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),l=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:db,baseArrayLayer:s}),c=u.createView({baseMipLevel:0,mipLevelCount:1,dimension:db,baseArrayLayer:0}),d=this.device.createCommandEncoder({}),h=(e,t,s)=>{const r=e.getBindGroupLayout(0),i=this.device.createBindGroup({layout:r,entries:[{binding:0,resource:this.flipYSampler},{binding:1,resource:t}]}),n=d.beginRenderPass({colorAttachments:[{view:s,loadOp:Fy,storeOp:wy,clearValue:[0,0,0,0]}]});n.setPipeline(e),n.setBindGroup(0,i),n.draw(4,1,0,0),n.end()};h(o,l,c),h(a,c,l),this.device.queue.submit([d.finish()]),u.destroy()}generateMipmaps(e,t,s=0){const r=this.getTransferPipeline(t.format),i=this.device.createCommandEncoder({}),n=r.getBindGroupLayout(0);let o=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:db,baseArrayLayer:s});for(let a=1;a<t.mipLevelCount;a++){const t=this.device.createBindGroup({layout:n,entries:[{binding:0,resource:this.mipmapSampler},{binding:1,resource:o}]}),u=e.createView({baseMipLevel:a,mipLevelCount:1,dimension:db,baseArrayLayer:s}),l=i.beginRenderPass({colorAttachments:[{view:u,loadOp:Fy,storeOp:wy,clearValue:[0,0,0,0]}]});l.setPipeline(r),l.setBindGroup(0,t),l.draw(4,1,0,0),l.end(),o=u}this.device.queue.submit([i.finish()])}}const Sb={[as]:"never",[v]:"less",[cs]:"equal",[ls]:"less-equal",[hs]:"greater",[ds]:"greater-equal",[us]:"always",[ps]:"not-equal"},Ab=[0,1,3,2,4,5];class Rb{constructor(e){this.backend=e,this._passUtils=null,this.defaultTexture=null,this.defaultCubeTexture=null,this.colorBuffer=null,this.depthTexture=new N,this.depthTexture.name="depthBuffer"}createSampler(e){const t=this.backend,s=t.device,r=t.get(e),i={addressModeU:this._convertAddressMode(e.wrapS),addressModeV:this._convertAddressMode(e.wrapT),addressModeW:this._convertAddressMode(e.wrapR),magFilter:this._convertFilterMode(e.magFilter),minFilter:this._convertFilterMode(e.minFilter),mipmapFilter:this._convertFilterMode(e.minFilter),maxAnisotropy:e.anisotropy};e.isDepthTexture&&null!==e.compareFunction&&(i.compare=Sb[e.compareFunction]),r.sampler=s.createSampler(i)}createDefaultTexture(e){let t;t=e.isCubeTexture?this._getDefaultCubeTextureGPU():this._getDefaultTextureGPU(),this.backend.get(e).texture=t}createTexture(e,t={}){const s=this.backend,r=s.get(e);if(r.initialized)throw new Error("WebGPUTextureUtils: Texture already initialized.");void 0===t.needsMipmaps&&(t.needsMipmaps=!1),void 0===t.levels&&(t.levels=1),void 0===t.depth&&(t.depth=1);const{width:i,height:n,depth:o,levels:a}=t,u=this._getDimension(e),l=e.internalFormat||Cb(e,s.device);let c=void 0!==t.sampleCount?t.sampleCount:1;c>1&&(c=Math.pow(2,Math.floor(Math.log2(c))),2===c&&(c=4));const d=e.isRenderTargetTexture?1:c;let h=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC;!0===e.isStorageTexture&&(h|=GPUTextureUsage.STORAGE_BINDING),!0!==e.isCompressedTexture&&(h|=GPUTextureUsage.RENDER_ATTACHMENT);const p={label:e.name,size:{width:i,height:n,depthOrArrayLayers:o},mipLevelCount:a,sampleCount:d,dimension:u,format:l,usage:h};if(e.isVideoTexture){const t=e.source.data,s=new VideoFrame(t);p.size.width=s.displayWidth,p.size.height=s.displayHeight,s.close(),r.externalTexture=t}else{if(void 0===l)return this.createDefaultTexture(e);r.texture=s.device.createTexture(p)}if(e.isRenderTargetTexture&&c>1){const e=Object.assign({},p);e.label=e.label+"-msaa",e.sampleCount=c,r.msaaTexture=s.device.createTexture(e)}r.initialized=!0,r.textureDescriptorGPU=p}destroyTexture(e){const t=this.backend,s=t.get(e);s.texture.destroy(),void 0!==s.msaaTexture&&s.msaaTexture.destroy(),t.delete(e)}destroySampler(e){delete this.backend.get(e).sampler}generateMipmaps(e){const t=this.backend.get(e);if(e.isCubeTexture)for(let e=0;e<6;e++)this._generateMipmaps(t.texture,t.textureDescriptorGPU,e);else this._generateMipmaps(t.texture,t.textureDescriptorGPU)}getColorBuffer(){this.colorBuffer&&this.colorBuffer.destroy();const e=this.backend,{width:t,height:s}=e.getDrawingBufferSize();return this.colorBuffer=e.device.createTexture({label:"colorBuffer",size:{width:t,height:s,depthOrArrayLayers:1},sampleCount:e.parameters.sampleCount,format:Dy.BGRA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),this.colorBuffer}getDepthBuffer(e=!0,t=!0){const s=this.backend,{width:r,height:i}=s.getDrawingBufferSize(),n=this.depthTexture,o=s.get(n).texture;let a,u;if(t?(a=ye,u=Ne):e&&(a=be,u=_e),void 0!==o){if(n.image.width===r&&n.image.height===i&&n.format===a&&n.type===u)return o;this.destroyTexture(n)}return n.name="depthBuffer",n.format=a,n.type=u,n.image.width=r,n.image.height=i,this.createTexture(n,{sampleCount:s.parameters.sampleCount,width:r,height:i}),s.get(n).texture}updateTexture(e,t){const s=this.backend.get(e),{textureDescriptorGPU:r}=s;if(!e.isRenderTargetTexture&&void 0!==r){if(e.isDataTexture||e.isData3DTexture)this._copyBufferToTexture(t.image,s.texture,r,0,e.flipY);else if(e.isDataArrayTexture)for(let i=0;i<t.image.depth;i++)this._copyBufferToTexture(t.image,s.texture,r,i,e.flipY,i);else if(e.isCompressedTexture)this._copyCompressedBufferToTexture(e.mipmaps,s.texture,r);else if(e.isCubeTexture)this._copyCubeMapToTexture(t.images,s.texture,r,e.flipY);else if(e.isVideoTexture){const t=e.source.data;s.externalTexture=t}else this._copyImageToTexture(t.image,s.texture,r,0,e.flipY);s.version=e.version,e.onUpdate&&e.onUpdate(e)}}async copyTextureToBuffer(e,t,s,r,i){const n=this.backend.device,o=this.backend.get(e),a=o.texture,u=o.textureDescriptorGPU.format,l=this._getBytesPerTexel(u);let c=r*l;c=256*Math.ceil(c/256);const d=n.createBuffer({size:r*i*l,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),h=n.createCommandEncoder();h.copyTextureToBuffer({texture:a,origin:{x:t,y:s}},{buffer:d,bytesPerRow:c},{width:r,height:i});const p=this._getTypedArrayType(u);n.queue.submit([h.finish()]),await d.mapAsync(GPUMapMode.READ);return new p(d.getMappedRange())}_isEnvironmentTexture(e){const t=e.mapping;return t===Se||t===Ae||t===Re||t===Ce}_getDefaultTextureGPU(){let e=this.defaultTexture;if(null===e){const t=new ms;t.minFilter=_,t.magFilter=_,this.createTexture(t,{width:1,height:1}),this.defaultTexture=e=t}return this.backend.get(e).texture}_getDefaultCubeTextureGPU(){let e=this.defaultTexture;if(null===e){const t=new fs;t.minFilter=_,t.magFilter=_,this.createTexture(t,{width:1,height:1,depth:6}),this.defaultCubeTexture=e=t}return this.backend.get(e).texture}_copyCubeMapToTexture(e,t,s,r){for(let i=0;i<6;i++){const n=e[i],o=!0===r?Ab[i]:i;n.isDataTexture?this._copyBufferToTexture(n.image,t,s,o,r):this._copyImageToTexture(n,t,s,o,r)}}_copyImageToTexture(e,t,s,r,i){this.backend.device.queue.copyExternalImageToTexture({source:e},{texture:t,mipLevel:0,origin:{x:0,y:0,z:r}},{width:e.width,height:e.height,depthOrArrayLayers:1}),!0===i&&this._flipY(t,s,r)}_getPassUtils(){let e=this._passUtils;return null===e&&(this._passUtils=e=new vb(this.backend.device)),e}_generateMipmaps(e,t,s=0){this._getPassUtils().generateMipmaps(e,t,s)}_flipY(e,t,s=0){this._getPassUtils().flipY(e,t,s)}_copyBufferToTexture(e,t,s,r,i,n=0){const o=this.backend.device,a=e.data,u=this._getBytesPerTexel(s.format),l=e.width*u;o.queue.writeTexture({texture:t,mipLevel:0,origin:{x:0,y:0,z:r}},a,{offset:e.width*e.height*u*n,bytesPerRow:l},{width:e.width,height:e.height,depthOrArrayLayers:1}),!0===i&&this._flipY(t,s,r)}_copyCompressedBufferToTexture(e,t,s){const r=this.backend.device,i=this._getBlockData(s.format);for(let s=0;s<e.length;s++){const n=e[s],o=n.width,a=n.height,u=Math.ceil(o/i.width)*i.byteLength;r.queue.writeTexture({texture:t,mipLevel:s},n.data,{offset:0,bytesPerRow:u},{width:Math.ceil(o/i.width)*i.width,height:Math.ceil(a/i.width)*i.width,depthOrArrayLayers:1})}}_getBlockData(e){return e===Dy.BC1RGBAUnorm||e===Dy.BC1RGBAUnormSRGB?{byteLength:8,width:4,height:4}:e===Dy.BC2RGBAUnorm||e===Dy.BC2RGBAUnormSRGB||e===Dy.BC3RGBAUnorm||e===Dy.BC3RGBAUnormSRGB?{byteLength:16,width:4,height:4}:e===Dy.BC4RUnorm||e===Dy.BC4RSNorm?{byteLength:8,width:4,height:4}:e===Dy.BC5RGUnorm||e===Dy.BC5RGSnorm||e===Dy.BC6HRGBUFloat||e===Dy.BC6HRGBFloat||e===Dy.BC7RGBAUnorm||e===Dy.BC7RGBAUnormSRGB?{byteLength:16,width:4,height:4}:e===Dy.ETC2RGB8Unorm||e===Dy.ETC2RGB8UnormSRGB||e===Dy.ETC2RGB8A1Unorm||e===Dy.ETC2RGB8A1UnormSRGB?{byteLength:8,width:4,height:4}:e===Dy.ETC2RGBA8Unorm||e===Dy.ETC2RGBA8UnormSRGB?{byteLength:16,width:4,height:4}:e===Dy.EACR11Unorm||e===Dy.EACR11Snorm?{byteLength:8,width:4,height:4}:e===Dy.EACRG11Unorm||e===Dy.EACRG11Snorm||e===Dy.ASTC4x4Unorm||e===Dy.ASTC4x4UnormSRGB?{byteLength:16,width:4,height:4}:e===Dy.ASTC5x4Unorm||e===Dy.ASTC5x4UnormSRGB?{byteLength:16,width:5,height:4}:e===Dy.ASTC5x5Unorm||e===Dy.ASTC5x5UnormSRGB?{byteLength:16,width:5,height:5}:e===Dy.ASTC6x5Unorm||e===Dy.ASTC6x5UnormSRGB?{byteLength:16,width:6,height:5}:e===Dy.ASTC6x6Unorm||e===Dy.ASTC6x6UnormSRGB?{byteLength:16,width:6,height:6}:e===Dy.ASTC8x5Unorm||e===Dy.ASTC8x5UnormSRGB?{byteLength:16,width:8,height:5}:e===Dy.ASTC8x6Unorm||e===Dy.ASTC8x6UnormSRGB?{byteLength:16,width:8,height:6}:e===Dy.ASTC8x8Unorm||e===Dy.ASTC8x8UnormSRGB?{byteLength:16,width:8,height:8}:e===Dy.ASTC10x5Unorm||e===Dy.ASTC10x5UnormSRGB?{byteLength:16,width:10,height:5}:e===Dy.ASTC10x6Unorm||e===Dy.ASTC10x6UnormSRGB?{byteLength:16,width:10,height:6}:e===Dy.ASTC10x8Unorm||e===Dy.ASTC10x8UnormSRGB?{byteLength:16,width:10,height:8}:e===Dy.ASTC10x10Unorm||e===Dy.ASTC10x10UnormSRGB?{byteLength:16,width:10,height:10}:e===Dy.ASTC12x10Unorm||e===Dy.ASTC12x10UnormSRGB?{byteLength:16,width:12,height:10}:e===Dy.ASTC12x12Unorm||e===Dy.ASTC12x12UnormSRGB?{byteLength:16,width:12,height:12}:void 0}_convertAddressMode(e){let t=Vy;return e===ts?t=Gy:e===rs&&(t=ky),t}_convertFilterMode(e){let t=zy;return e!==_&&e!==is&&e!==ns||(t=$y),t}_getBytesPerTexel(e){return e===Dy.R8Unorm||e===Dy.R8Snorm||e===Dy.R8Uint||e===Dy.R8Sint?1:e===Dy.R16Uint||e===Dy.R16Sint||e===Dy.R16Float||e===Dy.RG8Unorm||e===Dy.RG8Snorm||e===Dy.RG8Uint||e===Dy.RG8Sint?2:e===Dy.R32Uint||e===Dy.R32Sint||e===Dy.R32Float||e===Dy.RG16Uint||e===Dy.RG16Sint||e===Dy.RG16Float||e===Dy.RGBA8Unorm||e===Dy.RGBA8UnormSRGB||e===Dy.RGBA8Snorm||e===Dy.RGBA8Uint||e===Dy.RGBA8Sint||e===Dy.BGRA8Unorm||e===Dy.BGRA8UnormSRGB||e===Dy.RGB9E5UFloat||e===Dy.RGB10A2Unorm||e===Dy.RG11B10UFloat||e===Dy.Depth32Float||e===Dy.Depth24Plus||e===Dy.Depth24PlusStencil8||e===Dy.Depth32FloatStencil8?4:e===Dy.RG32Uint||e===Dy.RG32Sint||e===Dy.RG32Float||e===Dy.RGBA16Uint||e===Dy.RGBA16Sint||e===Dy.RGBA16Float?8:e===Dy.RGBA32Uint||e===Dy.RGBA32Sint||e===Dy.RGBA32Float?16:void 0}_getTypedArrayType(e){return e===Dy.R8Uint?Uint8Array:e===Dy.R8Sint?Int8Array:e===Dy.R8Unorm?Uint8Array:e===Dy.R8Snorm?Int8Array:e===Dy.RG8Uint?Uint8Array:e===Dy.RG8Sint?Int8Array:e===Dy.RG8Unorm?Uint8Array:e===Dy.RG8Snorm?Int8Array:e===Dy.RGBA8Uint?Uint8Array:e===Dy.RGBA8Sint?Int8Array:e===Dy.RGBA8Unorm?Uint8Array:e===Dy.RGBA8Snorm?Int8Array:e===Dy.R16Uint?Uint16Array:e===Dy.R16Sint?Int16Array:e===Dy.RG16Uint?Uint16Array:e===Dy.RG16Sint?Int16Array:e===Dy.RGBA16Uint?Uint16Array:e===Dy.RGBA16Sint?Int16Array:e===Dy.R16Float||e===Dy.RG16Float||e===Dy.RGBA16Float?Float32Array:e===Dy.R32Uint?Uint32Array:e===Dy.R32Sint?Int32Array:e===Dy.R32Float?Float32Array:e===Dy.RG32Uint?Uint32Array:e===Dy.RG32Sint?Int32Array:e===Dy.RG32Float?Float32Array:e===Dy.RGBA32Uint?Uint32Array:e===Dy.RGBA32Sint?Int32Array:e===Dy.RGBA32Float?Float32Array:e===Dy.BGRA8Unorm||e===Dy.BGRA8UnormSRGB?Uint8Array:e===Dy.RGB10A2Unorm||e===Dy.RGB9E5UFloat||e===Dy.RG11B10UFloat?Uint32Array:e===Dy.Depth32Float?Float32Array:e===Dy.Depth24Plus||e===Dy.Depth24PlusStencil8?Uint32Array:e===Dy.Depth32FloatStencil8?Float32Array:void 0}_getDimension(e){let t;return t=e.isData3DTexture?cb:lb,t}}function Cb(e,t=null){const s=e.format,r=e.type,i=e.colorSpace;let n;if(!0===e.isFramebufferTexture&&e.type===ve)n=Dy.BGRA8Unorm;else if(!0===e.isCompressedTexture)switch(s){case Rt:n=i===p?Dy.BC1RGBAUnormSRGB:Dy.BC1RGBAUnorm;break;case Ct:n=i===p?Dy.BC2RGBAUnormSRGB:Dy.BC2RGBAUnorm;break;case Et:n=i===p?Dy.BC3RGBAUnormSRGB:Dy.BC3RGBAUnorm;break;case Ut:n=i===p?Dy.ETC2RGB8UnormSRGB:Dy.ETC2RGB8Unorm;break;case Lt:n=i===p?Dy.ETC2RGBA8UnormSRGB:Dy.ETC2RGBA8Unorm;break;case It:n=i===p?Dy.ASTC4x4UnormSRGB:Dy.ASTC4x4Unorm;break;case Pt:n=i===p?Dy.ASTC5x4UnormSRGB:Dy.ASTC5x4Unorm;break;case Dt:n=i===p?Dy.ASTC5x5UnormSRGB:Dy.ASTC5x5Unorm;break;case Vt:n=i===p?Dy.ASTC6x5UnormSRGB:Dy.ASTC6x5Unorm;break;case Gt:n=i===p?Dy.ASTC6x6UnormSRGB:Dy.ASTC6x6Unorm;break;case kt:n=i===p?Dy.ASTC8x5UnormSRGB:Dy.ASTC8x5Unorm;break;case zt:n=i===p?Dy.ASTC8x6UnormSRGB:Dy.ASTC8x6Unorm;break;case $t:n=i===p?Dy.ASTC8x8UnormSRGB:Dy.ASTC8x8Unorm;break;case Ht:n=i===p?Dy.ASTC10x5UnormSRGB:Dy.ASTC10x5Unorm;break;case Wt:n=i===p?Dy.ASTC10x6UnormSRGB:Dy.ASTC10x6Unorm;break;case jt:n=i===p?Dy.ASTC10x8UnormSRGB:Dy.ASTC10x8Unorm;break;case qt:n=i===p?Dy.ASTC10x10UnormSRGB:Dy.ASTC10x10Unorm;break;case Xt:n=i===p?Dy.ASTC12x10UnormSRGB:Dy.ASTC12x10Unorm;break;case Yt:n=i===p?Dy.ASTC12x12UnormSRGB:Dy.ASTC12x12Unorm}else switch(s){case Ie:switch(r){case ve:n=i===p?Dy.RGBA8UnormSRGB:Dy.RGBA8Unorm;break;case k:n=Dy.RGBA16Float;break;case y:n=Dy.RGBA32Float}break;case Ue:switch(r){case ve:n=Dy.R8Unorm;break;case k:n=Dy.R16Float;break;case y:n=Dy.R32Float}break;case Le:switch(r){case ve:n=Dy.RG8Unorm;break;case k:n=Dy.RG16Float;break;case y:n=Dy.RG32Float}break;case be:switch(r){case xt:n=Dy.Depth16Unorm;break;case _e:n=Dy.Depth24Plus;break;case y:n=Dy.Depth32Float}break;case ye:switch(r){case Ne:n=Dy.Depth24PlusStencil8;break;case y:t&&t.features.has(Tb.Depth32FloatStencil8),n=Dy.Depth32FloatStencil8}}return n}const Eb=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+)?/i,wb=/[a-z_0-9]+|<(.*?)>+/gi,Mb={f32:"float"};class Fb extends Nf{constructor(e){const{type:t,inputs:s,name:r,inputsCode:i,blockCode:n}=(e=>{const t=(e=e.trim()).match(Eb);if(null!==t&&4===t.length){const s=t[2],r=[];let i=null;for(;null!==(i=wb.exec(s));)r.push(i);const n=[];let o=0;for(;o<r.length;){const e=r[o++][0];let t=r[o++][0];t=Mb[t]||t,o<r.length&&!0===r[o][0].startsWith("<")&&o++,n.push(new Vd(t,e))}const a=e.substring(t[0].length),u=void 0!==t[1]?t[1]:"";return{type:t[3]||"void",inputs:n,name:u,inputsCode:s,blockCode:a}}throw new Error("FunctionNode: Function is not a WGSL code.")})(e);super(t,s,r),this.inputsCode=i,this.blockCode=n}getCode(e=this.name){const t="void"!==this.type?"-> "+this.type:"";return`fn ${e} ( ${this.inputsCode.trim()} ) ${t}`+this.blockCode}}class Bb extends bf{parseFunction(e){return new Fb(e)}}const Ob=self.GPUShaderStage,Ub={vertex:Ob?Ob.VERTEX:1,fragment:Ob?Ob.FRAGMENT:2,compute:Ob?Ob.COMPUTE:4},Lb={instance:!0,storageBuffer:!0},Ib={"^^":"threejs_xor"},Pb={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat2:"mat2x2<f32>",imat2:"mat2x2<i32>",umat2:"mat2x2<u32>",bmat2:"mat2x2<bool>",mat3:"mat3x3<f32>",imat3:"mat3x3<i32>",umat3:"mat3x3<u32>",bmat3:"mat3x3<bool>",mat4:"mat4x4<f32>",imat4:"mat4x4<i32>",umat4:"mat4x4<u32>",bmat4:"mat4x4<bool>"},Db={dFdx:"dpdx",dFdy:"- dpdy",mod_float:"threejs_mod_float",mod_vec2:"threejs_mod_vec2",mod_vec3:"threejs_mod_vec3",mod_vec4:"threejs_mod_vec4",equals_bool:"threejs_equals_bool",equals_bvec2:"threejs_equals_bvec2",equals_bvec3:"threejs_equals_bvec3",equals_bvec4:"threejs_equals_bvec4",lessThanEqual:"threejs_lessThanEqual",greaterThan:"threejs_greaterThan",inversesqrt:"inverseSqrt",bitcast:"bitcast<f32>"},Vb={threejs_xor:new Kn("\nfn threejs_xor( a : bool, b : bool ) -> bool {\n\n\treturn ( a || b ) && !( a && b );\n\n}\n"),lessThanEqual:new Kn("\nfn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );\n\n}\n"),greaterThan:new Kn("\nfn threejs_greaterThan( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x > b.x, a.y > b.y, a.z > b.z );\n\n}\n"),mod_float:new Kn("fn threejs_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new Kn("fn threejs_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new Kn("fn threejs_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new Kn("fn threejs_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new Kn("fn threejs_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new Kn("fn threejs_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new Kn("fn threejs_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new Kn("fn threejs_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping:new Kn("\nfn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n")};class Gb extends Pd{constructor(e,t,s=null){super(e,t,new Bb,s),this.uniformGroups={},this.builtins={}}needsColorSpaceToLinear(e){return!0===e.isVideoTexture&&e.colorSpace!==C}_generateTextureSample(e,t,s,r,i=this.shaderStage){return"fragment"===i?r?`textureSample( ${t}, ${t}_sampler, ${s}, ${r} )`:`textureSample( ${t}, ${t}_sampler, ${s} )`:this.generateTextureLod(e,t,s)}_generateVideoSample(e,t,s=this.shaderStage){if("fragment"===s)return`textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`}_generateTextureSampleLevel(e,t,s,r,i,n=this.shaderStage){return"fragment"===n&&!1===this.isUnfilterable(e)?`textureSampleLevel( ${t}, ${t}_sampler, ${s}, ${r} )`:this.generateTextureLod(e,t,s,r)}generateTextureLod(e,t,s,r="0"){this._include("repeatWrapping");return`textureLoad( ${t}, threejs_repeatWrapping( ${s}, ${`textureDimensions( ${t}, 0 )`} ), i32( ${r} ) )`}generateTextureLoad(e,t,s,r,i="0u"){return r?`textureLoad( ${t}, ${s}, ${r}, ${i} )`:`textureLoad( ${t}, ${s}, ${i} )`}generateTextureStore(e,t,s,r){return`textureStore( ${t}, ${s}, ${r} )`}isUnfilterable(e){return!0===e.isDataTexture&&e.type===y}generateTexture(e,t,s,r,i=this.shaderStage){let n=null;return n=!0===e.isVideoTexture?this._generateVideoSample(t,s,i):this.isUnfilterable(e)?this.generateTextureLod(e,t,s,"0",r,i):this._generateTextureSample(e,t,s,r,i),n}generateTextureCompare(e,t,s,r,i,n=this.shaderStage){if("fragment"===n)return`textureSampleCompare( ${t}, ${t}_sampler, ${s}, ${r} )`}generateTextureLevel(e,t,s,r,i,n=this.shaderStage){let o=null;return o=!0===e.isVideoTexture?this._generateVideoSample(t,s,n):this._generateTextureSampleLevel(e,t,s,r,i,n),o}getPropertyName(e,t=this.shaderStage){if(!0===e.isNodeVarying&&!0===e.needsInterpolation){if("vertex"===t)return`varyings.${e.name}`}else if(!0===e.isNodeUniform){const t=e.name,s=e.type;return"texture"===s||"cubeTexture"===s||"storageTexture"===s?t:"buffer"===s||"storageBuffer"===s?`NodeBuffer_${e.id}.${t}`:e.groupNode.name+"."+t}return super.getPropertyName(e)}_getUniformGroupCount(e){return Object.keys(this.uniforms[e]).length}getFunctionOperator(e){const t=Ib[e];return void 0!==t?(this._include(t),t):null}getUniformFromNode(e,t,s,r=null){const i=super.getUniformFromNode(e,t,s,r),n=this.getDataFromNode(e,s,this.globalCache);if(void 0===n.uniformGPU){let r;const o=this.bindings[s];if("texture"===t||"cubeTexture"===t||"storageTexture"===t){let n=null;if("texture"===t||"storageTexture"===t?n=new zx(i.name,i.node):"cubeTexture"===t&&(n=new $x(i.name,i.node)),n.store=!0===e.isStoreTextureNode,n.setVisibility(Ub[s]),"fragment"===s&&!1===this.isUnfilterable(e.value)&&!1===n.store){const e=new yb(`${i.name}_sampler`,i.node);e.setVisibility(Ub[s]),o.push(e,n),r=[e,n]}else o.push(n),r=[n]}else if("buffer"===t||"storageBuffer"===t){const i=new("storageBuffer"===t?_b:Ix)(e);i.setVisibility(Ub[s]),o.push(i),r=i}else{const n=e.groupNode,a=n.name,u=this.uniformGroups[s]||(this.uniformGroups[s]={});let l=u[a];void 0===l&&(l=new Vx(a,n),l.setVisibility(Ub[s]),u[a]=l,o.push(l)),r=this.getNodeUniform(i,t),l.addUniform(r)}n.uniformGPU=r,"vertex"===s&&(this.bindingsOffset.fragment=o.length)}return i}isReference(e){return super.isReference(e)||"texture_2d"===e||"texture_cube"===e||"texture_depth_2d"===e||"texture_storage_2d"===e}getBuiltin(e,t,s,r=this.shaderStage){const i=this.builtins[r]||(this.builtins[r]=new Map);return!1===i.has(e)&&i.set(e,{name:e,property:t,type:s}),t}getVertexIndex(){return"vertex"===this.shaderStage?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}buildFunctionCode(e){const t=e.layout,s=this.flowShaderNode(e),r=[];for(const e of t.inputs)r.push(e.name+" : "+this.getType(e.type));return`fn ${t.name}( ${r.join(", ")} ) -> ${this.getType(t.type)} {\n${s.vars}\n${s.code}\n\treturn ${s.result};\n\n}`}getInstanceIndex(){return"vertex"===this.shaderStage?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>")+".xy"}getFragDepth(){return"output."+this.getBuiltin("frag_depth","depth","f32","output")}isFlipY(){return!1}getBuiltins(e){const t=[],s=this.builtins[e];if(void 0!==s)for(const{name:e,property:r,type:i}of s.values())t.push(`@builtin( ${e} ) ${r} : ${i}`);return t.join(",\n\t")}getAttributes(e){const t=[];if("compute"===e&&this.getBuiltin("global_invocation_id","id","vec3<u32>","attribute"),"vertex"===e||"compute"===e){const e=this.getBuiltins("attribute");e&&t.push(e);const s=this.getAttributesArray();for(let e=0,r=s.length;e<r;e++){const r=s[e],i=r.name,n=this.getType(r.type);t.push(`@location( ${e} ) ${i} : ${n}`)}}return t.join(",\n\t")}getStructMembers(e){const t=[],s=e.getMemberTypes();for(let e=0;e<s.length;e++){const r=s[e];t.push(`\t@location( ${e} ) m${e} : ${r}<f32>`)}return t.join(",\n")}getStructs(e){const t=[],s=this.structs[e];for(let e=0,r=s.length;e<r;e++){const r=s[e];let i=`struct ${r.name} {\n`;i+=this.getStructMembers(r),i+="\n}",t.push(i)}return t.join("\n\n")}getVar(e,t){return`var ${t} : ${this.getType(e)}`}getVars(e){const t=[],s=this.vars[e];if(void 0!==s)for(const e of s)t.push(`\t${this.getVar(e.type,e.name)};`);return`\n${t.join("\n")}\n`}getVaryings(e){const t=[];if("vertex"===e&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),"vertex"===e||"fragment"===e){const s=this.varyings,r=this.vars[e];for(let i=0;i<s.length;i++){const n=s[i];if(n.needsInterpolation){let e=`@location( ${i} )`;/^(int|uint|ivec|uvec)/.test(n.type)&&(e+=" @interpolate( flat )"),t.push(`${e} ${n.name} : ${this.getType(n.type)}`)}else"vertex"===e&&!1===r.includes(n)&&r.push(n)}}const s=this.getBuiltins(e);s&&t.push(s);const r=t.join(",\n\t");return"vertex"===e?this._getWGSLStruct("VaryingsStruct","\t"+r):r}getUniforms(e){const t=this.uniforms[e],s=[],r=[],i=[],n={};let o=this.bindingsOffset[e];for(const i of t)if("texture"===i.type||"cubeTexture"===i.type||"storageTexture"===i.type){const t=i.node.value;let r;if("fragment"===e&&!1===this.isUnfilterable(t)&&!0!==i.node.isStoreTextureNode&&(!0===t.isDepthTexture&&null!==t.compareFunction?s.push(`@binding( ${o++} ) @group( 0 ) var ${i.name}_sampler : sampler_comparison;`):s.push(`@binding( ${o++} ) @group( 0 ) var ${i.name}_sampler : sampler;`)),!0===t.isCubeTexture)r="texture_cube<f32>";else if(!0===t.isDataArrayTexture)r="texture_2d_array<f32>";else if(!0===t.isDepthTexture)r="texture_depth_2d";else if(!0===t.isVideoTexture)r="texture_external";else if(!0===i.node.isStoreTextureNode){r="texture_storage_2d<"+Cb(t)+", write>"}else r="texture_2d<f32>";s.push(`@binding( ${o++} ) @group( 0 ) var ${i.name} : ${r};`)}else if("buffer"===i.type||"storageBuffer"===i.type){const e=i.node,t=this.getType(e.bufferType),s=e.bufferCount,n=s>0?", "+s:"",a=`\t${i.name} : array< ${t}${n} >\n`,u=e.isStorageBufferNode?"storage,read_write":"uniform";r.push(this._getWGSLStructBinding("NodeBuffer_"+e.id,a,u,o++))}else{const e=this.getType(this.getVectorType(i.type)),t=i.groupNode.name;(n[t]||(n[t]={index:o++,snippets:[]})).snippets.push(`\t${i.name} : ${e}`)}for(const e in n){const t=n[e];i.push(this._getWGSLStructBinding(e,t.snippets.join(",\n"),"uniform",t.index))}let a=s.join("\n");return a+=r.join("\n"),a+=i.join("\n"),a}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};for(const t in e){const s=e[t];s.uniforms=this.getUniforms(t),s.attributes=this.getAttributes(t),s.varyings=this.getVaryings(t),s.structs=this.getStructs(t),s.vars=this.getVars(t),s.codes=this.getCodes(t);let r="// code\n\n";r+=this.flowCode[t];const i=this.flowNodes[t],n=i[i.length-1],o=n.outputNode,a=void 0!==o&&!0===o.isOutputStructNode;for(const e of i){const i=this.getFlowData(e),u=e.name;if(u&&(r.length>0&&(r+="\n"),r+=`\t// flow -> ${u}\n\t`),r+=`${i.code}\n\t`,e===n&&"compute"!==t)if(r+="// result\n\n\t","vertex"===t)r+=`varyings.Vertex = ${i.result};`;else if("fragment"===t)if(a)s.returnType=o.nodeType,r+=`return ${i.result};`;else{let e="\t@location(0) color: vec4<f32>";const t=this.getBuiltins("output");t&&(e+=",\n\t"+t),s.returnType="OutputStruct",s.structs+=this._getWGSLStruct("OutputStruct",e),s.structs+="\nvar<private> output : OutputStruct;\n\n",r+=`output.color = ${i.result};\n\n\treturn output;`}}s.flow=r}null!==this.material?(this.vertexShader=this._getWGSLVertexCode(e.vertex),this.fragmentShader=this._getWGSLFragmentCode(e.fragment)):this.computeShader=this._getWGSLComputeCode(e.compute,(this.object.workgroupSize||[64]).join(", "))}getMethod(e,t=null){let s;return null!==t&&(s=this._getWGSLMethod(e+"_"+t)),void 0===s&&(s=this._getWGSLMethod(e)),s||e}getType(e){return Pb[e]||e}isAvailable(e){return!0===Lb[e]}_getWGSLMethod(e){return void 0!==Vb[e]&&this._include(e),Db[e]}_include(e){const t=Vb[e];return t.build(this),null!==this.currentFunctionNode&&this.currentFunctionNode.includes.push(t),t}_getWGSLVertexCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${e.codes}\n\n@vertex\nfn main( ${e.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n\treturn varyings;\n\n}\n`}_getWGSLFragmentCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// structs\n${e.structs}\n\n// codes\n${e.codes}\n\n@fragment\nfn main( ${e.varyings} ) -> ${e.returnType} {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLComputeCode(e,t){return`${this.getSignature()}\n// system\nvar<private> instanceIndex : u32;\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@compute @workgroup_size( ${t} )\nfn main( ${e.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x;\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLStruct(e,t){return`\nstruct ${e} {\n${t}\n};`}_getWGSLStructBinding(e,t,s,r=0,i=0){const n=e+"Struct";return`${this._getWGSLStruct(n,t)}\n@binding( ${r} ) @group( ${i} )\nvar<${s}> ${e} : ${n};`}}class kb{constructor(e){this.backend=e}getCurrentDepthStencilFormat(e){let t;return null!==e.depthTexture?t=this.getTextureFormatGPU(e.depthTexture):e.depth&&e.stencil?t=Dy.Depth24PlusStencil8:e.depth&&(t=Dy.Depth24Plus),t}getTextureFormatGPU(e){return this.backend.get(e).texture.format}getCurrentColorFormat(e){let t;return t=null!==e.textures?this.getTextureFormatGPU(e.textures[0]):Dy.BGRA8Unorm,t}getCurrentColorSpace(e){return null!==e.textures?e.textures[0].colorSpace:this.backend.renderer.outputColorSpace}getPrimitiveTopology(e,t){return e.isPoints?fy:e.isLineSegments||e.isMesh&&!0===t.wireframe?Ty:e.isLine?xy:e.isMesh?yy:void 0}getSampleCount(e){return null!==e.textures?e.sampleCount:this.backend.parameters.sampleCount}}const zb=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]),$b=new Map([[D,["float16"]]]),Hb=new Map([[Int32Array,"sint32"],[Uint32Array,"uint32"],[Float32Array,"float32"]]);class Wb{constructor(e){this.backend=e}createAttribute(e,t){const s=this._getBufferAttribute(e),r=this.backend,i=r.get(s);let n=i.buffer;if(void 0===n){const e=r.device;let o=s.array;if((s.isStorageBufferAttribute||s.isStorageInstancedBufferAttribute)&&3===s.itemSize){s.itemSize=4,o=new o.constructor(4*s.count);for(let e=0;e<s.count;e++)o.set(s.array.subarray(3*e,3*e+3),4*e)}const a=o.byteLength+(4-o.byteLength%4)%4;n=e.createBuffer({label:s.name,size:a,usage:t,mappedAtCreation:!0}),new o.constructor(n.getMappedRange()).set(o),n.unmap(),i.buffer=n}}updateAttribute(e){const t=this._getBufferAttribute(e),s=this.backend,r=s.device,i=s.get(t).buffer,n=t.array,o=t.updateRanges;if(0===o.length)r.queue.writeBuffer(i,0,n,0);else{for(let e=0,t=o.length;e<t;e++){const t=o[e];r.queue.writeBuffer(i,0,n,t.start*n.BYTES_PER_ELEMENT,t.count*n.BYTES_PER_ELEMENT)}t.clearUpdateRanges()}}createShaderVertexBuffers(e){const t=e.getAttributes(),s=new Map;for(let e=0;e<t.length;e++){const r=t[e],i=r.array.BYTES_PER_ELEMENT,n=this._getBufferAttribute(r);let o=s.get(n);if(void 0===o){let e,t;!0===r.isInterleavedBufferAttribute?(e=r.data.stride*i,t=r.data.isInstancedInterleavedBuffer?fb:mb):(e=r.itemSize*i,t=r.isInstancedBufferAttribute?fb:mb),o={arrayStride:e,attributes:[],stepMode:t},s.set(n,o)}const a=this._getVertexFormat(r),u=!0===r.isInterleavedBufferAttribute?r.offset*i:0;o.attributes.push({shaderLocation:e,offset:u,format:a})}return Array.from(s.values())}destroyAttribute(e){const t=this.backend;t.get(this._getBufferAttribute(e)).buffer.destroy(),t.delete(e)}async getArrayBufferAsync(e){const t=this.backend,s=t.device,r=t.get(this._getBufferAttribute(e)),i=r.buffer,n=i.size;let o=r.readBuffer,a=!0;void 0===o&&(o=s.createBuffer({label:e.name,size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),a=!1,r.readBuffer=o);const u=s.createCommandEncoder({});u.copyBufferToBuffer(i,0,o,0,n),a&&o.unmap();const l=u.finish();s.queue.submit([l]),await o.mapAsync(GPUMapMode.READ);return o.getMappedRange()}_getVertexFormat(e){const{itemSize:t,normalized:s}=e,r=e.array.constructor,i=e.constructor;let n;if(1==t)n=Hb.get(r);else{const e=($b.get(i)||zb.get(r))[s?1:0];if(e){const s=r.BYTES_PER_ELEMENT*t,i=4*Math.floor((s+3)/4)/r.BYTES_PER_ELEMENT;if(i%1)throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");n=`${e}x${i}`}}return n}_getBufferAttribute(e){return e.isInterleavedBufferAttribute&&(e=e.data),e}}class jb{constructor(e){this.backend=e}createBindingsLayout(e){const t=this.backend.device,s=[];let r=0;for(const t of e){const e={binding:r++,visibility:t.visibility};if(t.isUniformBuffer||t.isStorageBuffer){const s={};t.isStorageBuffer&&(s.type=ob),e.buffer=s}else if(t.isSampler){const s={};t.texture.isDepthTexture&&null!==t.texture.compareFunction&&(s.type="comparison"),e.sampler=s}else if(t.isSampledTexture&&t.texture.isVideoTexture)e.externalTexture={};else if(t.isSampledTexture&&t.store){const s=this.backend.get(t.texture).texture.format;e.storageTexture={format:s}}else if(t.isSampledTexture){const s={};t.texture.isDepthTexture?s.sampleType=ub:t.texture.isDataTexture&&t.texture.type===y&&(s.sampleType=ab),t.isSampledCubeTexture?s.viewDimension=pb:t.texture.isDataArrayTexture&&(s.viewDimension=hb),e.texture=s}s.push(e)}return t.createBindGroupLayout({entries:s})}createBindings(e){const t=this.backend.get(e),s=this.createBindingsLayout(e),r=this.createBindGroup(e,s);t.layout=s,t.group=r,t.bindings=e}updateBinding(e){const t=this.backend,s=t.device,r=e.buffer,i=t.get(e).buffer;s.queue.writeBuffer(i,0,r,0)}createBindGroup(e,t){const s=this.backend,r=s.device;let i=0;const n=[];for(const t of e){if(t.isUniformBuffer){const e=s.get(t);if(void 0===e.buffer){const s=t.byteLength,i=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n=r.createBuffer({label:"bindingBuffer_"+t.name,size:s,usage:i});e.buffer=n}n.push({binding:i,resource:{buffer:e.buffer}})}else if(t.isStorageBuffer){const e=s.get(t);if(void 0===e.buffer){const r=t.attribute;e.buffer=s.get(r).buffer}n.push({binding:i,resource:{buffer:e.buffer}})}else if(t.isSampler){const e=s.get(t.texture);n.push({binding:i,resource:e.sampler})}else if(t.isSampledTexture){const e=s.get(t.texture);let o,a;if(o=t.isSampledCubeTexture?pb:t.texture.isDataArrayTexture?hb:db,void 0!==e.externalTexture)a=r.importExternalTexture({source:e.externalTexture});else{const s=gb;a=e.texture.createView({aspect:s,dimension:o,mipLevelCount:t.store?1:e.mipLevelCount})}n.push({binding:i,resource:a})}i++}return r.createBindGroup({layout:t,entries:n})}}class qb{constructor(e){this.backend=e}createRenderPipeline(e,t){const{object:s,material:r,geometry:i,pipeline:n}=e,{vertexProgram:o,fragmentProgram:a}=n,u=this.backend,l=u.device,c=u.utils,d=u.get(n),h=u.get(e.getBindings()),p=u.attributeUtils.createShaderVertexBuffers(e);let g;!0===r.transparent&&r.blending!==B&&(g=this._getBlending(r));let m={};!0===r.stencilWrite&&(m={compare:this._getStencilCompare(r),failOp:this._getStencilOperation(r.stencilFail),depthFailOp:this._getStencilOperation(r.stencilZFail),passOp:this._getStencilOperation(r.stencilZPass)});const f=this._getColorWriteMask(r),T=[];if(null!==e.context.textures){const t=e.context.textures;for(let e=0;e<t.length;e++){const s=c.getTextureFormatGPU(t[e]);T.push({format:s,blend:g,writeMask:f})}}else{const t=c.getCurrentColorFormat(e.context);T.push({format:t,blend:g,writeMask:f})}const x=u.get(o).module,y=u.get(a).module,b=this._getPrimitiveState(s,i,r),N=this._getDepthCompare(r),_=c.getCurrentDepthStencilFormat(e.context);let v=c.getSampleCount(e.context);v>1&&(v=Math.pow(2,Math.floor(Math.log2(v))),2===v&&(v=4));const S={vertex:Object.assign({},x,{buffers:p}),fragment:Object.assign({},y,{targets:T}),primitive:b,depthStencil:{format:_,depthWriteEnabled:r.depthWrite,depthCompare:N,stencilFront:m,stencilBack:{},stencilReadMask:r.stencilFuncMask,stencilWriteMask:r.stencilWriteMask},multisample:{count:v,alphaToCoverageEnabled:r.alphaToCoverage},layout:l.createPipelineLayout({bindGroupLayouts:[h.layout]})};if(null===t)d.pipeline=l.createRenderPipeline(S);else{const e=new Promise((e=>{l.createRenderPipelineAsync(S).then((t=>{d.pipeline=t,e()}))}));t.push(e)}}createComputePipeline(e,t){const s=this.backend,r=s.device,i=s.get(e.computeProgram).module,n=s.get(e),o=s.get(t);n.pipeline=r.createComputePipeline({compute:i,layout:r.createPipelineLayout({bindGroupLayouts:[o.layout]})})}_getBlending(e){let t,s;const r=e.blending;if(r===tt){const r=null!==e.blendSrcAlpha?e.blendSrcAlpha:Hy.One,i=null!==e.blendDstAlpha?e.blendDstAlpha:Hy.Zero,n=null!==e.blendEquationAlpha?e.blendEquationAlpha:Hy.Add;t={srcFactor:this._getBlendFactor(e.blendSrc),dstFactor:this._getBlendFactor(e.blendDst),operation:this._getBlendOperation(e.blendEquation)},s={srcFactor:this._getBlendFactor(r),dstFactor:this._getBlendFactor(i),operation:this._getBlendOperation(n)}}else{const i=(e,r,i,n)=>{t={srcFactor:e,dstFactor:r,operation:Wy},s={srcFactor:i,dstFactor:n,operation:Wy}};if(e.premultipliedAlpha)switch(r){case nt:i(Hy.SrcAlpha,Hy.OneMinusSrcAlpha,Hy.One,Hy.OneMinusSrcAlpha);break;case it:i(Hy.SrcAlpha,Hy.One,Hy.One,Hy.One);break;case rt:i(Hy.Zero,Hy.OneMinusSrc,Hy.Zero,Hy.One);break;case st:i(Hy.Zero,Hy.Src,Hy.Zero,Hy.SrcAlpha)}else switch(r){case nt:i(Hy.SrcAlpha,Hy.OneMinusSrcAlpha,Hy.One,Hy.OneMinusSrcAlpha);break;case it:i(Hy.SrcAlpha,Hy.One,Hy.SrcAlpha,Hy.One);break;case rt:i(Hy.Zero,Hy.OneMinusSrc,Hy.Zero,Hy.One);break;case st:i(Hy.Zero,Hy.Src,Hy.Zero,Hy.Src)}}if(void 0!==t&&void 0!==s)return{color:t,alpha:s}}_getBlendFactor(e){let t;switch(e){case ke:t=Hy.Zero;break;case ze:t=Hy.One;break;case $e:t=Hy.Src;break;case Xe:t=Hy.OneMinusSrc;break;case He:t=Hy.SrcAlpha;break;case Ye:t=Hy.OneMinusSrcAlpha;break;case je:t=Hy.Dst;break;case Ke:t=Hy.OneMinusDstColor;break;case qe:t=Hy.DstAlpha;break;case Qe:t=Hy.OneMinusDstAlpha;break;case We:t=Hy.SrcAlphaSaturated;break;case 211:t=Hy.Constant;break;case 212:t=Hy.OneMinusConstant}return t}_getStencilCompare(e){let t;switch(e.stencilFunc){case Ss:t=Ny;break;case vs:t=Ey;break;case _s:t=_y;break;case Ns:t=Sy;break;case bs:t=vy;break;case ys:t=Cy;break;case xs:t=Ay;break;case Ts:t=Ry}return t}_getStencilOperation(e){let t;switch(e){case Bs:t=Zy;break;case Fs:t=Jy;break;case Ms:t=eb;break;case ws:t=tb;break;case Es:t=sb;break;case Cs:t=rb;break;case Rs:t=ib;break;case As:t=nb}return t}_getBlendOperation(e){let t;switch(e){case De:t=Wy;break;case Ve:t=jy;break;case Ge:t=qy;break;case Us:t=Xy;break;case Os:t=Yy}return t}_getPrimitiveState(e,t,s){const r={},i=this.backend.utils;switch(r.topology=i.getPrimitiveTopology(e,s),null!==t.index&&!0===e.isLine&&!0!==e.isLineSegments&&(r.stripIndexFormat=t.index.array instanceof Uint16Array?Iy:Py),s.side){case Fe:r.frontFace=By,r.cullMode=Ly;break;case F:r.frontFace=By,r.cullMode=Uy;break;case Me:r.frontFace=By,r.cullMode=Oy}return r}_getColorWriteMask(e){return!0===e.colorWrite?Qy:Ky}_getDepthCompare(e){let t;if(!1===e.depthTest)t=Ey;else{switch(e.depthFunc){case pt:t=Ny;break;case ht:t=Ey;break;case dt:t=_y;break;case ct:t=Sy;break;case lt:t=vy;break;case ut:t=Cy;break;case at:t=Ay;break;case ot:t=Ry}}return t}}class Xb extends Zx{constructor(e={}){super(e),this.isWebGPUBackend=!0,this.parameters.alpha=void 0===e.alpha||e.alpha,this.parameters.antialias=!0===e.antialias,!0===this.parameters.antialias?this.parameters.sampleCount=void 0===e.sampleCount?4:e.sampleCount:this.parameters.sampleCount=1,this.parameters.requiredLimits=void 0===e.requiredLimits?{}:e.requiredLimits,this.trackTimestamp=!0===e.trackTimestamp,this.adapter=null,this.device=null,this.context=null,this.colorBuffer=null,this.defaultRenderPassdescriptor=null,this.utils=new kb(this),this.attributeUtils=new Wb(this),this.bindingUtils=new jb(this),this.pipelineUtils=new qb(this),this.textureUtils=new Rb(this),this.occludedResolveCache=new Map}async init(e){await super.init(e);const t=this.parameters,s={powerPreference:t.powerPreference},r=await navigator.gpu.requestAdapter(s);if(null===r)throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");const i=Object.values(Tb),n=[];for(const e of i)r.features.has(e)&&n.push(e);const o={requiredFeatures:n,requiredLimits:t.requiredLimits},a=await r.requestDevice(o),u=void 0!==t.context?t.context:e.domElement.getContext("webgpu");this.adapter=r,this.device=a,this.context=u;const l=t.alpha?"premultiplied":"opaque";this.context.configure({device:this.device,format:Dy.BGRA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:l}),this.updateSize()}get coordinateSystem(){return b}async getArrayBufferAsync(e){return await this.attributeUtils.getArrayBufferAsync(e)}getContext(){return this.context}_getDefaultRenderPassDescriptor(){let e=this.defaultRenderPassdescriptor;const t=this.parameters.antialias;if(null===e){const s=this.renderer;e={colorAttachments:[{view:null}],depthStencilAttachment:{view:this.textureUtils.getDepthBuffer(s.depth,s.stencil).createView()}};const r=e.colorAttachments[0];!0===t?r.view=this.colorBuffer.createView():r.resolveTarget=void 0,this.defaultRenderPassdescriptor=e}const s=e.colorAttachments[0];return!0===t?s.resolveTarget=this.context.getCurrentTexture().createView():s.view=this.context.getCurrentTexture().createView(),e}_getRenderPassDescriptor(e){const t=e.renderTarget,s=this.get(t);let r=s.descriptors;void 0===r&&(r=[],s.descriptors=r),s.width===t.width&&s.height===t.height&&s.activeMipmapLevel===t.activeMipmapLevel&&s.samples===t.samples||(r.length=0);let i=r[e.activeCubeFace];if(void 0===i){const n=e.textures,o=[];for(let t=0;t<n.length;t++){const s=this.get(n[t]),r=s.texture.createView({baseMipLevel:e.activeMipmapLevel,mipLevelCount:1,baseArrayLayer:e.activeCubeFace,dimension:db});let i,a;void 0!==s.msaaTexture?(i=s.msaaTexture.createView(),a=r):(i=r,a=void 0),o.push({view:i,resolveTarget:a,loadOp:My,storeOp:wy})}i={colorAttachments:o,depthStencilAttachment:{view:this.get(e.depthTexture).texture.createView()}},r[e.activeCubeFace]=i,s.width=t.width,s.height=t.height,s.samples=t.samples,s.activeMipmapLevel=t.activeMipmapLevel}return i}beginRender(e){const t=this.get(e),s=this.device,r=e.occlusionQueryCount;let i,n;r>0&&(t.currentOcclusionQuerySet&&t.currentOcclusionQuerySet.destroy(),t.currentOcclusionQueryBuffer&&t.currentOcclusionQueryBuffer.destroy(),t.currentOcclusionQuerySet=t.occlusionQuerySet,t.currentOcclusionQueryBuffer=t.occlusionQueryBuffer,t.currentOcclusionQueryObjects=t.occlusionQueryObjects,i=s.createQuerySet({type:"occlusion",count:r}),t.occlusionQuerySet=i,t.occlusionQueryIndex=0,t.occlusionQueryObjects=new Array(r),t.lastOcclusionObject=null),n=null===e.textures?this._getDefaultRenderPassDescriptor():this._getRenderPassDescriptor(e),this.initTimestampQuery(e,n),n.occlusionQuerySet=i;const o=n.depthStencilAttachment;if(null!==e.textures){const t=n.colorAttachments;for(let s=0;s<t.length;s++){const r=t[s];e.clearColor?(r.clearValue=e.clearColorValue,r.loadOp=Fy,r.storeOp=wy):(r.loadOp=My,r.storeOp=wy)}}else{const t=n.colorAttachments[0];e.clearColor?(t.clearValue=e.clearColorValue,t.loadOp=Fy,t.storeOp=wy):(t.loadOp=My,t.storeOp=wy)}e.depth&&(e.clearDepth?(o.depthClearValue=e.clearDepthValue,o.depthLoadOp=Fy,o.depthStoreOp=wy):(o.depthLoadOp=My,o.depthStoreOp=wy)),e.stencil&&(e.clearStencil?(o.stencilClearValue=e.clearStencilValue,o.stencilLoadOp=Fy,o.stencilStoreOp=wy):(o.stencilLoadOp=My,o.stencilStoreOp=wy));const a=s.createCommandEncoder({label:"renderContext_"+e.id}),u=a.beginRenderPass(n);if(t.descriptor=n,t.encoder=a,t.currentPass=u,t.currentSets={attributes:{}},e.viewport&&this.updateViewport(e),e.scissor){const{x:t,y:s,width:r,height:i}=e.scissorValue;u.setScissorRect(t,e.height-i-s,r,i)}}finishRender(e){const t=this.get(e),s=e.occlusionQueryCount;if(s>t.occlusionQueryIndex&&t.currentPass.endOcclusionQuery(),t.currentPass.end(),s>0){const r=8*s;let i=this.occludedResolveCache.get(r);void 0===i&&(i=this.device.createBuffer({size:r,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.occludedResolveCache.set(r,i));const n=this.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});t.encoder.resolveQuerySet(t.occlusionQuerySet,0,s,i,0),t.encoder.copyBufferToBuffer(i,0,n,0,r),t.occlusionQueryBuffer=n,this.resolveOccludedAsync(e)}if(this.prepareTimestampBuffer(e,t.encoder),this.device.queue.submit([t.encoder.finish()]),null!==e.textures){const t=e.textures;for(let e=0;e<t.length;e++){const s=t[e];!0===s.generateMipmaps&&this.textureUtils.generateMipmaps(s)}}}isOccluded(e,t){const s=this.get(e);return s.occluded&&s.occluded.has(t)}async resolveOccludedAsync(e){const t=this.get(e),{currentOcclusionQueryBuffer:s,currentOcclusionQueryObjects:r}=t;if(s&&r){const e=new WeakSet;t.currentOcclusionQueryObjects=null,t.currentOcclusionQueryBuffer=null,await s.mapAsync(GPUMapMode.READ);const i=s.getMappedRange(),n=new BigUint64Array(i);for(let t=0;t<r.length;t++)0n!==n[t]&&e.add(r[t]);s.destroy(),t.occluded=e}}updateViewport(e){const{currentPass:t}=this.get(e),{x:s,y:r,width:i,height:n,minDepth:o,maxDepth:a}=e.viewportValue;t.setViewport(s,e.height-n-r,i,n,o,a)}clear(e,t,s,r=null){const i=this.device,n=this.renderer;let o,a,u,l,c=[];if(e){const e=this.getClearColor();a={r:e.r,g:e.g,b:e.b,a:e.a}}if(null===r){u=n.depth,l=n.stencil;const t=this._getDefaultRenderPassDescriptor();if(e){c=t.colorAttachments;const e=c[0];e.clearValue=a,e.loadOp=Fy,e.storeOp=wy}(u||l)&&(o=t.depthStencilAttachment)}else{if(u=r.depth,l=r.stencil,e)for(const e of r.textures){const t=this.get(e),s=t.texture.createView();let r,i;void 0!==t.msaaTexture?(r=t.msaaTexture.createView(),i=s):(r=s,i=void 0),c.push({view:r,resolveTarget:i,clearValue:a,loadOp:Fy,storeOp:wy})}if(u||l){o={view:this.get(r.depthTexture).texture.createView()}}}u&&(t?(o.depthLoadOp=Fy,o.depthClearValue=n.getClearDepth(),o.depthStoreOp=wy):(o.depthLoadOp=My,o.depthStoreOp=wy)),l&&(s?(o.stencilLoadOp=Fy,o.stencilClearValue=n.getClearStencil(),o.stencilStoreOp=wy):(o.stencilLoadOp=My,o.stencilStoreOp=wy));const d=i.createCommandEncoder({});d.beginRenderPass({colorAttachments:c,depthStencilAttachment:o}).end(),i.queue.submit([d.finish()])}beginCompute(e){const t=this.get(e),s={};this.initTimestampQuery(e,s),t.cmdEncoderGPU=this.device.createCommandEncoder(),t.passEncoderGPU=t.cmdEncoderGPU.beginComputePass(s)}compute(e,t,s,r){const{passEncoderGPU:i}=this.get(e),n=this.get(r).pipeline;i.setPipeline(n);const o=this.get(s).group;i.setBindGroup(0,o),i.dispatchWorkgroups(t.dispatchCount)}finishCompute(e){const t=this.get(e);t.passEncoderGPU.end(),this.prepareTimestampBuffer(e,t.cmdEncoderGPU),this.device.queue.submit([t.cmdEncoderGPU.finish()])}draw(e,t){const{object:s,geometry:r,context:i,pipeline:n}=e,o=this.get(e.getBindings()),a=this.get(i),u=this.get(n).pipeline,l=a.currentSets,c=a.currentPass;l.pipeline!==u&&(c.setPipeline(u),l.pipeline=u);const d=o.group;c.setBindGroup(0,d);const h=e.getIndex(),p=null!==h;if(!0===p&&l.index!==h){const e=this.get(h).buffer,t=h.array instanceof Uint16Array?Iy:Py;c.setIndexBuffer(e,t),l.index=h}const g=e.getVertexBuffers();for(let e=0,t=g.length;e<t;e++){const t=g[e];if(l.attributes[e]!==t){const s=this.get(t).buffer;c.setVertexBuffer(e,s),l.attributes[e]=t}}if(void 0!==a.occlusionQuerySet){const e=a.lastOcclusionObject;e!==s&&(null!==e&&!0===e.occlusionTest&&(c.endOcclusionQuery(),a.occlusionQueryIndex++),!0===s.occlusionTest&&(c.beginOcclusionQuery(a.occlusionQueryIndex),a.occlusionQueryObjects[a.occlusionQueryIndex]=s),a.lastOcclusionObject=s)}const m=r.drawRange,f=m.start,T=this.getInstanceCount(e);if(0!==T)if(!0===p){const e=m.count!==1/0?m.count:h.count;c.drawIndexed(e,T,f,0,0),t.update(s,e,T)}else{const e=r.attributes.position,i=m.count!==1/0?m.count:e.count;c.draw(i,T,f,0),t.update(s,i,T)}}needsRenderUpdate(e){const t=this.get(e),{object:s,material:r}=e,i=this.utils,n=i.getSampleCount(e.context),o=i.getCurrentColorSpace(e.context),a=i.getCurrentColorFormat(e.context),u=i.getCurrentDepthStencilFormat(e.context),l=i.getPrimitiveTopology(s,r);let c=!1;return t.material===r&&t.materialVersion===r.version&&t.transparent===r.transparent&&t.blending===r.blending&&t.premultipliedAlpha===r.premultipliedAlpha&&t.blendSrc===r.blendSrc&&t.blendDst===r.blendDst&&t.blendEquation===r.blendEquation&&t.blendSrcAlpha===r.blendSrcAlpha&&t.blendDstAlpha===r.blendDstAlpha&&t.blendEquationAlpha===r.blendEquationAlpha&&t.colorWrite===r.colorWrite&&t.depthWrite===r.depthWrite&&t.depthTest===r.depthTest&&t.depthFunc===r.depthFunc&&t.stencilWrite===r.stencilWrite&&t.stencilFunc===r.stencilFunc&&t.stencilFail===r.stencilFail&&t.stencilZFail===r.stencilZFail&&t.stencilZPass===r.stencilZPass&&t.stencilFuncMask===r.stencilFuncMask&&t.stencilWriteMask===r.stencilWriteMask&&t.side===r.side&&t.alphaToCoverage===r.alphaToCoverage&&t.sampleCount===n&&t.colorSpace===o&&t.colorFormat===a&&t.depthStencilFormat===u&&t.primitiveTopology===l&&t.clippingContextVersion===e.clippingContextVersion||(t.material=r,t.materialVersion=r.version,t.transparent=r.transparent,t.blending=r.blending,t.premultipliedAlpha=r.premultipliedAlpha,t.blendSrc=r.blendSrc,t.blendDst=r.blendDst,t.blendEquation=r.blendEquation,t.blendSrcAlpha=r.blendSrcAlpha,t.blendDstAlpha=r.blendDstAlpha,t.blendEquationAlpha=r.blendEquationAlpha,t.colorWrite=r.colorWrite,t.depthWrite=r.depthWrite,t.depthTest=r.depthTest,t.depthFunc=r.depthFunc,t.stencilWrite=r.stencilWrite,t.stencilFunc=r.stencilFunc,t.stencilFail=r.stencilFail,t.stencilZFail=r.stencilZFail,t.stencilZPass=r.stencilZPass,t.stencilFuncMask=r.stencilFuncMask,t.stencilWriteMask=r.stencilWriteMask,t.side=r.side,t.alphaToCoverage=r.alphaToCoverage,t.sampleCount=n,t.colorSpace=o,t.colorFormat=a,t.depthStencilFormat=u,t.primitiveTopology=l,t.clippingContextVersion=e.clippingContextVersion,c=!0),c}getRenderCacheKey(e){const{object:t,material:s}=e,r=this.utils,i=e.context;return[s.transparent,s.blending,s.premultipliedAlpha,s.blendSrc,s.blendDst,s.blendEquation,s.blendSrcAlpha,s.blendDstAlpha,s.blendEquationAlpha,s.colorWrite,s.depthWrite,s.depthTest,s.depthFunc,s.stencilWrite,s.stencilFunc,s.stencilFail,s.stencilZFail,s.stencilZPass,s.stencilFuncMask,s.stencilWriteMask,s.side,r.getSampleCount(i),r.getCurrentColorSpace(i),r.getCurrentColorFormat(i),r.getCurrentDepthStencilFormat(i),r.getPrimitiveTopology(t,s),e.clippingContextVersion].join()}createSampler(e){this.textureUtils.createSampler(e)}destroySampler(e){this.textureUtils.destroySampler(e)}createDefaultTexture(e){this.textureUtils.createDefaultTexture(e)}createTexture(e,t){this.textureUtils.createTexture(e,t)}updateTexture(e,t){this.textureUtils.updateTexture(e,t)}generateMipmaps(e){this.textureUtils.generateMipmaps(e)}destroyTexture(e){this.textureUtils.destroyTexture(e)}copyTextureToBuffer(e,t,s,r,i){return this.textureUtils.copyTextureToBuffer(e,t,s,r,i)}initTimestampQuery(e,t){if(!this.hasFeature(Tb.TimestampQuery)||!this.trackTimestamp)return;const s=this.get(e);if(!s.timeStampQuerySet){const e=this.device.createQuerySet({type:"timestamp",count:2}),r={querySet:e,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1};Object.assign(t,{timestampWrites:r}),s.timeStampQuerySet=e}}prepareTimestampBuffer(e,t){if(!this.hasFeature(Tb.TimestampQuery)||!this.trackTimestamp)return;const s=this.get(e),r=2*BigInt64Array.BYTES_PER_ELEMENT,i=this.device.createBuffer({size:r,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),n=this.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});t.resolveQuerySet(s.timeStampQuerySet,0,2,i,0),t.copyBufferToBuffer(i,0,n,0,r),s.currentTimestampQueryBuffer=n}async resolveTimestampAsync(e,t="render"){if(!this.hasFeature(Tb.TimestampQuery)||!this.trackTimestamp)return;const s=this.get(e),{currentTimestampQueryBuffer:r}=s;if(r){s.currentTimestampQueryBuffer=null,await r.mapAsync(GPUMapMode.READ);const e=new BigUint64Array(r.getMappedRange()),i=Number(e[1]-e[0])/1e6;this.renderer.info.updateTimestamp(t,i),r.unmap()}}createNodeBuilder(e,t,s=null){return new Gb(e,t,s)}createProgram(e){this.get(e).module={module:this.device.createShaderModule({code:e.code,label:e.stage}),entryPoint:"main"}}destroyProgram(e){this.delete(e)}createRenderPipeline(e,t){this.pipelineUtils.createRenderPipeline(e,t)}createComputePipeline(e,t){this.pipelineUtils.createComputePipeline(e,t)}createBindings(e){this.bindingUtils.createBindings(e)}updateBindings(e){this.bindingUtils.createBindings(e)}updateBinding(e){this.bindingUtils.updateBinding(e)}createIndexAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createStorageAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}updateAttribute(e){this.attributeUtils.updateAttribute(e)}destroyAttribute(e){this.attributeUtils.destroyAttribute(e)}updateSize(){this.colorBuffer=this.textureUtils.getColorBuffer(),this.defaultRenderPassdescriptor=null}getMaxAnisotropy(){return 16}async hasFeatureAsync(e){return(this.adapter||await Is.getStaticAdapter()).features.has(e)}hasFeature(e){return!!this.adapter&&this.adapter.features.has(e)}copyFramebufferToTexture(e,t){const s=this.get(t),{encoder:r,descriptor:i}=s;let n=null;n=t.renderTarget?e.isDepthTexture?this.get(t.depthTexture).texture:this.get(t.textures[0]).texture:e.isDepthTexture?this.textureUtils.getDepthBuffer(t.depth,t.stencil):this.context.getCurrentTexture();const o=this.get(e).texture;n.format===o.format&&(s.currentPass.end(),r.copyTextureToTexture({texture:n,origin:{x:0,y:0,z:0}},{texture:o},[e.image.width,e.image.height]),e.generateMipmaps&&this.textureUtils.generateMipmaps(e),i.colorAttachments[0].loadOp=My,t.depth&&(i.depthStencilAttachment.depthLoadOp=My),t.stencil&&(i.depthStencilAttachment.stencilLoadOp=My),s.currentPass=r.beginRenderPass(i),s.currentSets={attributes:{}})}}class Yb extends Fx{constructor(e={}){let t;t=e.forceWebGL?my:Is.isAvailable()?Xb:my;super(new t(e),e),this.isWebGPURenderer=!0}}class Kb extends Fx{constructor(e={},t=!1){let s;s=Is.isAvailable()&&!t?Xb:my;super(new s(e)),this.isWebGPURenderer=!0}}const Qb="requestVideoFrameCallback"in HTMLVideoElement.prototype,Zb=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,Jb=window.cancelAnimationFrame||window.mozCancelAnimationFrame;let eN;class tN{constructor(e,t){this._callback=e,this.video=t,this.animationID=null,this.running=!1}set callback(e){this._callback=e}async animateLegacy(){const e=this.video.currentTime;e>eN&&((1/(e-eN)).toFixed(),await this._callback(e,{width:this.video.videoWidth,height:this.video.videoHeight})),eN=e,this.animationID=Zb((async()=>await this.animateLegacy()))}async animate(e,t){await this._callback(e,t),this.video.requestVideoFrameCallback(this.animateRef)}initAnimate(){this.animateRef=async(e,t)=>await this.animate(e,t),this.video.requestVideoFrameCallback(this.animateRef)}initLegacyAnimate(){this.animateLegacy()}start(){this.stop(),Qb?this.initAnimate():(eN=new Date,this.initLegacyAnimate()),this.running=!0}stop(){this.running=!1,Qb?this.animateRef=()=>{}:Jb(this.animationID&&this.animationID.data&&this.animationID.data.handleId||this.animationID)}}const sN="requestVideoFrameCallback"in HTMLVideoElement.prototype,rN=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,iN=window.cancelAnimationFrame||window.mozCancelAnimationFrame;let nN;class oN{constructor(e,t){this._callback=e,this.video=t,this.animationID=null,this.running=!1,this.updateNodesRef=()=>{}}set nodes(e){this._nodes=e,e&&(this.updateNodesRef=()=>{this._nodes.nodeFrame.update()})}set callback(e){this._callback=e}async animateLegacy(){const e=this.video.currentTime;e>nN&&((1/(e-nN)).toFixed(),this.updateNodesRef(),await this._callback(e,{width:this.video.videoWidth,height:this.video.videoHeight})),nN=e,this.animationID=rN((async()=>await this.animateLegacy()))}async animate(e,t){this.updateNodesRef(),await this._callback(e,t),this.video.requestVideoFrameCallback(this.animateRef)}initAnimate(){this.animateRef=async(e,t)=>await this.animate(e,t),this.video.requestVideoFrameCallback(this.animateRef)}initLegacyAnimate(){this.animateLegacy()}start(){this.stop(),sN?this.initAnimate():(nN=new Date,this.initLegacyAnimate()),this.running=!0}stop(){this.running=!1,sN?this.animateRef=()=>{}:iN(this.animationID&&this.animationID.data&&this.animationID.data.handleId||this.animationID)}}export{_c as AONode,Lg as AfterImageNode,gm as AmbientLightNode,fc as AnalyticLightNode,Dg as AnamorphicNode,wr as ArrayElementNode,tn as AssignNode,on as AttributeNode,Wm as BRDF_GGX,Om as BRDF_Lambert,Kh as BitangentNode,Pp as BlendModeNode,ic as Break,Vl as BufferAttributeNode,du as BufferNode,Hp as BumpMapNode,un as BypassNode,hn as CacheNode,Mu as CameraNode,Tm as CheckerNode,Kn as CodeNode,Yp as ColorAdjustmentNode,Qa as ColorSpaceNode,nm as ComputeNode,Ed as CondNode,Ir as ConstNode,gn as ContextNode,rc as Continue,Mr as ConvertNode,hc as CubeTextureNode,jm as DFGApprox,Hm as D_GGX,dm as DirectionalLightNode,Jd as DiscardNode,ko as EPSILON,Mc as EnvironmentNode,Ac as EquirectUVNode,ru as ExpressionNode,Bm as F_Schlick,Jg as FogExp2Node,Yg as FogNode,Qg as FogRangeNode,od as FrontFacingNode,Gg as FunctionCallNode,to as FunctionNode,sh as FunctionOverloadingNode,Rf as GLSLNodeParser,Bg as GaussianBlurNode,$d as HashNode,mm as HemisphereLightNode,pm as IESSpotLightNode,zo as INFINITY,yi as If,Tn as IndexNode,Hl as InstanceNode,Nm as InstancedPointsNodeMaterial,Fr as JoinNode,am as LightNode,vc as LightingContextNode,bn as LightingModel,gc as LightingNode,xc as LightsNode,Cm as Line2NodeMaterial,vm as LineBasicNodeMaterial,Am as LineDashedNodeMaterial,tc as LoopNode,nh as MatcapUVNode,rl as MaterialNode,bu as MaterialReferenceNode,Go as MathNode,nu as MaxMipLevelNode,Fm as MeshBasicNodeMaterial,Dm as MeshLambertNodeMaterial,wm as MeshNormalNodeMaterial,Gm as MeshPhongNodeMaterial,cf as MeshPhysicalNodeMaterial,hf as MeshSSSNodeMaterial,uf as MeshStandardNodeMaterial,Gu as ModelNode,Pl as ModelViewProjectionNode,uc as MorphNode,Ar as Node,vn as NodeAttribute,Pd as NodeBuilder,dn as NodeCache,Cn as NodeCode,Dd as NodeFrame,Vd as NodeFunctionInput,En as NodeKeywords,ym as NodeLoader,cd as NodeMaterial,xf as NodeMaterialLoader,yf as NodeObjectLoader,lr as NodeShaderStage,dr as NodeType,Sn as NodeUniform,cr as NodeUpdateType,_r as NodeUtils,An as NodeVar,Rn as NodeVarying,rg as NormalMapNode,Xu as NormalNode,_u as Object3DNode,xo as OperatorNode,hh as OscNode,kd as OutputStructNode,$o as PI,Ho as PI2,Th as PackingNode,Xn as ParameterNode,vg as PassNode,Im as PhongLightingModel,of as PhysicalLightingModel,cm as PointLightNode,bp as PointUVNode,gf as PointsNodeMaterial,Ml as PositionNode,ng as PosterizeNode,wn as PropertyNode,rm as RangeNode,Tu as ReferenceNode,cc as ReflectVectorNode,Xh as ReflectorNode,bh as RemapNode,Ah as RotateNode,vh as RotateUVNode,_p as SceneNode,Xm as Schlick_to_F0,qg as ScriptableNode,zg as ScriptableValueNode,Ur as SetNode,li as ShaderNode,Jl as SkinningNode,Cc as SpecularMIPLevelNode,Or as SplitNode,hm as SpotLightNode,ff as SpriteNodeMaterial,Ch as SpriteSheetUVNode,Md as StackNode,wh as StorageArrayElementNode,Ap as StorageBufferNode,rp as TBNViewMatrix,jl as TangentNode,Er as TempNode,xp as TextureBicubicNode,au as TextureNode,Ep as TextureStoreNode,ah as TimerNode,Tg as ToneMappingNode,Fh as TriplanarTexturesNode,go as UVNode,no as UniformGroupNode,ho as UniformNode,gu as UniformsNode,Fp as UserDataNode,$m as V_GGX_SmithCorrelated,Nn as VarNode,rn as VaryingNode,op as VertexColorNode,tN as VideoAnimation,Kc as ViewportDepthNode,Xc as ViewportDepthTextureNode,Lc as ViewportNode,bg as ViewportSharedTextureNode,Hc as ViewportTextureNode,Is as WebGPU,Kb as WebGPUGLRenderer,Yb as WebGPURenderer,oN as WebGPUVideoAnimation,ha as abs,ca as acos,yo as add,Nc as addLightNode,Rr as addNodeClass,Vr as addNodeElement,dd as addNodeMaterial,Ig as afterImage,Wo as all,Vg as anamorphic,Mo as and,jo as any,bi as append,Qi as arrayBuffer,la as asin,sn as assign,da as atan,Sa as atan2,an as attribute,vp as backgroundBlurriness,Sp as backgroundIntensity,Uo as bitAnd,Lo as bitNot,Io as bitOr,Po as bitXor,Qh as bitangentGeometry,Zh as bitangentLocal,Jh as bitangentView,ep as bitangentWorld,va as bitcast,ki as bmat2,Wi as bmat3,Yi as bmat4,Ai as bool,hu as buffer,Gl as bufferAttribute,Wp as bumpMap,Dp as burn,wi as bvec2,Oi as bvec3,Pi as bvec4,ln as bypass,pn as cache,kg as call,Uu as cameraFar,Lu as cameraLogDepth,Ou as cameraNear,Pu as cameraNormalMatrix,Vu as cameraPosition,Fu as cameraProjectionMatrix,Bu as cameraProjectionMatrixInverse,Iu as cameraViewMatrix,Du as cameraWorldMatrix,Va as cbrt,ra as ceil,xm as checker,za as clamp,Ln as clearcoat,In as clearcoatRoughness,Qn as code,Ni as color,eu as colorSpaceToLinear,yh as colorToDirection,om as compute,wd as cond,mn as context,Ji as convert,aa as cos,Cr as createNodeFromType,hd as createNodeMaterialFromType,Oa as cross,pc as cubeTexture,Ta as dFdx,xa as dFdy,Wn as dashSize,pr as defaultBuildStages,hr as defaultShaderStages,Yo as degrees,em as densityFog,sd as depth,Rg as depthPass,id as depthPixel,rd as depthTexture,Fa as difference,Bn as diffuseColor,xh as directionToColor,th as discard,Ma as distance,_o as div,Vp as dodge,Ba as dot,kl as dynamicBufferAttribute,Zi as element,So as equal,qo as equals,Rc as equirectUV,Ko as exp,Qo as exp2,iu as expression,ud as faceDirection,ja as faceForward,_i as float,sa as floor,Kg as fog,na as fract,uo as frameGroup,dh as frameId,ad as frontFacing,_a as fwidth,jd as gain,jn as gapSize,Og as gaussianBlur,ui as getConstNodeType,xi as getCurrentStack,lm as getDistanceAttenuation,km as getGeometryRoughness,zm as getRoughness,jg as global,eo as glsl,ro as glslFn,Co as greaterThan,wo as greaterThanEqual,Hd as hash,Zp as hue,Vi as imat2,$i as imat3,qi as imat4,Wl as instance,yn as instanceIndex,zl as instancedBufferAttribute,$l as instancedDynamicBufferAttribute,vi as int,ta as inverseSqrt,Vn as iridescence,Gn as iridescenceIOR,kn as iridescenceThickness,Ci as ivec2,Fi as ivec3,Li as ivec4,Zn as js,fn as label,ga as length,Ga as lengthSq,Ro as lessThan,Eo as lessThanEqual,um as lightTargetDirection,Sc as lightingContext,yc as lights,bc as lightsNode,Ja as linearToColorSpace,tu as linearTosRGB,Zo as log,Jo as log2,sc as loop,Jp as lumaCoeffs,eg as luminance,Di as mat2,zi as mat3,ji as mat4,oh as matcapUV,il as materialAlphaTest,ml as materialClearcoat,Tl as materialClearcoatNormal,fl as materialClearcoatRoughness,nl as materialColor,al as materialEmissive,Nl as materialIridescence,_l as materialIridescenceIOR,vl as materialIridescenceThickness,El as materialLineDashOffset,Al as materialLineDashSize,Rl as materialLineGapSize,Sl as materialLineScale,Cl as materialLineWidth,pl as materialMetalness,gl as materialNormal,ul as materialOpacity,wl as materialPointWidth,Nu as materialReference,dl as materialReflectivity,xl as materialRotation,hl as materialRoughness,yl as materialSheen,bl as materialSheenRoughness,ol as materialShininess,ll as materialSpecularColor,cl as materialSpecularStrength,Ra as max,ou as maxMipLevel,Un as metalness,Aa as min,ka as mix,Ca as mod,ku as modelDirection,$u as modelNormalMatrix,Wu as modelPosition,ju as modelScale,zu as modelViewMatrix,qu as modelViewPosition,Dl as modelViewProjection,Hu as modelWorldMatrix,lc as morphReference,No as mul,HT as mx_aastep,ox as mx_cell_noise_float,JT as mx_contrast,ax as mx_fractal_noise_float,ux as mx_fractal_noise_vec2,lx as mx_fractal_noise_vec3,cx as mx_fractal_noise_vec4,kT as mx_hsvtorgb,ex as mx_noise_float,tx as mx_noise_vec3,sx as mx_noise_vec4,jT as mx_ramplr,qT as mx_ramptb,zT as mx_rgbtohsv,ZT as mx_safepower,YT as mx_splitlr,KT as mx_splittb,$T as mx_srgb_texture_to_lin_rec709,QT as mx_transform_uv,rx as mx_worley_noise_float,ix as mx_worley_noise_vec2,nx as mx_worley_noise_vec3,ma as negate,hi as nodeArray,gi as nodeImmutable,ci as nodeObject,di as nodeObjects,pi as nodeProxy,Yu as normalGeometry,Ku as normalLocal,ig as normalMap,Qu as normalView,Zu as normalWorld,ia as normalize,Bo as not,vu as objectDirection,co as objectGroup,Au as objectNormalMatrix,Cu as objectPosition,Eu as objectScale,Su as objectViewMatrix,wu as objectViewPosition,Ru as objectWorldMatrix,fa as oneMinus,Fo as or,Zc as orthographicDepthToViewZ,fh as oscSawtooth,ph as oscSine,gh as oscSquare,mh as oscTriangle,Hn as output,zd as outputStruct,Gp as overlay,ih as overloadingFn,Wd as parabola,ip as parallaxDirection,np as parallaxUV,Yn as parameter,Sg as pass,qd as pcurve,ed as perspectiveDepthToViewZ,Np as pointUV,qn as pointWidth,Fl as positionGeometry,Bl as positionLocal,Ll as positionView,Il as positionViewDirection,Ol as positionWorld,Ul as positionWorldDirection,og as posterize,Ua as pow,La as pow2,Ia as pow3,Pa as pow4,Mn as property,Xo as radians,im as range,Zg as rangeFog,ba as reciprocal,xu as reference,yu as referenceBuffer,wa as reflect,dc as reflectVector,Yh as reflector,Ha as refract,vo as remainder,Nh as remap,_h as remapClamp,lo as renderGroup,Rh as rotate,Sh as rotateUV,On as roughness,ya as round,su as sRGBToLinear,cu as sampler,$a as saturate,Kp as saturation,kp as screen,Xg as scriptable,$g as scriptableValue,Ti as setCurrentStack,mi as shader,gr as shaderStages,Pn as sheen,Dn as sheenRoughness,Do as shiftLeft,Vo as shiftRight,$n as shininess,pa as sign,oa as sin,Xd as sinc,ec as skinning,Wa as smoothstep,zn as specularColor,Ec as specularMIPLevel,en as split,Eh as spritesheetUV,ea as sqrt,Fd as stack,Ea as step,Rp as storage,Cp as storageObject,Ki as string,bo as sub,ua as tan,ql as tangentGeometry,Xl as tangentLocal,Yl as tangentView,Kl as tangentWorld,_n as temp,uu as texture,yp as textureBicubic,lu as textureLoad,Mp as textureStore,tg as threshold,ch as timerDelta,lh as timerGlobal,uh as timerLocal,xg as toneMapping,Da as transformDirection,tp as transformedBitangentView,sp as transformedBitangentWorld,tl as transformedClearcoatNormalView,Ju as transformedNormalView,el as transformedNormalWorld,Ql as transformedTangentView,Zl as transformedTangentWorld,Qd as triNoise3D,Oh as triplanarTexture,Bh as triplanarTextures,Na as trunc,fi as tslFn,Si as uint,Gi as umat2,Hi as umat3,Xi as umat4,po as uniform,oo as uniformGroup,mu as uniforms,Bp as userData,mo as uv,Ei as uvec2,Bi as uvec3,Ii as uvec4,nn as varying,Fn as varyingProperty,Ri as vec2,Mi as vec3,Ui as vec4,mr as vectorComponents,ap as vertexColor,xn as vertexIndex,Qp as vibrance,Qc as viewZToOrthographicDepth,Jc as viewZToPerspectiveDepth,Dc as viewport,Gc as viewportBottomLeft,zc as viewportBottomRight,Ic as viewportCoordinate,Yc as viewportDepthTexture,jc as viewportMipTexture,Pc as viewportResolution,Ng as viewportSharedTexture,Wc as viewportTexture,Vc as viewportTopLeft,kc as viewportTopRight,Jn as wgsl,io as wgslFn,Oo as xor};
